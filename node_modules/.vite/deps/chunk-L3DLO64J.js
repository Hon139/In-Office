// node_modules/melonjs/dist/melonjs.module.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var check = function(it) {
  return it && it.Math === Math && it;
};
var global$d = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
);
var global$e = getDefaultExportFromCjs(global$d);
var objectGetOwnPropertyDescriptor = {};
var fails$9 = function(exec) {
  try {
    return !!exec();
  } catch (error2) {
    return true;
  }
};
var fails$a = getDefaultExportFromCjs(fails$9);
var fails$8 = fails$9;
var descriptors = !fails$8(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
});
var descriptors$1 = getDefaultExportFromCjs(descriptors);
var fails$7 = fails$9;
var functionBindNative = !fails$7(function() {
  var test2 = (function() {
  }).bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var functionBindNative$1 = getDefaultExportFromCjs(functionBindNative);
var NATIVE_BIND$1 = functionBindNative;
var call$4 = Function.prototype.call;
var functionCall = NATIVE_BIND$1 ? call$4.bind(call$4) : function() {
  return call$4.apply(call$4, arguments);
};
var functionCall$1 = getDefaultExportFromCjs(functionCall);
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
var f$4 = objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$2 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var createPropertyDescriptor$3 = getDefaultExportFromCjs(createPropertyDescriptor$2);
var NATIVE_BIND = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var call$3 = FunctionPrototype$1.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype$1.bind.bind(call$3, call$3);
var functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$3.apply(fn, arguments);
  };
};
var functionUncurryThis$1 = getDefaultExportFromCjs(functionUncurryThis);
var uncurryThis$a = functionUncurryThis;
var toString$5 = uncurryThis$a({}.toString);
var stringSlice$1 = uncurryThis$a("".slice);
var classofRaw$1 = function(it) {
  return stringSlice$1(toString$5(it), 8, -1);
};
var classofRaw$2 = getDefaultExportFromCjs(classofRaw$1);
var uncurryThis$9 = functionUncurryThis;
var fails$6 = fails$9;
var classof$3 = classofRaw$1;
var $Object$3 = Object;
var split = uncurryThis$9("".split);
var indexedObject = fails$6(function() {
  return !$Object$3("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$3(it) === "String" ? split(it, "") : $Object$3(it);
} : $Object$3;
var indexedObject$1 = getDefaultExportFromCjs(indexedObject);
var isNullOrUndefined$2 = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$3 = getDefaultExportFromCjs(isNullOrUndefined$2);
var isNullOrUndefined$1 = isNullOrUndefined$2;
var $TypeError$5 = TypeError;
var requireObjectCoercible$3 = function(it) {
  if (isNullOrUndefined$1(it)) throw new $TypeError$5("Can't call method on " + it);
  return it;
};
var requireObjectCoercible$4 = getDefaultExportFromCjs(requireObjectCoercible$3);
var IndexedObject = indexedObject;
var requireObjectCoercible$2 = requireObjectCoercible$3;
var toIndexedObject$3 = function(it) {
  return IndexedObject(requireObjectCoercible$2(it));
};
var toIndexedObject$4 = getDefaultExportFromCjs(toIndexedObject$3);
var documentAll = typeof document == "object" && document.all;
var isCallable$b = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
  return typeof argument == "function" || argument === documentAll;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$c = getDefaultExportFromCjs(isCallable$b);
var isCallable$a = isCallable$b;
var isObject$5 = function(it) {
  return typeof it == "object" ? it !== null : isCallable$a(it);
};
var isObject$6 = getDefaultExportFromCjs(isObject$5);
var global$c = global$d;
var isCallable$9 = isCallable$b;
var aFunction = function(argument) {
  return isCallable$9(argument) ? argument : void 0;
};
var getBuiltIn$2 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$c[namespace]) : global$c[namespace] && global$c[namespace][method];
};
var getBuiltIn$3 = getDefaultExportFromCjs(getBuiltIn$2);
var uncurryThis$8 = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);
var objectIsPrototypeOf$1 = getDefaultExportFromCjs(objectIsPrototypeOf);
var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var engineUserAgent$1 = getDefaultExportFromCjs(engineUserAgent);
var global$b = global$d;
var userAgent = engineUserAgent;
var process$1 = global$b.process;
var Deno = global$b.Deno;
var versions = process$1 && process$1.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match;
var version$1;
if (v8) {
  match = v8.split(".");
  version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version$1 && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version$1 = +match[1];
  }
}
var engineV8Version = version$1;
var engineV8Version$1 = getDefaultExportFromCjs(engineV8Version);
var V8_VERSION = engineV8Version;
var fails$5 = fails$9;
var global$a = global$d;
var $String$4 = global$a.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$5(function() {
  var symbol = Symbol("symbol detection");
  return !$String$4(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});
var symbolConstructorDetection$1 = getDefaultExportFromCjs(symbolConstructorDetection);
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var useSymbolAsUid$1 = getDefaultExportFromCjs(useSymbolAsUid);
var getBuiltIn$1 = getBuiltIn$2;
var isCallable$8 = isCallable$b;
var isPrototypeOf = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$2 = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn$1("Symbol");
  return isCallable$8($Symbol) && isPrototypeOf($Symbol.prototype, $Object$2(it));
};
var isSymbol$3 = getDefaultExportFromCjs(isSymbol$2);
var $String$3 = String;
var tryToString$1 = function(argument) {
  try {
    return $String$3(argument);
  } catch (error2) {
    return "Object";
  }
};
var tryToString$2 = getDefaultExportFromCjs(tryToString$1);
var isCallable$7 = isCallable$b;
var tryToString = tryToString$1;
var $TypeError$4 = TypeError;
var aCallable$1 = function(argument) {
  if (isCallable$7(argument)) return argument;
  throw new $TypeError$4(tryToString(argument) + " is not a function");
};
var aCallable$2 = getDefaultExportFromCjs(aCallable$1);
var aCallable = aCallable$1;
var isNullOrUndefined = isNullOrUndefined$2;
var getMethod$1 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? void 0 : aCallable(func);
};
var getMethod$2 = getDefaultExportFromCjs(getMethod$1);
var call$2 = functionCall;
var isCallable$6 = isCallable$b;
var isObject$4 = isObject$5;
var $TypeError$3 = TypeError;
var ordinaryToPrimitive$1 = function(input2, pref) {
  var fn, val;
  if (pref === "string" && isCallable$6(fn = input2.toString) && !isObject$4(val = call$2(fn, input2))) return val;
  if (isCallable$6(fn = input2.valueOf) && !isObject$4(val = call$2(fn, input2))) return val;
  if (pref !== "string" && isCallable$6(fn = input2.toString) && !isObject$4(val = call$2(fn, input2))) return val;
  throw new $TypeError$3("Can't convert object to primitive value");
};
var ordinaryToPrimitive$2 = getDefaultExportFromCjs(ordinaryToPrimitive$1);
var sharedStore$2 = { exports: {} };
var isPure = false;
var isPure$1 = getDefaultExportFromCjs(isPure);
var global$9 = global$d;
var defineProperty$1 = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$1(global$9, key, { value, configurable: true, writable: true });
  } catch (error2) {
    global$9[key] = value;
  }
  return value;
};
var defineGlobalProperty$4 = getDefaultExportFromCjs(defineGlobalProperty$3);
var sharedStore = sharedStore$2.exports;
var IS_PURE = isPure;
var globalThis$3 = global$d;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = sharedStore$2.exports = globalThis$3[SHARED] || defineGlobalProperty$2(SHARED, {});
(store$3.versions || (store$3.versions = [])).push({
  version: "3.37.1",
  mode: IS_PURE ? "pure" : "global",
  copyright: "Â© 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var sharedStoreExports = sharedStore$2.exports;
var sharedStore$1 = getDefaultExportFromCjs(sharedStoreExports);
var store$2 = sharedStoreExports;
var shared$3 = function(key, value) {
  return store$2[key] || (store$2[key] = value || {});
};
var shared$4 = getDefaultExportFromCjs(shared$3);
var requireObjectCoercible$1 = requireObjectCoercible$3;
var $Object$1 = Object;
var toObject$1 = function(argument) {
  return $Object$1(requireObjectCoercible$1(argument));
};
var toObject$2 = getDefaultExportFromCjs(toObject$1);
var uncurryThis$7 = functionUncurryThis;
var toObject = toObject$1;
var hasOwnProperty = uncurryThis$7({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};
var hasOwnProperty$1 = getDefaultExportFromCjs(hasOwnProperty_1);
var uncurryThis$6 = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString$4 = uncurryThis$6(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$4(++id + postfix, 36);
};
var uid$3 = getDefaultExportFromCjs(uid$2);
var global$8 = global$d;
var shared$2 = shared$3;
var hasOwn$6 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$1 = global$8.Symbol;
var WellKnownSymbolsStore = shared$2("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1["for"] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
var wellKnownSymbol$3 = function(name) {
  if (!hasOwn$6(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$6(Symbol$1, name) ? Symbol$1[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore[name];
};
var wellKnownSymbol$4 = getDefaultExportFromCjs(wellKnownSymbol$3);
var call$1 = functionCall;
var isObject$3 = isObject$5;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$2 = wellKnownSymbol$3;
var $TypeError$2 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$2("toPrimitive");
var toPrimitive$1 = function(input2, pref) {
  if (!isObject$3(input2) || isSymbol$1(input2)) return input2;
  var exoticToPrim = getMethod(input2, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$1(exoticToPrim, input2, pref);
    if (!isObject$3(result) || isSymbol$1(result)) return result;
    throw new $TypeError$2("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive(input2, pref);
};
var toPrimitive$2 = getDefaultExportFromCjs(toPrimitive$1);
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$2 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var toPropertyKey$3 = getDefaultExportFromCjs(toPropertyKey$2);
var global$7 = global$d;
var isObject$2 = isObject$5;
var document$1 = global$7.document;
var EXISTS$1 = isObject$2(document$1) && isObject$2(document$1.createElement);
var documentCreateElement = function(it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};
var documentCreateElement$1 = getDefaultExportFromCjs(documentCreateElement);
var DESCRIPTORS$6 = descriptors;
var fails$4 = fails$9;
var createElement = documentCreateElement;
var ie8DomDefine = !DESCRIPTORS$6 && !fails$4(function() {
  return Object.defineProperty(createElement("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
});
var ie8DomDefine$1 = getDefaultExportFromCjs(ie8DomDefine);
var DESCRIPTORS$5 = descriptors;
var call = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject$2 = toIndexedObject$3;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$5 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var f$3 = objectGetOwnPropertyDescriptor.f = DESCRIPTORS$5 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$2(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error2) {
  }
  if (hasOwn$5(O, P)) return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};
var objectDefineProperty = {};
var DESCRIPTORS$4 = descriptors;
var fails$3 = fails$9;
var v8PrototypeDefineBug = DESCRIPTORS$4 && fails$3(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype !== 42;
});
var v8PrototypeDefineBug$1 = getDefaultExportFromCjs(v8PrototypeDefineBug);
var isObject$1 = isObject$5;
var $String$2 = String;
var $TypeError$1 = TypeError;
var anObject$2 = function(argument) {
  if (isObject$1(argument)) return argument;
  throw new $TypeError$1($String$2(argument) + " is not an object");
};
var anObject$3 = getDefaultExportFromCjs(anObject$2);
var DESCRIPTORS$3 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var anObject$1 = anObject$2;
var toPropertyKey = toPropertyKey$2;
var $TypeError = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
var f$2 = objectDefineProperty.f = DESCRIPTORS$3 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject$1(O);
  P = toPropertyKey(P);
  anObject$1(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty2(O, P, Attributes) {
  anObject$1(O);
  P = toPropertyKey(P);
  anObject$1(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error2) {
  }
  if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
  if ("value" in Attributes) O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$2 = descriptors;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;
var createNonEnumerableProperty$2 = DESCRIPTORS$2 ? function(object, key, value) {
  return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var createNonEnumerableProperty$3 = getDefaultExportFromCjs(createNonEnumerableProperty$2);
var makeBuiltIn$3 = { exports: {} };
var DESCRIPTORS$1 = descriptors;
var hasOwn$4 = hasOwnProperty_1;
var FunctionPrototype = Function.prototype;
var getDescriptor = DESCRIPTORS$1 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$4(FunctionPrototype, "name");
var PROPER = EXISTS && (function something() {
}).name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$1 || DESCRIPTORS$1 && getDescriptor(FunctionPrototype, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var functionName$1 = getDefaultExportFromCjs(functionName);
var uncurryThis$5 = functionUncurryThis;
var isCallable$5 = isCallable$b;
var store$1 = sharedStoreExports;
var functionToString = uncurryThis$5(Function.toString);
if (!isCallable$5(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString(it);
  };
}
var inspectSource$1 = store$1.inspectSource;
var inspectSource$2 = getDefaultExportFromCjs(inspectSource$1);
var global$6 = global$d;
var isCallable$4 = isCallable$b;
var WeakMap$1 = global$6.WeakMap;
var weakMapBasicDetection = isCallable$4(WeakMap$1) && /native code/.test(String(WeakMap$1));
var weakMapBasicDetection$1 = getDefaultExportFromCjs(weakMapBasicDetection);
var shared$1 = shared$3;
var uid = uid$2;
var keys = shared$1("keys");
var sharedKey$1 = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var sharedKey$2 = getDefaultExportFromCjs(sharedKey$1);
var hiddenKeys$3 = {};
var hiddenKeys$4 = getDefaultExportFromCjs(hiddenKeys$3);
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$5 = global$d;
var isObject = isObject$5;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
var hasOwn$3 = hasOwnProperty_1;
var shared = sharedStoreExports;
var sharedKey = sharedKey$1;
var hiddenKeys$2 = hiddenKeys$3;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$1 = global$5.TypeError;
var WeakMap = global$5.WeakMap;
var set;
var get$1;
var has;
var enforce = function(it) {
  return has(it) ? get$1(it) : set(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state2;
    if (!isObject(it) || (state2 = get$1(it)).type !== TYPE) {
      throw new TypeError$1("Incompatible receiver, " + TYPE + " required");
    }
    return state2;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  store = shared.state || (shared.state = new WeakMap());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set = function(it, metadata) {
    if (store.has(it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get$1 = function(it) {
    return store.get(it) || {};
  };
  has = function(it) {
    return store.has(it);
  };
} else {
  STATE = sharedKey("state");
  hiddenKeys$2[STATE] = true;
  set = function(it, metadata) {
    if (hasOwn$3(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$1(it, STATE, metadata);
    return metadata;
  };
  get$1 = function(it) {
    return hasOwn$3(it, STATE) ? it[STATE] : {};
  };
  has = function(it) {
    return hasOwn$3(it, STATE);
  };
}
var store;
var STATE;
var internalState = {
  set,
  get: get$1,
  has,
  enforce,
  getterFor
};
var internalState$1 = getDefaultExportFromCjs(internalState);
var makeBuiltIn_1 = makeBuiltIn$3.exports;
var uncurryThis$4 = functionUncurryThis;
var fails$2 = fails$9;
var isCallable$3 = isCallable$b;
var hasOwn$2 = hasOwnProperty_1;
var DESCRIPTORS = descriptors;
var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
var inspectSource = inspectSource$1;
var InternalStateModule = internalState;
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String$1 = String;
var defineProperty3 = Object.defineProperty;
var stringSlice = uncurryThis$4("".slice);
var replace$1 = uncurryThis$4("".replace);
var join = uncurryThis$4([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails$2(function() {
  return defineProperty3(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$1 = makeBuiltIn$3.exports = function(value, name, options) {
  if (stringSlice($String$1(name), 0, 7) === "Symbol(") {
    name = "[" + replace$1($String$1(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (!hasOwn$2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
    if (DESCRIPTORS) defineProperty3(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, "arity") && value.length !== options.arity) {
    defineProperty3(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$2(options, "constructor") && options.constructor) {
      if (DESCRIPTORS) defineProperty3(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error2) {
  }
  var state2 = enforceInternalState(value);
  if (!hasOwn$2(state2, "source")) {
    state2.source = join(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$1(function toString2() {
  return isCallable$3(this) && getInternalState(this).source || inspectSource(this);
}, "toString");
var makeBuiltInExports = makeBuiltIn$3.exports;
var makeBuiltIn$2 = getDefaultExportFromCjs(makeBuiltInExports);
var isCallable$2 = isCallable$b;
var definePropertyModule$1 = objectDefineProperty;
var makeBuiltIn = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$1 = function(O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$2(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error2) {
    }
    if (simple) O[key] = value;
    else definePropertyModule$1.f(O, key, {
      value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  }
  return O;
};
var defineBuiltIn$2 = getDefaultExportFromCjs(defineBuiltIn$1);
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor = Math.floor;
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};
var mathTrunc$1 = getDefaultExportFromCjs(mathTrunc);
var trunc2 = mathTrunc;
var toIntegerOrInfinity$2 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2(number);
};
var toIntegerOrInfinity$3 = getDefaultExportFromCjs(toIntegerOrInfinity$2);
var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
var max = Math.max;
var min$1 = Math.min;
var toAbsoluteIndex$1 = function(index2, length) {
  var integer = toIntegerOrInfinity$1(index2);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};
var toAbsoluteIndex$2 = getDefaultExportFromCjs(toAbsoluteIndex$1);
var toIntegerOrInfinity = toIntegerOrInfinity$2;
var min = Math.min;
var toLength$1 = function(argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 9007199254740991) : 0;
};
var toLength$2 = getDefaultExportFromCjs(toLength$1);
var toLength = toLength$1;
var lengthOfArrayLike$1 = function(obj) {
  return toLength(obj.length);
};
var lengthOfArrayLike$2 = getDefaultExportFromCjs(lengthOfArrayLike$1);
var toIndexedObject$1 = toIndexedObject$3;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike = lengthOfArrayLike$1;
var createMethod$1 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$1($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index2 = toAbsoluteIndex(fromIndex, length);
    var value;
    if (IS_INCLUDES && el !== el) while (length > index2) {
      value = O[index2++];
      if (value !== value) return true;
    }
    else for (; length > index2; index2++) {
      if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$1(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$1(false)
};
var arrayIncludes$1 = getDefaultExportFromCjs(arrayIncludes);
var uncurryThis$3 = functionUncurryThis;
var hasOwn$1 = hasOwnProperty_1;
var toIndexedObject = toIndexedObject$3;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$1 = hiddenKeys$3;
var push = uncurryThis$3([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$1(hiddenKeys$1, key) && hasOwn$1(O, key) && push(result, key);
  while (names.length > i) if (hasOwn$1(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};
var objectKeysInternal$1 = getDefaultExportFromCjs(objectKeysInternal);
var enumBugKeys$1 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var enumBugKeys$2 = getDefaultExportFromCjs(enumBugKeys$1);
var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$1;
var hiddenKeys = enumBugKeys.concat("length", "prototype");
var f$1 = objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};
var objectGetOwnPropertySymbols = {};
var f = objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn = getBuiltIn$2;
var uncurryThis$2 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject = anObject$2;
var concat = uncurryThis$2([].concat);
var ownKeys$1 = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
  var keys2 = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
};
var ownKeys$2 = getDefaultExportFromCjs(ownKeys$1);
var hasOwn2 = hasOwnProperty_1;
var ownKeys2 = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys2 = ownKeys2(source);
  var defineProperty4 = definePropertyModule.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var copyConstructorProperties$2 = getDefaultExportFromCjs(copyConstructorProperties$1);
var fails$1 = fails$9;
var isCallable$1 = isCallable$b;
var replacement = /#|\.prototype\./;
var isForced$1 = function(feature, detection) {
  var value = data$1[normalize$1(feature)];
  return value === POLYFILL ? true : value === NATIVE ? false : isCallable$1(detection) ? fails$1(detection) : !!detection;
};
var normalize$1 = isForced$1.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data$1 = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = "N";
var POLYFILL = isForced$1.POLYFILL = "P";
var isForced_1 = isForced$1;
var isForced$2 = getDefaultExportFromCjs(isForced_1);
var global$4 = global$d;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty = createNonEnumerableProperty$2;
var defineBuiltIn = defineBuiltIn$1;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$4;
  } else if (STATIC) {
    target = global$4[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global$4[TARGET] && global$4[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor2(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    if (!FORCED && targetProperty !== void 0) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, "sham", true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};
var _export$1 = getDefaultExportFromCjs(_export);
var $$4 = _export;
var global$3 = global$d;
$$4({ global: true, forced: global$3.globalThis !== global$3 }, {
  globalThis: global$3
});
var global$2 = global$d;
var globalThis$1 = global$2;
var globalThis$2 = getDefaultExportFromCjs(globalThis$1);
var wellKnownSymbol$1 = wellKnownSymbol$3;
var TO_STRING_TAG$1 = wellKnownSymbol$1("toStringTag");
var test = {};
test[TO_STRING_TAG$1] = "z";
var toStringTagSupport = String(test) === "[object z]";
var toStringTagSupport$1 = getDefaultExportFromCjs(toStringTagSupport);
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable = isCallable$b;
var classofRaw = classofRaw$1;
var wellKnownSymbol = wellKnownSymbol$3;
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var $Object = Object;
var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error2) {
  }
};
var classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
};
var classof$2 = getDefaultExportFromCjs(classof$1);
var classof = classof$1;
var $String = String;
var toString$2 = function(argument) {
  if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return $String(argument);
};
var toString$3 = getDefaultExportFromCjs(toString$2);
var whitespaces$2 = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
var whitespaces$3 = getDefaultExportFromCjs(whitespaces$2);
var uncurryThis$1 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$3;
var toString$1 = toString$2;
var whitespaces$1 = whitespaces$2;
var replace = uncurryThis$1("".replace);
var ltrim = RegExp("^[" + whitespaces$1 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$1 + "])[" + whitespaces$1 + "]+$");
var createMethod = function(TYPE) {
  return function($this) {
    var string = toString$1(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, "");
    if (TYPE & 2) string = replace(string, rtrim, "$1");
    return string;
  };
};
var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};
var stringTrim$1 = getDefaultExportFromCjs(stringTrim);
var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails = fails$9;
var whitespaces = whitespaces$2;
var non = "âÂá ";
var stringTrimForced = function(METHOD_NAME) {
  return fails(function() {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};
var stringTrimForced$1 = getDefaultExportFromCjs(stringTrimForced);
var $trimStart = stringTrim.start;
var forcedStringTrimMethod$1 = stringTrimForced;
var stringTrimStart = forcedStringTrimMethod$1("trimStart") ? function trimStart() {
  return $trimStart(this);
} : "".trimStart;
var stringTrimStart$1 = getDefaultExportFromCjs(stringTrimStart);
var $$3 = _export;
var trimStart$3 = stringTrimStart;
$$3({ target: "String", proto: true, name: "trimStart", forced: "".trimLeft !== trimStart$3 }, {
  trimLeft: trimStart$3
});
var $$2 = _export;
var trimStart$2 = stringTrimStart;
$$2({ target: "String", proto: true, name: "trimStart", forced: "".trimStart !== trimStart$2 }, {
  trimStart: trimStart$2
});
var global$1 = global$d;
var uncurryThis = functionUncurryThis;
var entryUnbind$2 = function(CONSTRUCTOR, METHOD) {
  return uncurryThis(global$1[CONSTRUCTOR].prototype[METHOD]);
};
var entryUnbind$3 = getDefaultExportFromCjs(entryUnbind$2);
var entryUnbind$1 = entryUnbind$2;
var trimStart2 = entryUnbind$1("String", "trimLeft");
var trimStart$1 = getDefaultExportFromCjs(trimStart2);
var $trimEnd = stringTrim.end;
var forcedStringTrimMethod = stringTrimForced;
var stringTrimEnd = forcedStringTrimMethod("trimEnd") ? function trimEnd() {
  return $trimEnd(this);
} : "".trimEnd;
var stringTrimEnd$1 = getDefaultExportFromCjs(stringTrimEnd);
var $$1 = _export;
var trimEnd$3 = stringTrimEnd;
$$1({ target: "String", proto: true, name: "trimEnd", forced: "".trimRight !== trimEnd$3 }, {
  trimRight: trimEnd$3
});
var $ = _export;
var trimEnd$2 = stringTrimEnd;
$({ target: "String", proto: true, name: "trimEnd", forced: "".trimEnd !== trimEnd$2 }, {
  trimEnd: trimEnd$2
});
var entryUnbind = entryUnbind$2;
var trimEnd2 = entryUnbind("String", "trimRight");
var trimEnd$1 = getDefaultExportFromCjs(trimEnd2);
if (typeof globalThis !== "undefined") {
  if (typeof globalThis.console === "undefined") {
    globalThis.console = {};
    globalThis.console.log = function() {
    };
    globalThis.console.assert = function() {
    };
    globalThis.console.warn = function() {
    };
    globalThis.console.error = function() {
      alert(Array.prototype.slice.call(arguments).join(", "));
    };
  }
}
(() => {
  "use strict";
  function roundRect(x, y, w, h, radii) {
    if (![x, y, w, h].every((input2) => Number.isFinite(input2))) {
      return;
    }
    radii = parseRadiiArgument(radii);
    let upperLeft, upperRight, lowerRight, lowerLeft;
    if (radii.length === 4) {
      upperLeft = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[1]);
      lowerRight = toCornerPoint(radii[2]);
      lowerLeft = toCornerPoint(radii[3]);
    } else if (radii.length === 3) {
      upperLeft = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[1]);
      lowerLeft = toCornerPoint(radii[1]);
      lowerRight = toCornerPoint(radii[2]);
    } else if (radii.length === 2) {
      upperLeft = toCornerPoint(radii[0]);
      lowerRight = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[1]);
      lowerLeft = toCornerPoint(radii[1]);
    } else if (radii.length === 1) {
      upperLeft = toCornerPoint(radii[0]);
      upperRight = toCornerPoint(radii[0]);
      lowerRight = toCornerPoint(radii[0]);
      lowerLeft = toCornerPoint(radii[0]);
    } else {
      throw new Error(radii.length + " is not a valid size for radii sequence.");
    }
    const corners = [upperLeft, upperRight, lowerRight, lowerLeft];
    const negativeCorner = corners.find(({ x: x2, y: y2 }) => x2 < 0 || y2 < 0);
    if (corners.some(({ x: x2, y: y2 }) => !Number.isFinite(x2) || !Number.isFinite(y2))) {
      return;
    }
    if (negativeCorner) {
      throw new Error("Radius value " + negativeCorner + " is negative.");
    }
    fixOverlappingCorners(corners);
    if (w < 0 && h < 0) {
      this.moveTo(x - upperLeft.x, y);
      this.ellipse(x + w + upperRight.x, y - upperRight.y, upperRight.x, upperRight.y, 0, -Math.PI * 1.5, -Math.PI);
      this.ellipse(x + w + lowerRight.x, y + h + lowerRight.y, lowerRight.x, lowerRight.y, 0, -Math.PI, -Math.PI / 2);
      this.ellipse(x - lowerLeft.x, y + h + lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, -Math.PI / 2, 0);
      this.ellipse(x - upperLeft.x, y - upperLeft.y, upperLeft.x, upperLeft.y, 0, 0, -Math.PI / 2);
    } else if (w < 0) {
      this.moveTo(x - upperLeft.x, y);
      this.ellipse(x + w + upperRight.x, y + upperRight.y, upperRight.x, upperRight.y, 0, -Math.PI / 2, -Math.PI, 1);
      this.ellipse(x + w + lowerRight.x, y + h - lowerRight.y, lowerRight.x, lowerRight.y, 0, -Math.PI, -Math.PI * 1.5, 1);
      this.ellipse(x - lowerLeft.x, y + h - lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, Math.PI / 2, 0, 1);
      this.ellipse(x - upperLeft.x, y + upperLeft.y, upperLeft.x, upperLeft.y, 0, 0, -Math.PI / 2, 1);
    } else if (h < 0) {
      this.moveTo(x + upperLeft.x, y);
      this.ellipse(x + w - upperRight.x, y - upperRight.y, upperRight.x, upperRight.y, 0, Math.PI / 2, 0, 1);
      this.ellipse(x + w - lowerRight.x, y + h + lowerRight.y, lowerRight.x, lowerRight.y, 0, 0, -Math.PI / 2, 1);
      this.ellipse(x + lowerLeft.x, y + h + lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, -Math.PI / 2, -Math.PI, 1);
      this.ellipse(x + upperLeft.x, y - upperLeft.y, upperLeft.x, upperLeft.y, 0, -Math.PI, -Math.PI * 1.5, 1);
    } else {
      this.moveTo(x + upperLeft.x, y);
      this.ellipse(x + w - upperRight.x, y + upperRight.y, upperRight.x, upperRight.y, 0, -Math.PI / 2, 0);
      this.ellipse(x + w - lowerRight.x, y + h - lowerRight.y, lowerRight.x, lowerRight.y, 0, 0, Math.PI / 2);
      this.ellipse(x + lowerLeft.x, y + h - lowerLeft.y, lowerLeft.x, lowerLeft.y, 0, Math.PI / 2, Math.PI);
      this.ellipse(x + upperLeft.x, y + upperLeft.y, upperLeft.x, upperLeft.y, 0, Math.PI, Math.PI * 1.5);
    }
    this.closePath();
    this.moveTo(x, y);
    function toDOMPointInit(value) {
      const { x: x2, y: y2, z, w: w2 } = value;
      return { x: x2, y: y2, z, w: w2 };
    }
    function parseRadiiArgument(value) {
      const type = typeof value;
      if (type === "undefined" || value === null) {
        return [0];
      }
      if (type === "function") {
        return [NaN];
      }
      if (type === "object") {
        if (typeof value[Symbol.iterator] === "function") {
          return [...value].map((elem) => {
            const elemType = typeof elem;
            if (elemType === "undefined" || elem === null) {
              return 0;
            }
            if (elemType === "function") {
              return NaN;
            }
            if (elemType === "object") {
              return toDOMPointInit(elem);
            }
            return toUnrestrictedNumber(elem);
          });
        }
        return [toDOMPointInit(value)];
      }
      return [toUnrestrictedNumber(value)];
    }
    function toUnrestrictedNumber(value) {
      return +value;
    }
    function toCornerPoint(value) {
      const asNumber = toUnrestrictedNumber(value);
      if (Number.isFinite(asNumber)) {
        return {
          x: asNumber,
          y: asNumber
        };
      }
      if (Object(value) === value) {
        return {
          x: toUnrestrictedNumber(value.x || 0),
          y: toUnrestrictedNumber(value.y || 0)
        };
      }
      return {
        x: NaN,
        y: NaN
      };
    }
    function fixOverlappingCorners(corners2) {
      const [upperLeft2, upperRight2, lowerRight2, lowerLeft2] = corners2;
      const factors = [
        Math.abs(w) / (upperLeft2.x + upperRight2.x),
        Math.abs(h) / (upperRight2.y + lowerRight2.y),
        Math.abs(w) / (lowerRight2.x + lowerLeft2.x),
        Math.abs(h) / (upperLeft2.y + lowerLeft2.y)
      ];
      const minFactor = Math.min(...factors);
      if (minFactor <= 1) {
        corners2.forEach((radii2) => {
          radii2.x *= minFactor;
          radii2.y *= minFactor;
        });
      }
    }
  }
  if (globalThis.CanvasRenderingContext2D) {
    if (typeof globalThis.Path2D.prototype.roundRect === "undefined") {
      globalThis.Path2D.prototype.roundRect = roundRect;
    }
  }
  if (globalThis.CanvasRenderingContext2D) {
    if (typeof globalThis.CanvasRenderingContext2D.prototype.roundRect === "undefined") {
      globalThis.CanvasRenderingContext2D.prototype.roundRect = roundRect;
    }
  }
  if (globalThis.OffscreenCanvasRenderingContext2D) {
    if (typeof globalThis.OffscreenCanvasRenderingContext2D.prototype.roundRect === "undefined") {
      globalThis.OffscreenCanvasRenderingContext2D.prototype.roundRect = roundRect;
    }
  }
})();
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match2 = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match2 ? match2[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body$1() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode$1);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input2, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input2 instanceof Request) {
    if (input2.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input2.url;
    this.credentials = input2.credentials;
    if (!options.headers) {
      this.headers = new Headers(input2.headers);
    }
    this.method = input2.method;
    this.mode = input2.mode;
    this.signal = input2.signal;
    if (!body && input2._bodyInit != null) {
      body = input2._bodyInit;
      input2.bodyUsed = true;
    }
  } else {
    this.url = String(input2);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode$1(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split2 = bytes.split("=");
      var name = split2.shift().replace(/\+/g, " ");
      var value = split2.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error2) {
        console.warn("Response " + error2.message);
      }
    }
  });
  return headers;
}
Body$1.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body$1.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error2 = Error(message);
    this.stack = error2.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch$1(input2, init2) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input2, init2);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers || g.Headers && init2.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch$1.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch$1;
  g.Headers = Headers;
  g.Request = Request;
  g.Response = Response;
}
var DEG_TO_RAD = Math.PI / 180;
var RAD_TO_DEG = 180 / Math.PI;
var TAU = Math.PI * 2;
var ETA = Math.PI * 0.5;
var EPSILON = 1e-6;
function isPowerOfTwo(val) {
  return (val & val - 1) === 0;
}
function isPowerOfFour(val) {
  if (val === 0 || val === 2 || val === 3) {
    return false;
  }
  if (val === 1) {
    return true;
  }
  if ((val & val - 1) === 0) {
    if ((val & 2863311530) === 0) {
      return true;
    }
  }
  return false;
}
function nextPowerOfTwo(val) {
  val--;
  val |= val >> 1;
  val |= val >> 2;
  val |= val >> 4;
  val |= val >> 8;
  val |= val >> 16;
  val++;
  return val;
}
function degToRad(angle) {
  return angle * DEG_TO_RAD;
}
function radToDeg(radians) {
  return radians * RAD_TO_DEG;
}
function clamp(val, low, high) {
  return val < low ? low : val > high ? high : +val;
}
function random$1(min2, max2) {
  return ~~(Math.random() * (max2 - min2)) + min2;
}
function randomFloat(min2, max2) {
  return Math.random() * (max2 - min2) + min2;
}
function weightedRandom$1(min2, max2) {
  return ~~(Math.pow(Math.random(), 2) * (max2 - min2)) + min2;
}
function round(num, dec = 0) {
  const powres = Math.pow(10, dec);
  return ~~(0.5 + num * powres) / powres;
}
function toBeCloseTo(expected, actual, precision = 2) {
  return Math.abs(expected - actual) < Math.pow(10, -precision) / 2;
}
function pow(n) {
  return Math.pow(n, 2);
}
var math = {
  __proto__: null,
  DEG_TO_RAD,
  EPSILON,
  ETA,
  RAD_TO_DEG,
  TAU,
  clamp,
  degToRad,
  isPowerOfFour,
  isPowerOfTwo,
  nextPowerOfTwo,
  pow,
  radToDeg,
  random: random$1,
  randomFloat,
  round,
  toBeCloseTo,
  weightedRandom: weightedRandom$1
};
var ObjectPool = class {
  constructor() {
    this.objectClass = {};
    this.instance_counter = 0;
  }
  /**
   * register an object to the pool. <br>
   * Pooling must be set to true if more than one such objects will be created. <br>
   * (Note: for an object to be poolable, it must implements a `onResetEvent` method)
   * @param {string} className - as defined in the Name field of the Object Properties (in Tiled)
   * @param {object} classObj - corresponding Class to be instantiated
   * @param {boolean} [recycling=false] - enables object recycling for the specified class
   * @example
   * // implement CherryEntity
   * class Cherry extends Sprite {
   *    onResetEvent() {
   *        // reset object mutable properties
   *        this.lifeBar = 100;
   *    }
   * };
   * // add our users defined entities in the object pool and enable object recycling
   * me.pool.register("cherrysprite", Cherry, true);
   */
  register(className, classObj, recycling = false) {
    if (typeof classObj !== "undefined") {
      this.objectClass[className] = {
        "class": classObj,
        "pool": recycling ? [] : void 0
      };
    } else {
      throw new Error("Cannot register object '" + className + "', invalid class");
    }
  }
  /**
   * Pull a new instance of the requested object (if added into the object pool)
   * @param {string} name - as used in {@link pool.register}
   * @param {...*} [args] - arguments to be passed when instantiating/reinitializing the object
   * @returns {object} the instance of the requested object
   * @example
   * me.pool.register("bullet", BulletEntity, true);
   * me.pool.register("enemy", EnemyEntity, true);
   * // ...
   * // when we need to manually create a new bullet:
   * let bullet = me.pool.pull("bullet", x, y, direction);
   * // ...
   * // params aren't a fixed number
   * // when we need new enemy we can add more params, that the object construct requires:
   * let enemy = me.pool.pull("enemy", x, y, direction, speed, power, life);
   * // ...
   * // when we want to destroy existing object, the remove
   * // function will ensure the object can then be reallocated later
   * me.game.world.removeChild(enemy);
   * me.game.world.removeChild(bullet);
   */
  pull(name, ...args) {
    let className = this.objectClass[name];
    if (className) {
      let proto = className["class"], poolArray = className.pool, obj;
      if (poolArray && (obj = poolArray.pop())) {
        obj.onResetEvent.apply(obj, args);
        this.instance_counter--;
      } else {
        obj = new (proto.bind.apply(proto, [proto, ...args]))();
        if (poolArray) {
          obj.className = name;
        }
      }
      return obj;
    }
    throw new Error("Cannot instantiate object of type '" + name + "'");
  }
  /**
   * purge the object pool from any inactive object <br>
   * Object pooling must be enabled for this function to work<br>
   * note: this will trigger the garbage collector
   */
  purge() {
    for (let className in this.objectClass) {
      if (this.objectClass[className]) {
        this.objectClass[className].pool = [];
      }
    }
    this.instance_counter = 0;
  }
  /**
   * Push back an object instance into the object pool <br>
   * Object pooling for the object class must be enabled,
   * and object must have been instantiated using {@link pool#pull},
   * otherwise this function won't work
   * @throws will throw an error if the object cannot be recycled
   * @param {object} obj - instance to be recycled
   * @param {boolean} [throwOnError=true] - throw an exception if the object cannot be recycled
   * @returns {boolean} true if the object was successfully recycled in the object pool
   */
  push(obj, throwOnError = true) {
    if (!this.poolable(obj)) {
      if (throwOnError === true) {
        throw new Error("me.pool: object " + obj + " cannot be recycled");
      } else {
        return false;
      }
    }
    this.objectClass[obj.className].pool.push(obj);
    this.instance_counter++;
    return true;
  }
  /**
   * Check if an object with the provided name is registered
   * @param {string} name - of the registered object class
   * @returns {boolean} true if the classname is registered
   */
  exists(name) {
    return name in this.objectClass;
  }
  /**
   * Check if an object is poolable
   * (was properly registered with the recycling feature enable)
   * @see register
   * @param {object} obj - object to be checked
   * @returns {boolean} true if the object is poolable
   * @example
   * if (!me.pool.poolable(myCherryEntity)) {
   *     // object was not properly registered
   * }
   */
  poolable(obj) {
    let className = obj.className;
    return typeof className !== "undefined" && typeof obj.onResetEvent === "function" && className in this.objectClass && typeof this.objectClass[className].pool !== "undefined";
  }
  /**
   * returns the amount of object instance currently in the pool
   * @returns {number} amount of object instance
   */
  getInstanceCount() {
    return this.instance_counter;
  }
};
var pool = new ObjectPool();
var charLookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
function toHex$1(component) {
  return charLookup[(component & 240) >> 4] + charLookup[component & 15];
}
function hue2rgb(p, q, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p + (q - p) * 6 * t2;
  if (t2 < 1 / 2) return q;
  if (t2 < 2 / 3) return p + (q - p) * (2 / 3 - t2) * 6;
  return p;
}
var rgbaRx = /^rgba?\((\d+), ?(\d+), ?(\d+)(, ?([\d\.]+))?\)$/;
var hex3Rx = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])$/;
var hex4Rx = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])([\da-fA-F])$/;
var hex6Rx = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/;
var hex8Rx = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/;
var cssToRGB = /* @__PURE__ */ new Map();
[
  // CSS1
  ["black", [0, 0, 0]],
  ["silver", [192, 192, 129]],
  ["gray", [128, 128, 128]],
  ["white", [255, 255, 255]],
  ["maroon", [128, 0, 0]],
  ["red", [255, 0, 0]],
  ["purple", [128, 0, 128]],
  ["fuchsia", [255, 0, 255]],
  ["green", [0, 128, 0]],
  ["lime", [0, 255, 0]],
  ["olive", [128, 128, 0]],
  ["yellow", [255, 255, 0]],
  ["navy", [0, 0, 128]],
  ["blue", [0, 0, 255]],
  ["teal", [0, 128, 128]],
  ["aqua", [0, 255, 255]],
  // CSS2
  ["orange", [255, 165, 0]],
  // CSS3
  ["aliceblue", [240, 248, 245]],
  ["antiquewhite", [250, 235, 215]],
  ["aquamarine", [127, 255, 212]],
  ["azure", [240, 255, 255]],
  ["beige", [245, 245, 220]],
  ["bisque", [255, 228, 196]],
  ["blanchedalmond", [255, 235, 205]],
  ["blueviolet", [138, 43, 226]],
  ["brown", [165, 42, 42]],
  ["burlywood", [222, 184, 35]],
  ["cadetblue", [95, 158, 160]],
  ["chartreuse", [127, 255, 0]],
  ["chocolate", [210, 105, 30]],
  ["coral", [255, 127, 80]],
  ["cornflowerblue", [100, 149, 237]],
  ["cornsilk", [255, 248, 220]],
  ["crimson", [220, 20, 60]],
  ["darkblue", [0, 0, 139]],
  ["darkcyan", [0, 139, 139]],
  ["darkgoldenrod", [184, 134, 11]],
  ["darkgray[*]", [169, 169, 169]],
  ["darkgreen", [0, 100, 0]],
  ["darkgrey[*]", [169, 169, 169]],
  ["darkkhaki", [189, 183, 107]],
  ["darkmagenta", [139, 0, 139]],
  ["darkolivegreen", [85, 107, 47]],
  ["darkorange", [255, 140, 0]],
  ["darkorchid", [153, 50, 204]],
  ["darkred", [139, 0, 0]],
  ["darksalmon", [233, 150, 122]],
  ["darkseagreen", [143, 188, 143]],
  ["darkslateblue", [72, 61, 139]],
  ["darkslategray", [47, 79, 79]],
  ["darkslategrey", [47, 79, 79]],
  ["darkturquoise", [0, 206, 209]],
  ["darkviolet", [148, 0, 211]],
  ["deeppink", [255, 20, 147]],
  ["deepskyblue", [0, 191, 255]],
  ["dimgray", [105, 105, 105]],
  ["dimgrey", [105, 105, 105]],
  ["dodgerblue", [30, 144, 255]],
  ["firebrick", [178, 34, 34]],
  ["floralwhite", [255, 250, 240]],
  ["forestgreen", [34, 139, 34]],
  ["gainsboro", [220, 220, 220]],
  ["ghostwhite", [248, 248, 255]],
  ["gold", [255, 215, 0]],
  ["goldenrod", [218, 165, 32]],
  ["greenyellow", [173, 255, 47]],
  ["grey", [128, 128, 128]],
  ["honeydew", [240, 255, 240]],
  ["hotpink", [255, 105, 180]],
  ["indianred", [205, 92, 92]],
  ["indigo", [75, 0, 130]],
  ["ivory", [255, 255, 240]],
  ["khaki", [240, 230, 140]],
  ["lavender", [230, 230, 250]],
  ["lavenderblush", [255, 240, 245]],
  ["lawngreen", [124, 252, 0]],
  ["lemonchiffon", [255, 250, 205]],
  ["lightblue", [173, 216, 230]],
  ["lightcoral", [240, 128, 128]],
  ["lightcyan", [224, 255, 255]],
  ["lightgoldenrodyellow", [250, 250, 210]],
  ["lightgray", [211, 211, 211]],
  ["lightgreen", [144, 238, 144]],
  ["lightgrey", [211, 211, 211]],
  ["lightpink", [255, 182, 193]],
  ["lightsalmon", [255, 160, 122]],
  ["lightseagreen", [32, 178, 170]],
  ["lightskyblue", [135, 206, 250]],
  ["lightslategray", [119, 136, 153]],
  ["lightslategrey", [119, 136, 153]],
  ["lightsteelblue", [176, 196, 222]],
  ["lightyellow", [255, 255, 224]],
  ["limegreen", [50, 205, 50]],
  ["linen", [250, 240, 230]],
  ["mediumaquamarine", [102, 205, 170]],
  ["mediumblue", [0, 0, 205]],
  ["mediumorchid", [186, 85, 211]],
  ["mediumpurple", [147, 112, 219]],
  ["mediumseagreen", [60, 179, 113]],
  ["mediumslateblue", [123, 104, 238]],
  ["mediumspringgreen", [0, 250, 154]],
  ["mediumturquoise", [72, 209, 204]],
  ["mediumvioletred", [199, 21, 133]],
  ["midnightblue", [25, 25, 112]],
  ["mintcream", [245, 255, 250]],
  ["mistyrose", [255, 228, 225]],
  ["moccasin", [255, 228, 181]],
  ["navajowhite", [255, 222, 173]],
  ["oldlace", [253, 245, 230]],
  ["olivedrab", [107, 142, 35]],
  ["orangered", [255, 69, 0]],
  ["orchid", [218, 112, 214]],
  ["palegoldenrod", [238, 232, 170]],
  ["palegreen", [152, 251, 152]],
  ["paleturquoise", [175, 238, 238]],
  ["palevioletred", [219, 112, 147]],
  ["papayawhip", [255, 239, 213]],
  ["peachpuff", [255, 218, 185]],
  ["peru", [205, 133, 63]],
  ["pink", [255, 192, 203]],
  ["plum", [221, 160, 221]],
  ["powderblue", [176, 224, 230]],
  ["rosybrown", [188, 143, 143]],
  ["royalblue", [65, 105, 225]],
  ["saddlebrown", [139, 69, 19]],
  ["salmon", [250, 128, 114]],
  ["sandybrown", [244, 164, 96]],
  ["seagreen", [46, 139, 87]],
  ["seashell", [255, 245, 238]],
  ["sienna", [160, 82, 45]],
  ["skyblue", [135, 206, 235]],
  ["slateblue", [106, 90, 205]],
  ["slategray", [112, 128, 144]],
  ["slategrey", [112, 128, 144]],
  ["snow", [255, 250, 250]],
  ["springgreen", [0, 255, 127]],
  ["steelblue", [70, 130, 180]],
  ["tan", [210, 180, 140]],
  ["thistle", [216, 191, 216]],
  ["tomato", [255, 99, 71]],
  ["turquoise", [64, 224, 208]],
  ["violet", [238, 130, 238]],
  ["wheat", [245, 222, 179]],
  ["whitesmoke", [245, 245, 245]],
  ["yellowgreen", [154, 205, 50]]
].forEach((value) => {
  cssToRGB.set(value[0], value[1]);
});
var Color = class {
  /**
   * @param {number} [r=0] - red component [0 .. 255]
   * @param {number} [g=0] - green component [0 .. 255]
   * @param {number} [b=0] - blue component [0 .. 255]
   * @param {number} [alpha=1.0] - alpha value [0.0 .. 1.0]
   */
  constructor(r = 0, g2 = 0, b = 0, alpha2 = 1) {
    this.onResetEvent(r, g2, b, alpha2);
  }
  /**
   * @ignore
   */
  onResetEvent(r = 0, g2 = 0, b = 0, alpha2 = 1) {
    if (typeof this.glArray === "undefined") {
      this.glArray = new Float32Array([0, 0, 0, 1]);
    }
    this.setColor(r, g2, b, alpha2);
  }
  /**
   * Color Red Component [0 .. 255]
   * @type {number}
   */
  get r() {
    return ~~(this.glArray[0] * 255);
  }
  set r(value) {
    this.glArray[0] = clamp(~~value || 0, 0, 255) / 255;
  }
  /**
   * Color Green Component [0 .. 255]
   * @type {number}
   */
  get g() {
    return ~~(this.glArray[1] * 255);
  }
  set g(value) {
    this.glArray[1] = clamp(~~value || 0, 0, 255) / 255;
  }
  /**
   * Color Blue Component [0 .. 255]
   * @type {number}
   */
  get b() {
    return ~~(this.glArray[2] * 255);
  }
  set b(value) {
    this.glArray[2] = clamp(~~value || 0, 0, 255) / 255;
  }
  /**
   * Color Alpha Component [0.0 .. 1.0]
   * @type {number}
   */
  get alpha() {
    return this.glArray[3];
  }
  set alpha(value = 1) {
    this.glArray[3] = clamp(+value, 0, 1);
  }
  /**
   * Set this color to the specified value.
   * @param {number} r - red component [0 .. 255]
   * @param {number} g - green component [0 .. 255]
   * @param {number} b - blue component [0 .. 255]
   * @param {number} [alpha=1.0] - alpha value [0.0 .. 1.0]
   * @returns {Color} Reference to this object for method chaining
   */
  setColor(r, g2, b, alpha2 = 1) {
    this.r = r;
    this.g = g2;
    this.b = b;
    this.alpha = alpha2;
    return this;
  }
  /**
   * set this color to the specified normalized float values
   * @param {number} r - red component [0.0 .. 1.0]
   * @param {number} g - green component [0.0 .. 1.0]
   * @param {number} b - blue component [0.0 .. 1.0]
   * @param {number} [alpha=1.0] - alpha value [0.0 .. 1.0]
   * @returns {Color} Reference to this object for method chaining
   */
  setFloat(r, g2, b, alpha2 = 1) {
    const a = this.glArray;
    a[0] = clamp(+r, 0, 1);
    a[1] = clamp(+g2, 0, 1);
    a[2] = clamp(+b, 0, 1);
    a[3] = clamp(+alpha2, 0, 1);
    return this;
  }
  /**
   * set this color to the specified HSV value
   * @param {number} h - hue (a value from 0 to 1)
   * @param {number} s - saturation (a value from 0 to 1)
   * @param {number} v - value (a value from 0 to 1)
   * @returns {Color} Reference to this object for method chaining
   */
  setHSV(h, s, v) {
    let r, g2, b;
    let i = Math.floor(h * 6);
    let f2 = h * 6 - i;
    let p = v * (1 - s);
    let q = v * (1 - f2 * s);
    let t2 = v * (1 - (1 - f2) * s);
    switch (i % 6) {
      case 0:
        r = v, g2 = t2, b = p;
        break;
      case 1:
        r = q, g2 = v, b = p;
        break;
      case 2:
        r = p, g2 = v, b = t2;
        break;
      case 3:
        r = p, g2 = q, b = v;
        break;
      case 4:
        r = t2, g2 = p, b = v;
        break;
      case 5:
        r = v, g2 = p, b = q;
        break;
    }
    return this.setColor(r * 255, g2 * 255, b * 255);
  }
  /**
   * set this color to the specified HSL value
   * @param {number} h - hue (a value from 0 to 1)
   * @param {number} s - saturation (a value from 0 to 1)
   * @param {number} l - lightness (a value from 0 to 1)
   * @returns {Color} Reference to this object for method chaining
   */
  setHSL(h, s, l) {
    let r, g2, b;
    if (s === 0) {
      r = g2 = b = l;
    } else {
      let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      let p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g2 = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return this.setColor(r * 255, g2 * 255, b * 255);
  }
  /**
   * Create a new copy of this color object.
   * @returns {Color} Reference to the newly cloned object
   */
  clone() {
    return pool.pull("Color").copy(this);
  }
  /**
   * Copy a color object or CSS color into this one.
   * @param {Color|string} color
   * @returns {Color} Reference to this object for method chaining
   */
  copy(color) {
    if (typeof color === "string") {
      return this.parseCSS(color);
    } else {
      this.glArray.set(color.glArray);
      return this;
    }
  }
  /**
   * Blend this color with the given one using addition.
   * @param {Color} color
   * @returns {Color} Reference to this object for method chaining
   */
  add(color) {
    this.glArray[0] = clamp(this.glArray[0] + color.glArray[0], 0, 1);
    this.glArray[1] = clamp(this.glArray[1] + color.glArray[1], 0, 1);
    this.glArray[2] = clamp(this.glArray[2] + color.glArray[2], 0, 1);
    this.glArray[3] = (this.glArray[3] + color.glArray[3]) / 2;
    return this;
  }
  /**
   * Darken this color value by 0..1
   * @param {number} scale
   * @returns {Color} Reference to this object for method chaining
   */
  darken(scale2) {
    scale2 = clamp(scale2, 0, 1);
    this.glArray[0] *= scale2;
    this.glArray[1] *= scale2;
    this.glArray[2] *= scale2;
    return this;
  }
  /**
   * Linearly interpolate between this color and the given one.
   * @param {Color} color
   * @param {number} alpha - with alpha = 0 being this color, and alpha = 1 being the given one.
   * @returns {Color} Reference to this object for method chaining
   */
  lerp(color, alpha2) {
    alpha2 = clamp(alpha2, 0, 1);
    this.glArray[0] += (color.glArray[0] - this.glArray[0]) * alpha2;
    this.glArray[1] += (color.glArray[1] - this.glArray[1]) * alpha2;
    this.glArray[2] += (color.glArray[2] - this.glArray[2]) * alpha2;
    return this;
  }
  /**
   * Lighten this color value by 0..1
   * @param {number} scale
   * @returns {Color} Reference to this object for method chaining
   */
  lighten(scale2) {
    scale2 = clamp(scale2, 0, 1);
    this.glArray[0] = clamp(this.glArray[0] + (1 - this.glArray[0]) * scale2, 0, 1);
    this.glArray[1] = clamp(this.glArray[1] + (1 - this.glArray[1]) * scale2, 0, 1);
    this.glArray[2] = clamp(this.glArray[2] + (1 - this.glArray[2]) * scale2, 0, 1);
    return this;
  }
  /**
   * Generate random r,g,b values for this color object
   * @param {number} [min=0] - minimum value for the random range
   * @param {number} [max=255] - maxmium value for the random range
   * @returns {Color} Reference to this object for method chaining
   */
  random(min2 = 0, max2 = 255) {
    if (min2 < 0) {
      min2 = 0;
    }
    if (max2 > 255) {
      max2 = 255;
    }
    return this.setColor(
      random$1(min2, max2),
      random$1(min2, max2),
      random$1(min2, max2),
      this.alpha
    );
  }
  /**
   * Return true if the r,g,b,a values of this color are equal with the
   * given one.
   * @param {Color} color
   * @returns {boolean}
   */
  equals(color) {
    return this.glArray[0] === color.glArray[0] && this.glArray[1] === color.glArray[1] && this.glArray[2] === color.glArray[2] && this.glArray[3] === color.glArray[3];
  }
  /**
   * Parse a CSS color string and set this color to the corresponding
   * r,g,b values
   * @param {string} cssColor
   * @returns {Color} Reference to this object for method chaining
   */
  parseCSS(cssColor) {
    if (cssToRGB.has(cssColor)) {
      return this.setColor.apply(this, cssToRGB.get(cssColor));
    }
    return this.parseRGB(cssColor);
  }
  /**
   * Parse an RGB or RGBA CSS color string
   * @param {string} rgbColor
   * @returns {Color} Reference to this object for method chaining
   */
  parseRGB(rgbColor) {
    let match2 = rgbaRx.exec(rgbColor);
    if (match2) {
      return this.setColor(+match2[1], +match2[2], +match2[3], +match2[5]);
    }
    return this.parseHex(rgbColor);
  }
  /**
   * Parse a Hex color ("#RGB", "#RGBA" or "#RRGGBB", "#RRGGBBAA" format) and set this color to
   * the corresponding r,g,b,a values
   * @param {string} hexColor
   * @param {boolean} [argb = false] - true if format is #ARGB, or #AARRGGBB (as opposed to #RGBA or #RGGBBAA)
   * @returns {Color} Reference to this object for method chaining
   */
  parseHex(hexColor, argb = false) {
    let match2;
    if (match2 = hex8Rx.exec(hexColor)) {
      return this.setColor(
        parseInt(match2[argb === false ? 1 : 2], 16),
        // r
        parseInt(match2[argb === false ? 2 : 3], 16),
        // g
        parseInt(match2[argb === false ? 3 : 4], 16),
        // b
        (clamp(parseInt(match2[argb === false ? 4 : 1], 16), 0, 255) / 255).toFixed(1)
        // a
      );
    }
    if (match2 = hex6Rx.exec(hexColor)) {
      return this.setColor(
        parseInt(match2[1], 16),
        parseInt(match2[2], 16),
        parseInt(match2[3], 16)
      );
    }
    if (match2 = hex4Rx.exec(hexColor)) {
      let r = match2[argb === false ? 1 : 2];
      let g2 = match2[argb === false ? 2 : 3];
      let b = match2[argb === false ? 3 : 4];
      let a = match2[argb === false ? 4 : 1];
      return this.setColor(
        parseInt(r + r, 16),
        // r
        parseInt(g2 + g2, 16),
        // g
        parseInt(b + b, 16),
        // b
        (clamp(parseInt(a + a, 16), 0, 255) / 255).toFixed(1)
        // a
      );
    }
    if (match2 = hex3Rx.exec(hexColor)) {
      return this.setColor(
        parseInt(match2[1] + match2[1], 16),
        parseInt(match2[2] + match2[2], 16),
        parseInt(match2[3] + match2[3], 16)
      );
    }
    throw new Error(
      "invalid parameter: " + hexColor
    );
  }
  /**
   * Pack this color RGB components into a Uint32 ARGB representation
   * @param {number} [alpha=1.0] - alpha value [0.0 .. 1.0]
   * @returns {number}
   */
  toUint32(alpha2 = 1) {
    const a = this.glArray;
    const ur = a[0] * 255 >> 0;
    const ug = a[1] * 255 >> 0;
    const ub = a[2] * 255 >> 0;
    return alpha2 * 255 >> 0 << 24 | ur << 16 | ug << 8 | ub;
  }
  /**
   * return an Float Array representation of this object
   * @returns {Float32Array}
   */
  toArray() {
    return this.glArray;
  }
  /**
   * return the color in "#RRGGBB" format
   * @returns {string}
   */
  toHex() {
    return "#" + toHex$1(this.r) + toHex$1(this.g) + toHex$1(this.b);
  }
  /**
   * Get the color in "#RRGGBBAA" format
   * @returns {string}
   */
  toHex8(alpha2 = this.alpha) {
    return "#" + toHex$1(this.r) + toHex$1(this.g) + toHex$1(this.b) + toHex$1(alpha2 * 255);
  }
  /**
   * Get the color in "rgb(R,G,B)" format
   * @returns {string}
   */
  toRGB() {
    return "rgb(" + this.r + "," + this.g + "," + this.b + ")";
  }
  /**
   * Get the color in "rgba(R,G,B,A)" format
   * @param {number} [alpha=1.0] - alpha value [0.0 .. 1.0]
   * @returns {string}
   */
  toRGBA(alpha2 = this.alpha) {
    return "rgba(" + this.r + "," + this.g + "," + this.b + "," + alpha2 + ")";
  }
};
var Vector2d = class _Vector2d {
  /**
   * @param {number} [x=0] - x value of the vector
   * @param {number} [y=0] - y value of the vector
   */
  constructor(x = 0, y = 0) {
    this.onResetEvent(x, y);
  }
  /**
   * @param {number} [x=0] - x value of the vector
   * @param {number} [y=0] - y value of the vector
   * @ignore
   */
  onResetEvent(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  /**
   * @param {number} [x=0] - x value of the vector
   * @param {number} [y=0] - y value of the vector
   * @ignore
   */
  _set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  /**
   * set the Vector x and y properties to the given values
   * @param {number} x
   * @param {number} y
   * @returns {Vector2d} Reference to this object for method chaining
   */
  set(x, y) {
    if (x !== +x || y !== +y) {
      throw new Error(
        "invalid x,y parameters (not a number)"
      );
    }
    return this._set(x, y);
  }
  /**
   * set the Vector x and y properties to 0
   * @returns {Vector2d} Reference to this object for method chaining
   */
  setZero() {
    return this.set(0, 0);
  }
  /**
   * set the Vector x and y properties using the passed vector
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  setV(v) {
    return this._set(v.x, v.y);
  }
  /**
   * Add the passed vector to this vector
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  add(v) {
    return this._set(this.x + v.x, this.y + v.y);
  }
  /**
   * Substract the passed vector to this vector
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  sub(v) {
    return this._set(this.x - v.x, this.y - v.y);
  }
  /**
   * Multiply this vector values by the given scalar
   * @param {number} x
   * @param {number} [y=x]
   * @returns {Vector2d} Reference to this object for method chaining
   */
  scale(x, y = x) {
    return this._set(this.x * x, this.y * y);
  }
  /**
   * Convert this vector into isometric coordinate space
   * @returns {Vector2d} Reference to this object for method chaining
   */
  toIso() {
    return this._set(this.x - this.y, (this.x + this.y) * 0.5);
  }
  /**
   * Convert this vector into 2d coordinate space
   * @returns {Vector2d} Reference to this object for method chaining
   */
  to2d() {
    return this._set(this.y + this.x / 2, this.y - this.x / 2);
  }
  /**
   * Multiply this vector values by the passed vector
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  scaleV(v) {
    return this._set(this.x * v.x, this.y * v.y);
  }
  /**
   * Divide this vector values by the passed value
   * @param {number} n - the value to divide the vector by
   * @returns {Vector2d} Reference to this object for method chaining
   */
  div(n) {
    return this._set(this.x / n, this.y / n);
  }
  /**
   * Update this vector values to absolute values
   * @returns {Vector2d} Reference to this object for method chaining
   */
  abs() {
    return this._set(this.x < 0 ? -this.x : this.x, this.y < 0 ? -this.y : this.y);
  }
  /**
   * Clamp the vector value within the specified value range
   * @param {number} low
   * @param {number} high
   * @returns {Vector2d} new me.Vector2d
   */
  clamp(low, high) {
    return new _Vector2d(clamp(this.x, low, high), clamp(this.y, low, high));
  }
  /**
   * Clamp this vector value within the specified value range
   * @param {number} low
   * @param {number} high
   * @returns {Vector2d} Reference to this object for method chaining
   */
  clampSelf(low, high) {
    return this._set(clamp(this.x, low, high), clamp(this.y, low, high));
  }
  /**
   * Update this vector with the minimum value between this and the passed vector
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  minV(v) {
    return this._set(this.x < v.x ? this.x : v.x, this.y < v.y ? this.y : v.y);
  }
  /**
   * Update this vector with the maximum value between this and the passed vector
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  maxV(v) {
    return this._set(this.x > v.x ? this.x : v.x, this.y > v.y ? this.y : v.y);
  }
  /**
   * Floor the vector values
   * @returns {Vector2d} new me.Vector2d
   */
  floor() {
    return new _Vector2d(Math.floor(this.x), Math.floor(this.y));
  }
  /**
   * Floor this vector values
   * @returns {Vector2d} Reference to this object for method chaining
   */
  floorSelf() {
    return this._set(Math.floor(this.x), Math.floor(this.y));
  }
  /**
   * Ceil the vector values
   * @returns {Vector2d} new me.Vector2d
   */
  ceil() {
    return new _Vector2d(Math.ceil(this.x), Math.ceil(this.y));
  }
  /**
   * Ceil this vector values
   * @returns {Vector2d} Reference to this object for method chaining
   */
  ceilSelf() {
    return this._set(Math.ceil(this.x), Math.ceil(this.y));
  }
  /**
   * Negate the vector values
   * @returns {Vector2d} new me.Vector2d
   */
  negate() {
    return new _Vector2d(-this.x, -this.y);
  }
  /**
   * Negate this vector values
   * @returns {Vector2d} Reference to this object for method chaining
   */
  negateSelf() {
    return this._set(-this.x, -this.y);
  }
  /**
   * Copy the x,y values of the passed vector to this one
   * @param {Vector2d} v
   * @returns {Vector2d} Reference to this object for method chaining
   */
  copy(v) {
    return this._set(v.x, v.y);
  }
  /**
   * return true if this vector is equal to the given values or vector
   * @param {number|Vector2d} x
   * @param {number} [y]
   * @returns {boolean}
   */
  equals(...args) {
    let _x, _y;
    if (args.length === 2) {
      [_x, _y] = args;
    } else {
      [_x, _y] = [args[0].x, args[0].y];
    }
    return this.x === _x && this.y === _y;
  }
  /**
   * normalize this vector (scale the vector so that its magnitude is 1)
   * @returns {Vector2d} Reference to this object for method chaining
   */
  normalize() {
    return this.div(this.length() || 1);
  }
  /**
   * change this vector to be perpendicular to what it was before.<br>
   * (Effectively rotates it 90 degrees in a clockwise direction)
   * @returns {Vector2d} Reference to this object for method chaining
   */
  perp() {
    return this._set(this.y, -this.x);
  }
  /**
   * Rotate this vector (counter-clockwise) by the specified angle (in radians).
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d} [v] - an optional point to rotate around
   * @returns {Vector2d} Reference to this object for method chaining
   */
  rotate(angle, v) {
    let cx = 0;
    let cy = 0;
    if (typeof v === "object") {
      cx = v.x;
      cy = v.y;
    }
    let x = this.x - cx;
    let y = this.y - cy;
    let c = Math.cos(angle);
    let s = Math.sin(angle);
    return this._set(x * c - y * s + cx, x * s + y * c + cy);
  }
  /**
   * return the dot product of this vector and the passed one
   * @param {Vector2d} v
   * @returns {number} The dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  /**
   * return the cross product of this vector and the passed one
   * @param {Vector2d} v
   * @returns {number} The cross product.
   */
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  /**
  * return the square length of this vector
  * @returns {number} The length^2 of this vector.
  */
  length2() {
    return this.dot(this);
  }
  /**
   * return the length (magnitude) of this vector
   * @returns {number} the length of this vector
   */
  length() {
    return Math.sqrt(this.length2());
  }
  /**
   * Linearly interpolate between this vector and the given one.
   * @param {Vector2d} v
   * @param {number} alpha - distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
   * @returns {Vector2d} Reference to this object for method chaining
   */
  lerp(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    return this;
  }
  /**
   * interpolate the position of this vector towards the given one by the given maximum step.
   * @param {Vector2d} target
   * @param {number} step - the maximum step per iteration (Negative values will push the vector away from the target)
   * @returns {Vector2d} Reference to this object for method chaining
   */
  moveTowards(target, step) {
    let angle = Math.atan2(target.y - this.y, target.x - this.x);
    let distance = this.distance(target);
    if (distance === 0 || step >= 0 && distance <= step * step) {
      return target;
    }
    this.x += Math.cos(angle) * step;
    this.y += Math.sin(angle) * step;
    return this;
  }
  /**
   * return the distance between this vector and the passed one
   * @param {Vector2d} v
   * @returns {number}
   */
  distance(v) {
    let dx = this.x - v.x, dy = this.y - v.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * return the angle between this vector and the passed one
   * @param {Vector2d} v
   * @returns {number} angle in radians
   */
  angle(v) {
    return Math.acos(clamp(this.dot(v) / (this.length() * v.length()), -1, 1));
  }
  /**
   * project this vector on to another vector.
   * @param {Vector2d} v - The vector to project onto.
   * @returns {Vector2d} Reference to this object for method chaining
   */
  project(v) {
    return this.scale(this.dot(v) / v.length2());
  }
  /**
   * Project this vector onto a vector of unit length.<br>
   * This is slightly more efficient than `project` when dealing with unit vectors.
   * @param {Vector2d} v - The unit vector to project onto.
   * @returns {Vector2d} Reference to this object for method chaining
   */
  projectN(v) {
    return this.scale(this.dot(v));
  }
  /**
   * return a clone copy of this vector
   * @returns {Vector2d} new me.Vector2d
   */
  clone() {
    return pool.pull("Vector2d", this.x, this.y);
  }
  /**
   * convert the object to a string representation
   * @returns {string}
   */
  toString() {
    return "x:" + this.x + ",y:" + this.y;
  }
};
var Vector3d = class _Vector3d {
  /**
   * @param {number} [x=0] - x value of the vector
   * @param {number} [y=0] - y value of the vector
   * @param {number} [z=0] - z value of the vector
   */
  constructor(x = 0, y = 0, z = 0) {
    this.onResetEvent(x, y, z);
  }
  /**
   * @param {number} [x=0]
   * @param {number} [y=0]
   * @param {number} [z=0]
   * @ignore
   */
  onResetEvent(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} [z=0]
   * @ignore
   */
  _set(x, y, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * set the Vector x and y properties to the given values
   * @param {number} x
   * @param {number} y
   * @param {number} [z=0]
   * @returns {Vector3d} Reference to this object for method chaining
   */
  set(x, y, z) {
    if (x !== +x || y !== +y || typeof z !== "undefined" && z !== +z) {
      throw new Error(
        "invalid x, y, z parameters (not a number)"
      );
    }
    return this._set(x, y, z);
  }
  /**
   * set the Vector x and y properties to 0
   * @returns {Vector3d} Reference to this object for method chaining
   */
  setZero() {
    return this.set(0, 0, 0);
  }
  /**
   * set the Vector x and y properties using the passed vector
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  setV(v) {
    return this._set(v.x, v.y, v.z);
  }
  /**
   * Add the passed vector to this vector
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  add(v) {
    return this._set(this.x + v.x, this.y + v.y, this.z + (v.z || 0));
  }
  /**
   * Substract the passed vector to this vector
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  sub(v) {
    return this._set(this.x - v.x, this.y - v.y, this.z - (v.z || 0));
  }
  /**
   * Multiply this vector values by the given scalar
   * @param {number} x
   * @param {number} [y=x]
   * @param {number} [z=1]
   * @returns {Vector3d} Reference to this object for method chaining
   */
  scale(x, y = x, z = 1) {
    return this._set(this.x * x, this.y * y, this.z * z);
  }
  /**
   * Multiply this vector values by the passed vector
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  scaleV(v) {
    return this.scale(v.x, v.y, v.z);
  }
  /**
   * Convert this vector into isometric coordinate space
   * @returns {Vector3d} Reference to this object for method chaining
   */
  toIso() {
    return this._set(this.x - this.y, (this.x + this.y) * 0.5, this.z);
  }
  /**
   * Convert this vector into 2d coordinate space
   * @returns {Vector3d} Reference to this object for method chaining
   */
  to2d() {
    return this._set(this.y + this.x / 2, this.y - this.x / 2, this.z);
  }
  /**
   * Divide this vector values by the passed value
   * @param {number} n - the value to divide the vector by
   * @returns {Vector3d} Reference to this object for method chaining
   */
  div(n) {
    return this._set(this.x / n, this.y / n, this.z / n);
  }
  /**
   * Update this vector values to absolute values
   * @returns {Vector3d} Reference to this object for method chaining
   */
  abs() {
    return this._set(this.x < 0 ? -this.x : this.x, this.y < 0 ? -this.y : this.y, this.z < 0 ? -this.z : this.z);
  }
  /**
   * Clamp the vector value within the specified value range
   * @param {number} low
   * @param {number} high
   * @returns {Vector3d} new me.Vector3d
   */
  clamp(low, high) {
    return new _Vector3d(clamp(this.x, low, high), clamp(this.y, low, high), clamp(this.z, low, high));
  }
  /**
   * Clamp this vector value within the specified value range
   * @param {number} low
   * @param {number} high
   * @returns {Vector3d} Reference to this object for method chaining
   */
  clampSelf(low, high) {
    return this._set(clamp(this.x, low, high), clamp(this.y, low, high), clamp(this.z, low, high));
  }
  /**
   * Update this vector with the minimum value between this and the passed vector
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  minV(v) {
    let _vz = v.z || 0;
    return this._set(this.x < v.x ? this.x : v.x, this.y < v.y ? this.y : v.y, this.z < _vz ? this.z : _vz);
  }
  /**
   * Update this vector with the maximum value between this and the passed vector
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  maxV(v) {
    let _vz = v.z || 0;
    return this._set(this.x > v.x ? this.x : v.x, this.y > v.y ? this.y : v.y, this.z > _vz ? this.z : _vz);
  }
  /**
   * Floor the vector values
   * @returns {Vector3d} new me.Vector3d
   */
  floor() {
    return new _Vector3d(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
  }
  /**
   * Floor this vector values
   * @returns {Vector3d} Reference to this object for method chaining
   */
  floorSelf() {
    return this._set(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
  }
  /**
   * Ceil the vector values
   * @returns {Vector3d} new me.Vector3d
   */
  ceil() {
    return new _Vector3d(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
  }
  /**
   * Ceil this vector values
   * @returns {Vector3d} Reference to this object for method chaining
   */
  ceilSelf() {
    return this._set(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
  }
  /**
   * Negate the vector values
   * @returns {Vector3d} new me.Vector3d
   */
  negate() {
    return new _Vector3d(-this.x, -this.y, -this.z);
  }
  /**
   * Negate this vector values
   * @returns {Vector3d} Reference to this object for method chaining
   */
  negateSelf() {
    return this._set(-this.x, -this.y, -this.z);
  }
  /**
   * Copy the components of the given vector into this one
   * @param {Vector2d|Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  copy(v) {
    return this._set(v.x, v.y, v.z || 0);
  }
  /**
   * return true if this vector is equal to the given values or vector
   * @param {number|Vector2d|Vector3d} x
   * @param {number} [y]
   * @param {number} [z]
   * @returns {boolean} true if both vectros are equals
   */
  equals(...args) {
    let _x, _y, _z;
    if (args.length >= 2) {
      [_x, _y, _z] = args;
    } else {
      [_x, _y, _z] = [args[0].x, args[0].y, args[0].z];
    }
    if (typeof _z === "undefined") {
      _z = this.z;
    }
    return this.x === _x && this.y === _y && this.z === _z;
  }
  /**
   * normalize this vector (scale the vector so that its magnitude is 1)
   * @returns {Vector3d} Reference to this object for method chaining
   */
  normalize() {
    return this.div(this.length() || 1);
  }
  /**
   * change this vector to be perpendicular to what it was before.<br>
   * (Effectively rotates it 90 degrees in a clockwise direction around the z axis)
   * @returns {Vector3d} Reference to this object for method chaining
   */
  perp() {
    return this._set(this.y, -this.x, this.z);
  }
  /**
   * Rotate this vector (counter-clockwise) by the specified angle (in radians) around the z axis
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d} [v] - an optional point to rotate around (on the same z axis)
   * @returns {Vector3d} Reference to this object for method chaining
   */
  rotate(angle, v) {
    let cx = 0;
    let cy = 0;
    if (typeof v === "object") {
      cx = v.x;
      cy = v.y;
    }
    let x = this.x - cx;
    let y = this.y - cy;
    let c = Math.cos(angle);
    let s = Math.sin(angle);
    return this._set(x * c - y * s + cx, x * s + y * c + cy, this.z);
  }
  /**
   * return the dot product of this vector and the passed one
   * @param {Vector2d|Vector3d} v
   * @returns {number} The dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * (typeof v.z !== "undefined" ? v.z : this.z);
  }
  /**
   * calculate the cross product of this vector and the passed one
   * @param {Vector3d} v
   * @returns {Vector3d} Reference to this object for method chaining
   */
  cross(v) {
    let ax = this.x, ay = this.y, az = this.z;
    let bx = v.x, by = v.y, bz = v.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  /**
  * return the square length of this vector
  * @returns {number} The length^2 of this vector.
  */
  length2() {
    return this.dot(this);
  }
  /**
   * return the length (magnitude) of this vector
   * @returns {number} the length of this vector
   */
  length() {
    return Math.sqrt(this.length2());
  }
  /**
   * Linearly interpolate between this vector and the given one.
   * @param {Vector3d} v
   * @param {number} alpha - distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
   * @returns {Vector3d} Reference to this object for method chaining
   */
  lerp(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    this.z += (v.z - this.z) * alpha2;
    return this;
  }
  /**
   * interpolate the position of this vector on the x and y axis towards the given one by the given maximum step.
   * @param {Vector2d|Vector3d} target
   * @param {number} step - the maximum step per iteration (Negative values will push the vector away from the target)
   * @returns {Vector3d} Reference to this object for method chaining
   */
  moveTowards(target, step) {
    let angle = Math.atan2(target.y - this.y, target.x - this.x);
    let dx = this.x - target.x;
    let dy = this.y - target.y;
    let distance = Math.sqrt(dx * dx + dy * dy);
    if (distance === 0 || step >= 0 && distance <= step * step) {
      return target;
    }
    this.x += Math.cos(angle) * step;
    this.y += Math.sin(angle) * step;
    return this;
  }
  /**
   * return the distance between this vector and the passed one
   * @param {Vector2d|Vector3d} v
   * @returns {number}
   */
  distance(v) {
    let dx = this.x - v.x;
    let dy = this.y - v.y;
    let dz = this.z - (v.z || 0);
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  /**
   * return the angle between this vector and the passed one
   * @param {Vector2d|Vector3d} v
   * @returns {number} angle in radians
   */
  angle(v) {
    return Math.acos(clamp(this.dot(v) / (this.length() * v.length()), -1, 1));
  }
  /**
   * project this vector on to another vector.
   * @param {Vector2d|Vector3d} v - The vector to project onto.
   * @returns {Vector3d} Reference to this object for method chaining
   */
  project(v) {
    let ratio = this.dot(v) / v.length2();
    return this.scale(ratio, ratio, ratio);
  }
  /**
   * Project this vector onto a vector of unit length.<br>
   * This is slightly more efficient than `project` when dealing with unit vectors.
   * @param {Vector2d|Vector3d} v - The unit vector to project onto.
   * @returns {Vector3d} Reference to this object for method chaining
   */
  projectN(v) {
    let ratio = this.dot(v) / v.length2();
    return this.scale(ratio, ratio, ratio);
  }
  /**
   * return a clone copy of this vector
   * @returns {Vector3d} new me.Vector3d
   */
  clone() {
    return pool.pull("Vector3d", this.x, this.y, this.z);
  }
  /**
   * convert the object to a string representation
   * @returns {string}
   */
  toString() {
    return "x:" + this.x + ",y:" + this.y + ",z:" + this.z;
  }
};
var ObservableVector2d = class _ObservableVector2d extends Vector2d {
  /**
   * @param {number} x - x value of the vector
   * @param {number} y - y value of the vector
   * @param {object} settings - additional required parameters
   * @param {Function} settings.onUpdate - the callback to be executed when the vector is changed
   * @param {Function} [settings.scope] - the value to use as this when calling onUpdate
   */
  constructor(x = 0, y = 0, settings) {
    super(x, y);
    if (typeof settings === "undefined") {
      throw new Error(
        "undefined `onUpdate` callback"
      );
    }
    this.setCallback(settings.onUpdate, settings.scope);
  }
  /**
   * @ignore
   */
  onResetEvent(x = 0, y = 0, settings) {
    this.setMuted(x, y);
    if (typeof settings !== "undefined") {
      this.setCallback(settings.onUpdate, settings.scope);
    }
  }
  /**
   * x value of the vector
   * @public
   * @type {number}
   * @name x
   * @memberof ObservableVector2d
   */
  get x() {
    return this._x;
  }
  set x(value) {
    let ret = this.onUpdate.call(this.scope, value, this._y, this._x, this._y);
    if (ret && "x" in ret) {
      this._x = ret.x;
    } else {
      this._x = value;
    }
  }
  /**
   * y value of the vector
   * @public
   * @type {number}
   * @name y
   * @memberof ObservableVector2d
   */
  get y() {
    return this._y;
  }
  set y(value) {
    let ret = this.onUpdate.call(this.scope, this._x, value, this._x, this._y);
    if (ret && "y" in ret) {
      this._y = ret.y;
    } else {
      this._y = value;
    }
  }
  /** @ignore */
  _set(x, y) {
    let ret = this.onUpdate.call(this.scope, x, y, this._x, this._y);
    if (ret && "x" in ret && "y" in ret) {
      this._x = ret.x;
      this._y = ret.y;
    } else {
      this._x = x;
      this._y = y;
    }
    return this;
  }
  /**
   * set the vector value without triggering the callback
   * @name setMuted
   * @memberof ObservableVector2d
   * @param {number} x - x value of the vector
   * @param {number} y - y value of the vector
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  setMuted(x, y) {
    this._x = x;
    this._y = y;
    return this;
  }
  /**
   * set the callback to be executed when the vector is changed
   * @name setCallback
   * @memberof ObservableVector2d
   * @param {Function} fn - callback
   * @param {Function} [scope=null] - scope
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  setCallback(fn, scope = null) {
    if (typeof fn !== "function") {
      throw new Error(
        "invalid `onUpdate` callback"
      );
    }
    this.onUpdate = fn;
    this.scope = scope;
    return this;
  }
  /**
   * Add the passed vector to this vector
   * @name add
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  add(v) {
    return this._set(this._x + v.x, this._y + v.y);
  }
  /**
   * Substract the passed vector to this vector
   * @name sub
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  sub(v) {
    return this._set(this._x - v.x, this._y - v.y);
  }
  /**
   * Multiply this vector values by the given scalar
   * @name scale
   * @memberof ObservableVector2d
   * @param {number} x
   * @param {number} [y=x]
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  scale(x, y = x) {
    return this._set(this._x * x, this._y * y);
  }
  /**
   * Multiply this vector values by the passed vector
   * @name scaleV
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  scaleV(v) {
    return this._set(this._x * v.x, this._y * v.y);
  }
  /**
   * Divide this vector values by the passed value
   * @name div
   * @memberof ObservableVector2d
   * @param {number} n - the value to divide the vector by
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  div(n) {
    return this._set(this._x / n, this._y / n);
  }
  /**
   * Update this vector values to absolute values
   * @name abs
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  abs() {
    return this._set(this._x < 0 ? -this._x : this._x, this._y < 0 ? -this._y : this._y);
  }
  /**
   * Clamp the vector value within the specified value range
   * @name clamp
   * @memberof ObservableVector2d
   * @param {number} low
   * @param {number} high
   * @returns {ObservableVector2d} new me.ObservableVector2d
   */
  clamp(low, high) {
    return new _ObservableVector2d(clamp(this.x, low, high), clamp(this.y, low, high), { onUpdate: this.onUpdate, scope: this.scope });
  }
  /**
   * Clamp this vector value within the specified value range
   * @name clampSelf
   * @memberof ObservableVector2d
   * @param {number} low
   * @param {number} high
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  clampSelf(low, high) {
    return this._set(clamp(this._x, low, high), clamp(this._y, low, high));
  }
  /**
   * Update this vector with the minimum value between this and the passed vector
   * @name minV
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  minV(v) {
    return this._set(this._x < v.x ? this._x : v.x, this._y < v.y ? this._y : v.y);
  }
  /**
   * Update this vector with the maximum value between this and the passed vector
   * @name maxV
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  maxV(v) {
    return this._set(this._x > v.x ? this._x : v.x, this._y > v.y ? this._y : v.y);
  }
  /**
   * Floor the vector values
   * @name floor
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} new me.ObservableVector2d
   */
  floor() {
    return new _ObservableVector2d(Math.floor(this._x), Math.floor(this._y), { onUpdate: this.onUpdate, scope: this.scope });
  }
  /**
   * Floor this vector values
   * @name floorSelf
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  floorSelf() {
    return this._set(Math.floor(this._x), Math.floor(this._y));
  }
  /**
   * Ceil the vector values
   * @name ceil
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} new me.ObservableVector2d
   */
  ceil() {
    return new _ObservableVector2d(Math.ceil(this._x), Math.ceil(this._y), { onUpdate: this.onUpdate, scope: this.scope });
  }
  /**
   * Ceil this vector values
   * @name ceilSelf
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  ceilSelf() {
    return this._set(Math.ceil(this._x), Math.ceil(this._y));
  }
  /**
   * Negate the vector values
   * @name negate
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} new me.ObservableVector2d
   */
  negate() {
    return new _ObservableVector2d(-this._x, -this._y, { onUpdate: this.onUpdate, scope: this.scope });
  }
  /**
   * Negate this vector values
   * @name negateSelf
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  negateSelf() {
    return this._set(-this._x, -this._y);
  }
  /**
   * Copy the x,y values of the passed vector to this one
   * @name copy
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  copy(v) {
    return this._set(v.x, v.y);
  }
  /**
   * return true if the two vectors are the same
   * @name equals
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {boolean}
   */
  equals(v) {
    return this._x === v.x && this._y === v.y;
  }
  /**
   * change this vector to be perpendicular to what it was before.<br>
   * (Effectively rotates it 90 degrees in a clockwise direction)
   * @name perp
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  perp() {
    return this._set(this._y, -this._x);
  }
  /**
   * Rotate this vector (counter-clockwise) by the specified angle (in radians).
   * @name rotate
   * @memberof ObservableVector2d
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d|ObservableVector2d} [v] - an optional point to rotate around
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  rotate(angle, v) {
    let cx = 0;
    let cy = 0;
    if (typeof v === "object") {
      cx = v.x;
      cy = v.y;
    }
    let x = this._x - cx;
    let y = this._y - cy;
    let c = Math.cos(angle);
    let s = Math.sin(angle);
    return this._set(x * c - y * s + cx, x * s + y * c + cy);
  }
  /**
   * return the dot product of this vector and the passed one
   * @name dot
   * @memberof ObservableVector2d
   * @param {Vector2d|ObservableVector2d} v
   * @returns {number} The dot product.
   */
  dot(v) {
    return this._x * v.x + this._y * v.y;
  }
  /**
   * return the cross product of this vector and the passed one
   * @name cross
   * @memberof ObservableVector2d
   * @param {Vector2d|ObservableVector2d} v
   * @returns {number} The cross product.
   */
  cross(v) {
    return this._x * v.y - this._y * v.x;
  }
  /**
   * Linearly interpolate between this vector and the given one.
   * @name lerp
   * @memberof ObservableVector2d
   * @param {Vector2d|ObservableVector2d} v
   * @param {number} alpha - distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  lerp(v, alpha2) {
    return this._set(
      this._x + (v.x - this._x) * alpha2,
      this._y + (v.y - this._y) * alpha2
    );
  }
  /**
   * interpolate the position of this vector towards the given one while nsure that the distance never exceeds the given step.
   * @name moveTowards
   * @memberof ObservableVector2d
   * @param {Vector2d|ObservableVector2d} target
   * @param {number} step - the maximum step per iteration (Negative values will push the vector away from the target)
   * @returns {ObservableVector2d} Reference to this object for method chaining
   */
  moveTowards(target, step) {
    let angle = Math.atan2(target.y - this._y, target.x - this._x);
    let distance = this.distance(target);
    if (distance === 0 || step >= 0 && distance <= step * step) {
      return target;
    }
    this._x += Math.cos(angle) * step;
    this._y += Math.sin(angle) * step;
    return this;
  }
  /**
   * return the distance between this vector and the passed one
   * @name distance
   * @memberof ObservableVector2d
   * @param {ObservableVector2d} v
   * @returns {number}
   */
  distance(v) {
    return Math.sqrt((this._x - v.x) * (this._x - v.x) + (this._y - v.y) * (this._y - v.y));
  }
  /**
   * return a clone copy of this vector
   * @name clone
   * @memberof ObservableVector2d
   * @returns {ObservableVector2d} new me.ObservableVector2d
   */
  clone() {
    return pool.pull("ObservableVector2d", this._x, this._y, { onUpdate: this.onUpdate, scope: this.scope });
  }
  /**
   * return a `me.Vector2d` copy of this `me.ObservableVector2d` object
   * @name toVector2d
   * @memberof ObservableVector2d
   * @returns {Vector2d} new me.Vector2d
   */
  toVector2d() {
    return pool.pull("Vector2d", this._x, this._y);
  }
  /**
   * convert the object to a string representation
   * @name toString
   * @memberof ObservableVector2d
   * @returns {string}
   */
  toString() {
    return "x:" + this._x + ",y:" + this._y;
  }
};
var ObservableVector3d = class _ObservableVector3d extends Vector3d {
  /**
   * @param {number} x - x value of the vector
   * @param {number} y - y value of the vector
   * @param {number} z - z value of the vector
   * @param {object} settings - additional required parameters
   * @param {Function} settings.onUpdate - the callback to be executed when the vector is changed
   * @param {object} [settings.scope] - the value to use as this when calling onUpdate
   */
  constructor(x = 0, y = 0, z = 0, settings) {
    super(x, y, z);
    if (typeof settings === "undefined") {
      throw new Error(
        "undefined `onUpdate` callback"
      );
    }
    this.setCallback(settings.onUpdate, settings.scope);
  }
  /**
   * @ignore
   */
  onResetEvent(x = 0, y = 0, z = 0, settings) {
    this.setMuted(x, y, z);
    if (typeof settings !== "undefined") {
      this.setCallback(settings.onUpdate, settings.scope);
    }
    return this;
  }
  /**
   * x value of the vector
   * @public
   * @type {number}
   * @name x
   * @memberof ObservableVector3d
   */
  get x() {
    return this._x;
  }
  set x(value) {
    let ret = this.onUpdate.call(this.scope, value, this._y, this._z, this._x, this._y, this._z);
    if (ret && "x" in ret) {
      this._x = ret.x;
    } else {
      this._x = value;
    }
  }
  /**
   * y value of the vector
   * @public
   * @type {number}
   * @name y
   * @memberof ObservableVector3d
   */
  get y() {
    return this._y;
  }
  set y(value) {
    let ret = this.onUpdate.call(this.scope, this._x, value, this._z, this._x, this._y, this._z);
    if (ret && "y" in ret) {
      this._y = ret.y;
    } else {
      this._y = value;
    }
  }
  /**
   * z value of the vector
   * @public
   * @type {number}
   * @name z
   * @memberof ObservableVector3d
   */
  get z() {
    return this._z;
  }
  set z(value) {
    let ret = this.onUpdate.call(this.scope, this._x, this._y, value, this._x, this._y, this._z);
    if (ret && "z" in ret) {
      this._z = ret.z;
    } else {
      this._z = value;
    }
  }
  /**
   * @ignore
   */
  _set(x, y, z) {
    let ret = this.onUpdate.call(this.scope, x, y, z, this._x, this._y, this._z);
    if (ret && "x" in ret && "y" in ret && "z" in ret) {
      this._x = ret.x;
      this._y = ret.y;
      this._z = ret.z;
    } else {
      this._x = x;
      this._y = y;
      this._z = z || 0;
    }
    return this;
  }
  /**
   * set the vector value without triggering the callback
   * @name setMuted
   * @memberof ObservableVector3d
   * @param {number} x - x value of the vector
   * @param {number} y - y value of the vector
   * @param {number} [z=0] - z value of the vector
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  setMuted(x, y, z) {
    this._x = x;
    this._y = y;
    this._z = z || 0;
    return this;
  }
  /**
   * set the callback to be executed when the vector is changed
   * @name setCallback
   * @memberof ObservableVector3d
   * @param {Function} fn - callback
   * @param {Function} [scope=null] - scope
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  setCallback(fn, scope = null) {
    if (typeof fn !== "function") {
      throw new Error(
        "invalid `onUpdate` callback"
      );
    }
    this.onUpdate = fn;
    this.scope = scope;
    return this;
  }
  /**
   * Add the passed vector to this vector
   * @name add
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  add(v) {
    return this._set(this._x + v.x, this._y + v.y, this._z + (v.z || 0));
  }
  /**
   * Substract the passed vector to this vector
   * @name sub
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  sub(v) {
    return this._set(this._x - v.x, this._y - v.y, this._z - (v.z || 0));
  }
  /**
   * Multiply this vector values by the given scalar
   * @name scale
   * @memberof ObservableVector3d
   * @param {number} x
   * @param {number} [y=x]
   * @param {number} [z=1]
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  scale(x, y = x, z = 1) {
    return this._set(this._x * x, this._y * y, this._z * z);
  }
  /**
   * Multiply this vector values by the passed vector
   * @name scaleV
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  scaleV(v) {
    return this._set(this._x * v.x, this._y * v.y, this._z * (v.z || 1));
  }
  /**
   * Divide this vector values by the passed value
   * @name div
   * @memberof ObservableVector3d
   * @param {number} n - the value to divide the vector by
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  div(n) {
    return this._set(this._x / n, this._y / n, this._z / n);
  }
  /**
   * Update this vector values to absolute values
   * @name abs
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  abs() {
    return this._set(
      this._x < 0 ? -this._x : this._x,
      this._y < 0 ? -this._y : this._y,
      this._Z < 0 ? -this._z : this._z
    );
  }
  /**
   * Clamp the vector value within the specified value range
   * @name clamp
   * @memberof ObservableVector3d
   * @param {number} low
   * @param {number} high
   * @returns {ObservableVector3d} new me.ObservableVector3d
   */
  clamp(low, high) {
    return new _ObservableVector3d(
      clamp(this._x, low, high),
      clamp(this._y, low, high),
      clamp(this._z, low, high),
      { onUpdate: this.onUpdate, scope: this.scope }
    );
  }
  /**
   * Clamp this vector value within the specified value range
   * @name clampSelf
   * @memberof ObservableVector3d
   * @param {number} low
   * @param {number} high
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  clampSelf(low, high) {
    return this._set(
      clamp(this._x, low, high),
      clamp(this._y, low, high),
      clamp(this._z, low, high)
    );
  }
  /**
   * Update this vector with the minimum value between this and the passed vector
   * @name minV
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  minV(v) {
    let _vz = v.z || 0;
    return this._set(
      this._x < v.x ? this._x : v.x,
      this._y < v.y ? this._y : v.y,
      this._z < _vz ? this._z : _vz
    );
  }
  /**
   * Update this vector with the maximum value between this and the passed vector
   * @name maxV
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  maxV(v) {
    let _vz = v.z || 0;
    return this._set(
      this._x > v.x ? this._x : v.x,
      this._y > v.y ? this._y : v.y,
      this._z > _vz ? this._z : _vz
    );
  }
  /**
   * Floor the vector values
   * @name floor
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} new me.ObservableVector3d
   */
  floor() {
    return new _ObservableVector3d(
      Math.floor(this._x),
      Math.floor(this._y),
      Math.floor(this._z),
      { onUpdate: this.onUpdate, scope: this.scope }
    );
  }
  /**
   * Floor this vector values
   * @name floorSelf
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  floorSelf() {
    return this._set(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  }
  /**
   * Ceil the vector values
   * @name ceil
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} new me.ObservableVector3d
   */
  ceil() {
    return new _ObservableVector3d(
      Math.ceil(this._x),
      Math.ceil(this._y),
      Math.ceil(this._z),
      { onUpdate: this.onUpdate, scope: this.scope }
    );
  }
  /**
   * Ceil this vector values
   * @name ceilSelf
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  ceilSelf() {
    return this._set(Math.ceil(this._x), Math.ceil(this._y), Math.ceil(this._z));
  }
  /**
   * Negate the vector values
   * @name negate
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} new me.ObservableVector3d
   */
  negate() {
    return new _ObservableVector3d(
      -this._x,
      -this._y,
      -this._z,
      { onUpdate: this.onUpdate, scope: this.scope }
    );
  }
  /**
   * Negate this vector values
   * @name negateSelf
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  negateSelf() {
    return this._set(-this._x, -this._y, -this._z);
  }
  /**
   * Copy the components of the given vector into this one
   * @name copy
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  copy(v) {
    return this._set(v.x, v.y, v.z || 0);
  }
  /**
   * return true if the two vectors are the same
   * @name equals
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {boolean}
   */
  equals(v) {
    return this._x === v.x && this._y === v.y && this._z === (v.z || this._z);
  }
  /**
   * change this vector to be perpendicular to what it was before.<br>
   * (Effectively rotates it 90 degrees in a clockwise direction)
   * @name perp
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  perp() {
    return this._set(this._y, -this._x, this._z);
  }
  /**
   * Rotate this vector (counter-clockwise) by the specified angle (in radians).
   * @name rotate
   * @memberof ObservableVector3d
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d|ObservableVector2d} [v] - an optional point to rotate around (on the same z axis)
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  rotate(angle, v) {
    let cx = 0;
    let cy = 0;
    if (typeof v === "object") {
      cx = v.x;
      cy = v.y;
    }
    let x = this.x - cx;
    let y = this.y - cy;
    let c = Math.cos(angle);
    let s = Math.sin(angle);
    return this._set(x * c - y * s + cx, x * s + y * c + cy, this.z);
  }
  /**
   * return the dot product of this vector and the passed one
   * @name dot
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {number} The dot product.
   */
  dot(v) {
    return this._x * v.x + this._y * v.y + this._z * (v.z || 1);
  }
  /**
   * calculate the cross product of this vector and the passed one
   * @name cross
   * @memberof ObservableVector3d
   * @param {Vector3d|ObservableVector3d} v
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  cross(v) {
    let ax = this._x, ay = this._y, az = this._z;
    let bx = v.x, by = v.y, bz = v.z;
    return this._set(
      ay * bz - az * by,
      az * bx - ax * bz,
      ax * by - ay * bx
    );
  }
  /**
   * Linearly interpolate between this vector and the given one.
   * @name lerp
   * @memberof ObservableVector3d
   * @param {Vector3d|ObservableVector3d} v
   * @param {number} alpha - distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  lerp(v, alpha2) {
    return this._set(
      this._x + (v.x - this._x) * alpha2,
      this._y + (v.y - this._y) * alpha2,
      this._z + (v.z - this._z) * alpha2
    );
  }
  /**
   * interpolate the position of this vector on the x and y axis towards the given one while ensure that the distance never exceeds the given step.
   * @name moveTowards
   * @memberof ObservableVector3d
   * @param {Vector2d|ObservableVector2d|Vector3d|ObservableVector3d} target
   * @param {number} step - the maximum step per iteration (Negative values will push the vector away from the target)
   * @returns {ObservableVector3d} Reference to this object for method chaining
   */
  moveTowards(target, step) {
    let angle = Math.atan2(target.y - this._y, target.x - this._x);
    let dx = this._x - target.x;
    let dy = this._y - target.y;
    let distance = Math.sqrt(dx * dx + dy * dy);
    if (distance === 0 || step >= 0 && distance <= step * step) {
      return target;
    }
    return this._set(
      this._x + Math.cos(angle) * step,
      this._y + Math.sin(angle) * step,
      this._z
    );
  }
  /**
   * return the distance between this vector and the passed one
   * @name distance
   * @memberof ObservableVector3d
   * @param {Vector2d|Vector3d|ObservableVector2d|ObservableVector3d} v
   * @returns {number}
   */
  distance(v) {
    let dx = this._x - v.x;
    let dy = this._y - v.y;
    let dz = this._z - (v.z || 0);
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  /**
   * return a clone copy of this vector
   * @name clone
   * @memberof ObservableVector3d
   * @returns {ObservableVector3d} new me.ObservableVector3d
   */
  clone() {
    return pool.pull(
      "ObservableVector3d",
      this._x,
      this._y,
      this._z,
      { onUpdate: this.onUpdate }
    );
  }
  /**
   * return a `me.Vector3d` copy of this `me.ObservableVector3d` object
   * @name toVector3d
   * @memberof ObservableVector3d
   * @returns {Vector3d} new me.Vector3d
   */
  toVector3d() {
    return pool.pull("Vector3d", this._x, this._y, this._z);
  }
  /**
   * convert the object to a string representation
   * @name toString
   * @memberof ObservableVector3d
   * @returns {string}
   */
  toString() {
    return "x:" + this._x + ",y:" + this._y + ",z:" + this._z;
  }
};
var Matrix2d = class {
  /**
   * @param {(Matrix2d|Matrix3d|...number)} args - an instance of me.Matrix2d or me.Matrix3d to copy from, or individual matrix components (See {@link Matrix2d.setTransform}). If not arguments are given, the matrix will be set to Identity.
   */
  constructor(...args) {
    this.onResetEvent(...args);
  }
  /**
   * @ignore
   */
  onResetEvent() {
    const arg0 = arguments[0];
    const argLen = arguments.length;
    if (typeof this.val === "undefined") {
      this.val = new Float32Array(9);
    }
    if (argLen === 1) {
      if (arg0.val.length === 9) {
        this.copy(arg0);
      } else if (arg0.val.length === 16) {
        this.fromMat3d(arguments[0]);
      } else {
        throw new Error("invalid Matrix2d constructor parameter");
      }
    } else if (arguments.length >= 6) {
      this.setTransform.apply(this, arguments);
    } else {
      this.identity();
    }
  }
  /**
   * tx component of the matrix
   * @type {number}
   * @see Matrix2d.translate
   */
  get tx() {
    return this.val[6];
  }
  /**
   * ty component of the matrix
   * @type {number}
   * @see Matrix2d.translate
   */
  get ty() {
    return this.val[7];
  }
  /**
   * reset the transformation matrix to the identity matrix (no transformation).<br>
   * the identity matrix and parameters position : <br>
   * <img src="images/identity-matrix_2x.png"/>
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  identity() {
    this.setTransform(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * set the matrix to the specified value
   * @param {number} a
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @param {number} e
   * @param {number} f
   * @param {number} [g=0]
   * @param {number} [h=0]
   * @param {number} [i=1]
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  setTransform() {
    let a = this.val;
    if (arguments.length === 9) {
      a[0] = arguments[0];
      a[1] = arguments[1];
      a[2] = arguments[2];
      a[3] = arguments[3];
      a[4] = arguments[4];
      a[5] = arguments[5];
      a[6] = arguments[6];
      a[7] = arguments[7];
      a[8] = arguments[8];
    } else if (arguments.length === 6) {
      a[0] = arguments[0];
      a[1] = arguments[2];
      a[2] = arguments[4];
      a[3] = arguments[1];
      a[4] = arguments[3];
      a[5] = arguments[5];
      a[6] = 0;
      a[7] = 0;
      a[8] = 1;
    }
    return this;
  }
  /**
   * Multiplies the current transformation with the matrix described by the arguments of this method
   * @param {number} a
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @param {number} e
   * @param {number} f
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  transform(a, b, c, d, e, f2) {
    let v = this.val, a0 = v[0], a1 = v[1], a3 = v[3], a4 = v[4], b0 = a, b1 = b, b3 = c, b4 = d, b6 = e, b7 = f2;
    v[0] = a0 * b0 + a3 * b1;
    v[1] = a1 * b0 + a4 * b1;
    v[3] = a0 * b3 + a3 * b4;
    v[4] = a1 * b3 + a4 * b4;
    v[6] += a0 * b6 + a3 * b7;
    v[7] += a1 * b6 + a4 * b7;
    return this;
  }
  /**
   * Copies over the values from another me.Matrix2d.
   * @param {Matrix2d} m - the matrix object to copy from
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  copy(m) {
    this.val.set(m.val);
    return this;
  }
  /**
   * Copies over the upper-left 3x3 values from the given me.Matrix3d
   * @param {Matrix3d} m - the matrix object to copy from
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  fromMat3d(m) {
    let b = m.val;
    let a = this.val;
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[4];
    a[4] = b[5];
    a[5] = b[6];
    a[6] = b[8];
    a[7] = b[9];
    a[8] = b[10];
    return this;
  }
  /**
   * multiply both matrix
   * @param {Matrix2d} m - the other matrix
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  multiply(m) {
    let b = m.val;
    let a = this.val, a0 = a[0], a1 = a[1], a3 = a[3], a4 = a[4], b0 = b[0], b1 = b[1], b3 = b[3], b4 = b[4], b6 = b[6], b7 = b[7];
    a[0] = a0 * b0 + a3 * b1;
    a[1] = a1 * b0 + a4 * b1;
    a[3] = a0 * b3 + a3 * b4;
    a[4] = a1 * b3 + a4 * b4;
    a[6] += a0 * b6 + a3 * b7;
    a[7] += a1 * b6 + a4 * b7;
    return this;
  }
  /**
   * Transpose the value of this matrix.
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  transpose() {
    let a = this.val, a1 = a[1], a2 = a[2], a5 = a[5];
    a[1] = a[3];
    a[2] = a[6];
    a[3] = a1;
    a[5] = a[7];
    a[6] = a2;
    a[7] = a5;
    return this;
  }
  /**
   * invert this matrix, causing it to apply the opposite transformation.
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  invert() {
    let val = this.val;
    let a = val[0], b = val[1], c = val[2], d = val[3], e = val[4], f2 = val[5], g2 = val[6], h = val[7], i = val[8];
    let ta = i * e - f2 * h, td = f2 * g2 - i * d, tg = h * d - e * g2;
    let n = a * ta + b * td + c * tg;
    val[0] = ta / n;
    val[1] = (c * h - i * b) / n;
    val[2] = (f2 * b - c * e) / n;
    val[3] = td / n;
    val[4] = (i * a - c * g2) / n;
    val[5] = (c * d - f2 * a) / n;
    val[6] = tg / n;
    val[7] = (b * g2 - h * a) / n;
    val[8] = (e * a - b * d) / n;
    return this;
  }
  /**
  * apply the current transform to the given 2d or 3d vector
  * @param {Vector2d|Vector3d} v - the vector object to be transformed
  * @returns {Vector2d|Vector3d} result vector object.
  */
  apply(v) {
    let a = this.val, x = v.x, y = v.y, z = typeof v.z !== "undefined" ? v.z : 1;
    v.x = x * a[0] + y * a[3] + z * a[6];
    v.y = x * a[1] + y * a[4] + z * a[7];
    if (typeof v.z !== "undefined") {
      v.z = x * a[2] + y * a[5] + z * a[8];
    }
    return v;
  }
  /**
   * apply the inverted current transform to the given 2d vector
   * @param {Vector2d} v - the vector object to be transformed
   * @returns {Vector2d} result vector object.
   */
  applyInverse(v) {
    let a = this.val, x = v.x, y = v.y;
    let invD = 1 / (a[0] * a[4] + a[3] * -a[1]);
    v.x = a[4] * invD * x + -a[3] * invD * y + (a[7] * a[3] - a[6] * a[4]) * invD;
    v.y = a[0] * invD * y + -a[1] * invD * x + (-a[7] * a[0] + a[6] * a[1]) * invD;
    return v;
  }
  /**
   * scale the matrix
   * @param {number} x - a number representing the abscissa of the scaling vector.
   * @param {number} [y=x] - a number representing the ordinate of the scaling vector.
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  scale(x, y = x) {
    let a = this.val;
    a[0] *= x;
    a[1] *= x;
    a[3] *= y;
    a[4] *= y;
    return this;
  }
  /**
   * adds a 2D scaling transformation.
   * @param {Vector2d} v - scaling vector
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  scaleV(v) {
    return this.scale(v.x, v.y);
  }
  /**
   * specifies a 2D scale operation using the [sx, 1] scaling vector
   * @param {number} x - x scaling vector
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  scaleX(x) {
    return this.scale(x, 1);
  }
  /**
   * specifies a 2D scale operation using the [1,sy] scaling vector
   * @param {number} y - y scaling vector
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  scaleY(y) {
    return this.scale(1, y);
  }
  /**
   * rotate the matrix (counter-clockwise) by the specified angle (in radians).
   * @param {number} angle - Rotation angle in radians.
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  rotate(angle) {
    if (angle !== 0) {
      let a = this.val, a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], s = Math.sin(angle), c = Math.cos(angle);
      a[0] = c * a00 + s * a10;
      a[1] = c * a01 + s * a11;
      a[2] = c * a02 + s * a12;
      a[3] = c * a10 - s * a00;
      a[4] = c * a11 - s * a01;
      a[5] = c * a12 - s * a02;
    }
    return this;
  }
  /**
   * translate the matrix position on the horizontal and vertical axis
   * @param {number|Vector2d} x - the x coordindates or a vector to translate the matrix by
   * @param {number} [y] - the y coordindates to translate the matrix by
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  translate() {
    let a = this.val;
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    a[6] += a[0] * _x + a[3] * _y;
    a[7] += a[1] * _x + a[4] * _y;
    return this;
  }
  /**
   * returns true if the matrix is an identity matrix.
   * @returns {boolean}
   */
  isIdentity() {
    let a = this.val;
    return a[0] === 1 && a[1] === 0 && a[2] === 0 && a[3] === 0 && a[4] === 1 && a[5] === 0 && a[6] === 0 && a[7] === 0 && a[8] === 1;
  }
  /**
   * return true if the two matrices are identical
   * @param {Matrix2d} m - the other matrix
   * @returns {boolean} true if both are equals
   */
  equals(m) {
    let b = m.val;
    let a = this.val;
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Clone the Matrix
   * @returns {Matrix2d}
   */
  clone() {
    return pool.pull("Matrix2d", this);
  }
  /**
   * return an array representation of this Matrix
   * @returns {Float32Array}
   */
  toArray() {
    return this.val;
  }
  /**
   * convert the object to a string representation
   * @returns {string}
   */
  toString() {
    let a = this.val;
    return "me.Matrix2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
};
var Matrix3d = class {
  /**
   * @param {(Matrix3d|...number)} args - An instance of me.Matrix3d to copy from, or individual Matrix components (See {@link Matrix3d.setTransform}). If not arguments are given, the matrix will be set to Identity.
   */
  constructor(...args) {
    this.onResetEvent(...args);
  }
  /**
   * @ignore
   */
  onResetEvent() {
    const arg0 = arguments[0];
    const argLen = arguments.length;
    if (typeof this.val === "undefined") {
      this.val = new Float32Array(16);
    }
    if (argLen === 1 && arg0.val.length === 16) {
      this.copy(arg0);
    } else if (argLen === 16) {
      this.setTransform.apply(this, arguments);
    } else {
      this.identity();
    }
  }
  /**
   * tx component of the matrix
   * @type {number}
   */
  get tx() {
    return this.val[12];
  }
  /**
   * ty component of the matrix
   * @type {number}
   */
  get ty() {
    return this.val[13];
  }
  /**
   * ty component of the matrix
   * @type {number}
   */
  get tz() {
    return this.val[14];
  }
  /**
   * reset the transformation matrix to the identity matrix (no transformation).<br>
   * the identity matrix and parameters position : <br>
   * <img src="images/identity-matrix_2x.png"/>
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  identity() {
    return this.setTransform(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  /**
   * set the matrix to the specified value
   * @param {number} m00
   * @param {number} m01
   * @param {number} m02
   * @param {number} m03
   * @param {number} m10
   * @param {number} m11
   * @param {number} m12
   * @param {number} m13
   * @param {number} m20
   * @param {number} m21
   * @param {number} m22
   * @param {number} m23
   * @param {number} m30
   * @param {number} m31
   * @param {number} m32
   * @param {number} m33
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  setTransform(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    let a = this.val;
    a[0] = m00;
    a[1] = m01;
    a[2] = m02;
    a[3] = m03;
    a[4] = m10;
    a[5] = m11;
    a[6] = m12;
    a[7] = m13;
    a[8] = m20;
    a[9] = m21;
    a[10] = m22;
    a[11] = m23;
    a[12] = m30;
    a[13] = m31;
    a[14] = m32;
    a[15] = m33;
    return this;
  }
  /**
   * Copies over the values from another me.Matrix3d.
   * @param {Matrix3d} m - the matrix object to copy from
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  copy(m) {
    this.val.set(m.val);
    return this;
  }
  /**
   * Copies over the upper-left 2x2 values from the given me.Matrix2d
   * @param {Matrix2d} m - the matrix object to copy from
   * @returns {Matrix2d} Reference to this object for method chaining
   */
  fromMat2d(m) {
    let b = m.val;
    return this.setTransform(
      b[0],
      b[3],
      b[6],
      0,
      b[1],
      b[4],
      b[7],
      0,
      b[2],
      b[5],
      b[8],
      0,
      0,
      0,
      0,
      1
    );
  }
  /**
   * multiply both matrix
   * @param {Matrix3d} m - Other matrix
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  multiply(m) {
    let a = this.val;
    let b = m.val;
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return this;
  }
  /**
   * Transpose the value of this matrix.
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  transpose() {
    let a = this.val, a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
    a[1] = a[4];
    a[2] = a[8];
    a[3] = a[12];
    a[4] = a01;
    a[6] = a[9];
    a[7] = a[13];
    a[8] = a02;
    a[9] = a12;
    a[11] = a[14];
    a[12] = a03;
    a[13] = a13;
    a[14] = a23;
    return this;
  }
  /**
   * invert this matrix, causing it to apply the opposite transformation.
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  invert() {
    let a = this.val;
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b00 = a00 * a11 - a01 * a10;
    let b01 = a00 * a12 - a02 * a10;
    let b02 = a00 * a13 - a03 * a10;
    let b03 = a01 * a12 - a02 * a11;
    let b04 = a01 * a13 - a03 * a11;
    let b05 = a02 * a13 - a03 * a12;
    let b06 = a20 * a31 - a21 * a30;
    let b07 = a20 * a32 - a22 * a30;
    let b08 = a20 * a33 - a23 * a30;
    let b09 = a21 * a32 - a22 * a31;
    let b10 = a21 * a33 - a23 * a31;
    let b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return this;
  }
  /**
   * apply the current transform to the given 2d or 3d vector
   * @param {Vector2d|Vector3d} v - the vector object to be transformed
   * @returns {Vector2d|Vector3d} result vector object.
   */
  apply(v) {
    let a = this.val, x = v.x, y = v.y, z = typeof v.z !== "undefined" ? v.z : 1;
    let w = a[3] * x + a[7] * y + a[11] * z + a[15] || 1;
    v.x = (a[0] * x + a[4] * y + a[8] * z + a[12]) / w;
    v.y = (a[1] * x + a[5] * y + a[9] * z + a[13]) / w;
    if (typeof v.z !== "undefined") {
      v.z = (a[2] * x + a[6] * y + a[10] * z + a[14]) / w;
    }
    return v;
  }
  /**
    * apply the inverted current transform to the given 2d or 3d vector
    * @param {Vector2d|Vector3d} v - the vector object to be transformed
    * @returns {Vector2d|Vector3d} result vector object.
    */
  applyInverse(v) {
    let im = pool.pull("Matrix3d", this).invert();
    im.apply(v);
    pool.push(im);
    return v;
  }
  /**
   * generate an orthogonal projection matrix, with the result replacing the current matrix
   * <img src="images/glOrtho.gif"/><br>
   * @param {number} left - farthest left on the x-axis
   * @param {number} right - farthest right on the x-axis
   * @param {number} bottom - farthest down on the y-axis
   * @param {number} top - farthest up on the y-axis
   * @param {number} near - distance to the near clipping plane along the -Z axis
   * @param {number} far - distance to the far clipping plane along the -Z axis
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  ortho(left, right, bottom, top, near, far) {
    let a = this.val;
    let leftRight = 1 / (left - right);
    let bottomTop = 1 / (bottom - top);
    let nearFar = 1 / (near - far);
    a[0] = -2 * leftRight;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = -2 * bottomTop;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 2 * nearFar;
    a[11] = 0;
    a[12] = (left + right) * leftRight;
    a[13] = (top + bottom) * bottomTop;
    a[14] = (far + near) * nearFar;
    a[15] = 1;
    return this;
  }
  /**
   * scale the matrix
   * @param {number} x - a number representing the abscissa of the scaling vector.
   * @param {number} [y=x] - a number representing the ordinate of the scaling vector.
   * @param {number} [z=0] - a number representing the depth vector
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  scale(x, y = x, z = 0) {
    let a = this.val;
    a[0] = a[0] * x;
    a[1] = a[1] * x;
    a[2] = a[2] * x;
    a[3] = a[3] * x;
    a[4] = a[4] * y;
    a[5] = a[5] * y;
    a[6] = a[6] * y;
    a[7] = a[7] * y;
    a[8] = a[8] * z;
    a[9] = a[9] * z;
    a[10] = a[10] * z;
    a[11] = a[11] * z;
    return this;
  }
  /**
   * adds a 2D scaling transformation.
   * @param {Vector2d|Vector3d} v - scaling vector
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  scaleV(v) {
    return this.scale(v.x, v.y, v.z);
  }
  /**
   * specifies a 2D scale operation using the [sx, 1] scaling vector
   * @param {number} x - x scaling vector
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  scaleX(x) {
    return this.scale(x, 1);
  }
  /**
   * specifies a 2D scale operation using the [1,sy] scaling vector
   * @param {number} y - y scaling vector
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  scaleY(y) {
    return this.scale(1, y);
  }
  /**
   * rotate this matrix (counter-clockwise) by the specified angle (in radians).
   * @param {number} angle - Rotation angle in radians.
   * @param {Vector3d} v - the axis to rotate around
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  rotate(angle, v) {
    if (angle !== 0) {
      let a = this.val, x = v.x, y = v.y, z = v.z;
      let len = Math.sqrt(x * x + y * y + z * z);
      let s, c, t2;
      let a00, a01, a02, a03;
      let a10, a11, a12, a13;
      let a20, a21, a22, a23;
      let b00, b01, b02;
      let b10, b11, b12;
      let b20, b21, b22;
      if (len < EPSILON) {
        return null;
      }
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(angle);
      c = Math.cos(angle);
      t2 = 1 - c;
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      b00 = x * x * t2 + c;
      b01 = y * x * t2 + z * s;
      b02 = z * x * t2 - y * s;
      b10 = x * y * t2 - z * s;
      b11 = y * y * t2 + c;
      b12 = z * y * t2 + x * s;
      b20 = x * z * t2 + y * s;
      b21 = y * z * t2 - x * s;
      b22 = z * z * t2 + c;
      a[0] = a00 * b00 + a10 * b01 + a20 * b02;
      a[1] = a01 * b00 + a11 * b01 + a21 * b02;
      a[2] = a02 * b00 + a12 * b01 + a22 * b02;
      a[3] = a03 * b00 + a13 * b01 + a23 * b02;
      a[4] = a00 * b10 + a10 * b11 + a20 * b12;
      a[5] = a01 * b10 + a11 * b11 + a21 * b12;
      a[6] = a02 * b10 + a12 * b11 + a22 * b12;
      a[7] = a03 * b10 + a13 * b11 + a23 * b12;
      a[8] = a00 * b20 + a10 * b21 + a20 * b22;
      a[9] = a01 * b20 + a11 * b21 + a21 * b22;
      a[10] = a02 * b20 + a12 * b21 + a22 * b22;
      a[11] = a03 * b20 + a13 * b21 + a23 * b22;
    }
    return this;
  }
  /**
   * translate the matrix position using the given vector
   * @param {number|Vector2d|Vector3d} x - a number representing the abscissa of the vector, or a vector object
   * @param {number} [y] - a number representing the ordinate of the vector.
   * @param {number} [z=0] - a number representing the depth of the vector
   * @returns {Matrix3d} Reference to this object for method chaining
   */
  translate() {
    let a = this.val;
    let _x, _y, _z;
    if (arguments.length > 1) {
      _x = arguments[0];
      _y = arguments[1];
      _z = typeof arguments[2] === "undefined" ? 0 : arguments[2];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
      _z = typeof arguments[0].z === "undefined" ? 0 : arguments[0].z;
    }
    a[12] = a[0] * _x + a[4] * _y + a[8] * _z + a[12];
    a[13] = a[1] * _x + a[5] * _y + a[9] * _z + a[13];
    a[14] = a[2] * _x + a[6] * _y + a[10] * _z + a[14];
    a[15] = a[3] * _x + a[7] * _y + a[11] * _z + a[15];
    return this;
  }
  /**
   * returns true if the matrix is an identity matrix.
   * @returns {boolean}
   */
  isIdentity() {
    let a = this.val;
    return a[0] === 1 && a[1] === 0 && a[2] === 0 && a[3] === 0 && a[4] === 0 && a[5] === 1 && a[6] === 0 && a[7] === 0 && a[8] === 0 && a[9] === 0 && a[10] === 1 && a[11] === 0 && a[12] === 0 && a[13] === 0 && a[14] === 0 && a[15] === 1;
  }
  /**
   * return true if the two matrices are identical
   * @param {Matrix3d} m - the other matrix
   * @returns {boolean} true if both are equals
   */
  equals(m) {
    let b = m.val;
    let a = this.val;
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Clone the Matrix
   * @returns {Matrix3d}
   */
  clone() {
    return pool.pull("Matrix3d", this);
  }
  /**
   * return an array representation of this Matrix
   * @returns {Float32Array}
   */
  toArray() {
    return this.val;
  }
  /**
   * convert the object to a string representation
   * @returns {string}
   */
  toString() {
    let a = this.val;
    return "me.Matrix3d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
};
var earcut$2 = { exports: {} };
var earcut_1 = earcut$2.exports;
earcut$2.exports = earcut;
var _default = earcut$2.exports.default = earcut;
function earcut(data2, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data2.length, outerNode = linkedList(data2, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles) outerNode = eliminateHoles(data2, holeIndices, outerNode, dim);
  if (data2.length > 80 * dim) {
    minX = maxX = data2[0];
    minY = maxY = data2[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data2[i];
      y = data2[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data2, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data2, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data2[i], data2[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data2[i], data2[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop2 = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop2 = next.next;
      continue;
    }
    ear = next;
    if (ear === stop2) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects$3(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data2, holeIndices, outerNode, dim) {
  var queue = [], i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data2.length;
    list = linkedList(data2, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  var stop2 = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop2);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  var p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects$3(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects$3(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node$1(a.i, a.x, a.y), b2 = new Node$1(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node$1(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node$1(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data2, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data2.length;
  var polygonArea = Math.abs(signedArea(data2, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data2.length;
      polygonArea -= Math.abs(signedArea(data2, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs(
      (data2[a] - data2[c]) * (data2[b + 1] - data2[a + 1]) - (data2[a] - data2[b]) * (data2[c + 1] - data2[a + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data2, start, end, dim) {
  var sum = 0;
  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data2[j] - data2[i]) * (data2[i + 1] + data2[j + 1]);
    j = i;
  }
  return sum;
}
earcut.flatten = function(data2) {
  var dim = data2[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data2.length; i++) {
    for (var j = 0; j < data2[i].length; j++) {
      for (var d = 0; d < dim; d++) result.vertices.push(data2[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data2[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
var earcut$1 = getDefaultExportFromCjs(earcutExports);
var Polygon = class _Polygon {
  /**
   * @param {number} [x=0] - origin point of the Polygon
   * @param {number} [y=0] - origin point of the Polygon
   * @param {Vector2d[]} points - array of vector defining the Polygon
   */
  constructor(x = 0, y = 0, points) {
    this.pos = pool.pull("Vector2d");
    this.points = [];
    this.edges = [];
    this.indices = [];
    this.normals = [];
    this._bounds;
    this.type = "Polygon";
    this.setShape(x, y, points);
  }
  /** @ignore */
  onResetEvent(x, y, points) {
    this.setShape(x, y, points);
  }
  /**
   * set new value to the Polygon
   * @param {number} x - position of the Polygon
   * @param {number} y - position of the Polygon
   * @param {Vector2d[]|number[]} points - array of vector or vertice defining the Polygon
   * @returns {Polygon} this instance for objecf chaining
   */
  setShape(x, y, points) {
    this.pos.set(x, y);
    this.setVertices(points);
    return this;
  }
  /**
   * set the vertices defining this Polygon
   * @param {Vector2d[]} vertices - array of vector or vertice defining the Polygon
   * @returns {Polygon} this instance for objecf chaining
   */
  setVertices(vertices) {
    if (!Array.isArray(vertices)) {
      return this;
    }
    if (typeof vertices[0] === "object") {
      if (typeof vertices[0].setV === "function") {
        this.points = vertices;
      } else {
        this.points.length = 0;
        vertices.forEach((vertice) => {
          this.points.push(pool.pull("Vector2d", vertice.x, vertice.y));
        });
      }
    } else {
      let verticesLength = vertices.length;
      this.points.length = 0;
      for (let p = 0; p < verticesLength; p += 2) {
        this.points.push(pool.pull("Vector2d", vertices[p], vertices[p + 1]));
      }
    }
    this.recalc();
    this.updateBounds();
    return this;
  }
  /**
   * apply the given transformation matrix to this Polygon
   * @param {Matrix2d} m - the transformation matrix
   * @returns {Polygon} Reference to this object for method chaining
   */
  transform(m) {
    let points = this.points;
    let len = points.length;
    for (let i = 0; i < len; i++) {
      m.apply(points[i]);
    }
    this.recalc();
    this.updateBounds();
    return this;
  }
  /**
   * apply an isometric projection to this shape
   * @returns {Polygon} Reference to this object for method chaining
   */
  toIso() {
    return this.rotate(Math.PI / 4).scale(Math.SQRT2, Math.SQRT1_2);
  }
  /**
   * apply a 2d projection to this shapen
   * @returns {Polygon} Reference to this object for method chaining
   */
  to2d() {
    return this.scale(Math.SQRT1_2, Math.SQRT2).rotate(-Math.PI / 4);
  }
  /**
   * Rotate this Polygon (counter-clockwise) by the specified angle (in radians).
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d|ObservableVector2d} [v] - an optional point to rotate around
   * @returns {Polygon} Reference to this object for method chaining
   */
  rotate(angle, v) {
    if (angle !== 0) {
      let points = this.points;
      let len = points.length;
      for (let i = 0; i < len; i++) {
        points[i].rotate(angle, v);
      }
      this.recalc();
      this.updateBounds();
    }
    return this;
  }
  /**
   * Scale this Polygon by the given scalar.
   * @param {number} x
   * @param {number} [y=x]
   * @returns {Polygon} Reference to this object for method chaining
   */
  scale(x, y = x) {
    let points = this.points;
    let len = points.length;
    for (let i = 0; i < len; i++) {
      points[i].scale(x, y);
    }
    this.recalc();
    this.updateBounds();
    return this;
  }
  /**
   * Scale this Polygon by the given vector
   * @param {Vector2d} v
   * @returns {Polygon} Reference to this object for method chaining
   */
  scaleV(v) {
    return this.scale(v.x, v.y);
  }
  /**
   * Computes the calculated collision polygon.
   * This **must** be called if the `points` array, `angle`, or `offset` is modified manually.
   * @returns {Polygon} Reference to this object for method chaining
   */
  recalc() {
    let edges = this.edges;
    let normals = this.normals;
    let indices = this.indices;
    let points = this.points;
    let len = points.length;
    if (len < 3) {
      throw new Error("Requires at least 3 points");
    }
    for (let i = 0; i < len; i++) {
      let edge = edges[i];
      if (typeof edge === "undefined") {
        edge = edges[i] = pool.pull("Vector2d");
      }
      edge.copy(points[(i + 1) % len]).sub(points[i]);
      let normal = normals[i];
      if (typeof normal === "undefined") {
        normal = normals[i] = pool.pull("Vector2d");
      }
      normal.copy(edge).perp().normalize();
    }
    for (let i = len; i < edges.length; i++) {
      pool.push(edges[i]);
      pool.push(normals[i]);
    }
    edges.length = len;
    normals.length = len;
    indices.length = 0;
    return this;
  }
  /**
   * returns a list of indices for all triangles defined in this polygon
   * @returns {Array.<number>} an array of vertex indices for all triangles forming this polygon.
   */
  getIndices() {
    if (this.indices.length === 0) {
      this.indices = earcut$1(this.points.flatMap((p) => [p.x, p.y]));
    }
    return this.indices;
  }
  /**
   * Returns true if the vertices composing this polygon form a convex shape (vertices must be in clockwise order).
   * @returns {boolean} true if the vertices are convex, false if not, null if not computable
   */
  isConvex() {
    let flag = 0, vertices = this.points, n = vertices.length;
    if (n < 3) {
      return null;
    }
    for (let i = 0; i < n; i++) {
      let j = (i + 1) % n;
      let k = (i + 2) % n;
      let z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
      z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
      if (z < 0) {
        flag |= 1;
      } else if (z > 0) {
        flag |= 2;
      }
      if (flag === 3) {
        return false;
      }
    }
    if (flag !== 0) {
      return true;
    } else {
      return null;
    }
  }
  /**
   * translate the Polygon by the specified offset
   * @param {number|Vector2d} x -  x offset or a vector point to translate by
   * @param {number} [y] - y offset
   * @returns {Polygon} Reference to this object for method chaining
   * @example
   * polygon.translate(10, 10);
   * // or
   * polygon.translate(myVector2d);
   */
  translate() {
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    this.pos.x += _x;
    this.pos.y += _y;
    this.getBounds().translate(_x, _y);
    return this;
  }
  /**
   * Shifts the Polygon to the given position vector.
   * @param {number|Vector2d} x -  x coordinate or a vector point to shift to
   * @param {number} [y]
   * @example
   * polygon.shift(10, 10);
   * // or
   * polygon.shift(myVector2d);
   */
  shift() {
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    this.pos.x = _x;
    this.pos.y = _y;
    this.updateBounds();
  }
  /**
   * Returns true if the polygon contains the given point. <br>
   * (Note: it is highly recommended to first do a hit test on the corresponding <br>
   *  bounding rect, as the function can be highly consuming with complex shapes)
   * @param {number|Vector2d} x -  x coordinate or a vector point to check
   * @param {number} [y] - y coordinate
   * @returns {boolean} True if the polygon contain the point, otherwise false
   * @example
   * if (polygon.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (polygon.contains(myVector2d)) {
   *   // do something
   * }
   */
  contains(...args) {
    let [_x, _y] = args.length === 2 ? args : [args[0].x, args[0].y];
    let intersects2 = false;
    let posx = this.pos.x, posy = this.pos.y;
    let points = this.points;
    let len = points.length;
    for (let i = 0, j = len - 1; i < len; j = i++) {
      const iy = points[i].y + posy, ix = points[i].x + posx, jy = points[j].y + posy, jx = points[j].x + posx;
      if (iy > _y !== jy > _y && _x < (jx - ix) * (_y - iy) / (jy - iy) + ix) {
        intersects2 = !intersects2;
      }
    }
    return intersects2;
  }
  /**
   * returns the bounding box for this shape, the smallest Rectangle object completely containing this shape.
   * @returns {Bounds} this shape bounding box Rectangle object
   */
  getBounds() {
    if (typeof this._bounds === "undefined") {
      this._bounds = pool.pull("Bounds");
    }
    return this._bounds;
  }
  /**
   * update the bounding box for this shape.
   * @returns {Bounds} this shape bounding box Rectangle object
   */
  updateBounds() {
    let bounds = this.getBounds();
    bounds.update(this.points);
    bounds.translate(this.pos);
    return bounds;
  }
  /**
   * clone this Polygon
   * @returns {Polygon} new Polygon
   */
  clone() {
    let copy = [];
    this.points.forEach((point) => {
      copy.push(point.clone());
    });
    return new _Polygon(this.pos.x, this.pos.y, copy);
  }
};
var Line = class _Line extends Polygon {
  /**
   * Returns true if the Line contains the given point
   * @param {number|Vector2d} x -  x coordinate or a vector point to check
   * @param {number} [y] -  y coordinate
   * @returns {boolean} true if contains
   * @example
   * if (line.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (line.contains(myVector2d)) {
   *   // do something
   * }
   */
  contains() {
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    _x -= this.pos.x;
    _y -= this.pos.y;
    let start = this.points[0];
    let end = this.points[1];
    return (_y - start.y) * (end.x - start.x) === (end.y - start.y) * (_x - start.x);
  }
  /**
   * Computes the calculated collision edges and normals.
   * This **must** be called if the `points` array, `angle`, or `offset` is modified manually.
   * @returns {Line} this instance for objecf chaining
   */
  recalc() {
    let edges = this.edges;
    let normals = this.normals;
    let indices = this.indices;
    let points = this.points;
    if (points.length !== 2) {
      throw new Error("Requires exactly 2 points");
    }
    if (edges[0] === void 0) {
      edges[0] = pool.pull("Vector2d");
    }
    edges[0].copy(points[1]).sub(points[0]);
    if (normals[0] === void 0) {
      normals[0] = pool.pull("Vector2d");
    }
    normals[0].copy(edges[0]).perp().normalize();
    indices.length = 0;
    return this;
  }
  /**
   * clone this line segment
   * @returns {Line} new Line
   */
  clone() {
    let copy = [];
    this.points.forEach((point) => {
      copy.push(point.clone());
    });
    return new _Line(this.pos.x, this.pos.y, copy);
  }
};
var Ellipse = class _Ellipse {
  /**
   * @param {number} x - the center x coordinate of the ellipse
   * @param {number} y - the center y coordinate of the ellipse
   * @param {number} w - width (diameter) of the ellipse
   * @param {number} h - height (diameter) of the ellipse
   */
  constructor(x, y, w, h) {
    this.pos = pool.pull("Vector2d");
    this._bounds = void 0;
    this.radius = NaN;
    this.radiusV = pool.pull("Vector2d");
    this.radiusSq = pool.pull("Vector2d");
    this.ratio = pool.pull("Vector2d");
    this.type = "Ellipse";
    this.setShape(x, y, w, h);
  }
  /** @ignore */
  onResetEvent(x, y, w, h) {
    this.setShape(x, y, w, h);
  }
  /**
   * set new value to the Ellipse shape
   * @param {number} x - the center x coordinate of the ellipse
   * @param {number} y - the center y coordinate of the ellipse
   * @param {number} w - width (diameter) of the ellipse
   * @param {number} h - height (diameter) of the ellipse
   * @returns {Ellipse} this instance for objecf chaining
   */
  setShape(x, y, w, h) {
    const hW = w / 2;
    const hH = h / 2;
    const radius = Math.max(hW, hH);
    const r = radius * radius;
    this.pos.set(x, y);
    this.radius = radius;
    this.ratio.set(hW / radius, hH / radius);
    this.radiusV.set(radius, radius).scaleV(this.ratio);
    this.radiusSq.set(r, r).scaleV(this.ratio);
    let bounds = this.getBounds();
    bounds.setMinMax(x, y, x + w, x + h);
    bounds.translate(-this.radiusV.x, -this.radiusV.y);
    return this;
  }
  /**
   * Rotate this Ellipse (counter-clockwise) by the specified angle (in radians).
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d|ObservableVector2d} [v] - an optional point to rotate around
   * @returns {Ellipse} Reference to this object for method chaining
   */
  rotate(angle, v) {
    let bounds = this.getBounds();
    this.pos.rotate(angle, v);
    bounds.shift(this.pos);
    bounds.translate(-this.radiusV.x, -this.radiusV.y);
    return this;
  }
  /**
   * Scale this Ellipse by the specified scalar.
   * @param {number} x - the scale factor along the x-axis
   * @param {number} [y=x] - the scale factor along the y-axis
   * @returns {Ellipse} Reference to this object for method chaining
   */
  scale(x, y = x) {
    return this.setShape(
      this.pos.x,
      this.pos.y,
      this.radiusV.x * 2 * x,
      this.radiusV.y * 2 * y
    );
  }
  /**
   * Scale this Ellipse by the specified vector.
   * @param {Vector2d} v
   * @returns {Ellipse} Reference to this object for method chaining
   */
  scaleV(v) {
    return this.scale(v.x, v.y);
  }
  /**
   * apply the given transformation matrix to this ellipse
   * @param {Matrix2d} matrix - the transformation matrix
   * @returns {Ellipse} Reference to this object for method chaining
   */
  transform(matrix) {
    return this;
  }
  /**
   * translate the circle/ellipse by the specified offset
   * @param {number|Vector2d} x -  x coordinate or a vector point to translate by
   * @param {number} [y] - y offset
   * @returns {Ellipse} this ellipse
   * @example
   * ellipse.translate(10, 10);
   * // or
   * ellipse.translate(myVector2d);
   */
  translate() {
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    this.pos.x += _x;
    this.pos.y += _y;
    this.getBounds().translate(_x, _y);
    return this;
  }
  /**
   * check if this circle/ellipse contains the specified point
   * @param {number|Vector2d} x -  x coordinate or a vector point to check
   * @param {number} [y] -  y coordinate
   * @returns {boolean} true if contains
   * @example
   * if (circle.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (circle.contains(myVector2d)) {
   *  // do something
   * }
   */
  contains(...args) {
    let _x, _y;
    if (args.length === 2) {
      [_x, _y] = args;
    } else {
      [_x, _y] = [args[0].x, args[0].y];
    }
    _x -= this.pos.x;
    _y -= this.pos.y;
    return _x * _x / this.radiusSq.x + _y * _y / this.radiusSq.y <= 1;
  }
  /**
   * returns the bounding box for this shape, the smallest Rectangle object completely containing this shape.
   * @returns {Bounds} this shape bounding box Rectangle object
   */
  getBounds() {
    if (typeof this._bounds === "undefined") {
      this._bounds = pool.pull("Bounds");
    }
    return this._bounds;
  }
  /**
   * clone this Ellipse
   * @returns {Ellipse} new Ellipse
   */
  clone() {
    return new _Ellipse(
      this.pos.x,
      this.pos.y,
      this.radiusV.x * 2,
      this.radiusV.y * 2
    );
  }
};
var Point = class _Point {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    this.type = "Point";
  }
  /** @ignore */
  onResetEvent(x = 0, y = 0) {
    this.set(x, y);
  }
  /**
   * set the Point x and y properties to the given values
   * @param {number} x
   * @param {number} y
   * @returns {Point} Reference to this object for method chaining
   */
  set(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    return this;
  }
  /**
   * return true if this point is equal to the given point
   * @param {number|Point|Vector2d} x
   * @param {number} [y]
   * @returns {boolean}
   */
  equals(...args) {
    let _x, _y;
    if (args.length === 2) {
      [_x, _y] = args;
    } else {
      [_x, _y] = [args[0].x, args[0].y];
    }
    return this.x === _x && this.y === _y;
  }
  /**
   * clone this Point
   * @returns {Point} new Point
   */
  clone() {
    return new _Point(this.x, this.y);
  }
};
var Rect = class _Rect extends Polygon {
  /**
   * @param {number} x - position of the Rectangle
   * @param {number} y - position of the Rectangle
   * @param {number} w - width of the rectangle
   * @param {number} h - height of the rectangle
   */
  constructor(x, y, w, h) {
    super(x, y, [
      pool.pull("Vector2d", 0, 0),
      // 0, 0
      pool.pull("Vector2d", w, 0),
      // 1, 0
      pool.pull("Vector2d", w, h),
      // 1, 1
      pool.pull("Vector2d", 0, h)
      // 0, 1
    ]);
    this.type = "Rectangle";
  }
  /** @ignore */
  onResetEvent(x, y, w, h) {
    this.setShape(x, y, w, h);
  }
  /**
   * set new value to the rectangle shape
   * @param {number} x - position of the Rectangle
   * @param {number} y - position of the Rectangle
   * @param {number|Vector2d[]} w - width of the rectangle, or an array of vector defining the rectangle
   * @param {number} [h] - height of the rectangle, if a numeral width parameter is specified
   * @returns {Rect} this rectangle
   */
  setShape(x, y, w, h) {
    let points = w;
    this.pos.set(x, y);
    if (arguments.length === 4) {
      points = this.points;
      points[0].set(0, 0);
      points[1].set(w, 0);
      points[2].set(w, h);
      points[3].set(0, h);
    }
    this.setVertices(points);
    return this;
  }
  /**
   * left coordinate of the Rectangle
   * @type {number}
   */
  get left() {
    return this.pos.x;
  }
  /**
   * right coordinate of the Rectangle
   * @type {number}
   */
  get right() {
    let w = this.width;
    return this.left + w || w;
  }
  /**
   * top coordinate of the Rectangle
   * @type {number}
   */
  get top() {
    return this.pos.y;
  }
  /**
   * bottom coordinate of the Rectangle
   * @type {number}
   */
  get bottom() {
    let h = this.height;
    return this.top + h || h;
  }
  /**
   * width of the Rectangle
   * @type {number}
   */
  get width() {
    return this.points[2].x;
  }
  set width(value) {
    this.points[1].x = this.points[2].x = value;
    this.recalc();
    this.updateBounds();
  }
  /**
   * height of the Rectangle
   * @type {number}
   */
  get height() {
    return this.points[2].y;
  }
  set height(value) {
    this.points[2].y = this.points[3].y = value;
    this.recalc();
    this.updateBounds();
  }
  /**
   * absolute center of this rectangle on the horizontal axis
   * @type {number}
   */
  get centerX() {
    if (isFinite(this.width)) {
      return this.left + this.width / 2;
    } else {
      return this.width;
    }
  }
  set centerX(value) {
    this.pos.x = value - this.width / 2;
    this.recalc();
    this.updateBounds();
  }
  /**
   * absolute center of this rectangle on the vertical axis
   * @type {number}
   */
  get centerY() {
    if (isFinite(this.height)) {
      return this.top + this.height / 2;
    } else {
      return this.height;
    }
  }
  set centerY(value) {
    this.pos.y = value - this.height / 2;
    this.recalc();
    this.updateBounds();
  }
  /**
   * center the rectangle position around the given coordinates
   * @param {number} x - the x coordinate around which to center this rectangle
   * @param {number} y - the y coordinate around which to center this rectangle
   * @returns {Rect} this rectangle
   */
  centerOn(x, y) {
    this.centerX = x;
    this.centerY = y;
    return this;
  }
  /**
   * resize the rectangle
   * @param {number} w - new width of the rectangle
   * @param {number} h - new height of the rectangle
   * @returns {Rect} this rectangle
   */
  resize(w, h) {
    this.width = w;
    this.height = h;
    return this;
  }
  /**
   * scale the rectangle
   * @param {number} x - a number representing the abscissa of the scaling vector.
   * @param {number} [y=x] - a number representing the ordinate of the scaling vector.
   * @returns {Rect} this rectangle
   */
  scale(x, y = x) {
    this.width *= x;
    this.height *= y;
    return this;
  }
  /**
   * clone this rectangle
   * @returns {Rect} new rectangle
   */
  clone() {
    return new _Rect(this.left, this.top, this.width, this.height);
  }
  /**
   * copy the position and size of the given rectangle into this one
   * @param {Rect} rect - Source rectangle
   * @returns {Rect} new rectangle
   */
  copy(rect) {
    return this.setShape(rect.left, rect.top, rect.width, rect.height);
  }
  /**
   * merge this rectangle with another one
   * @param {Rect} rect - other rectangle to union with
   * @returns {Rect} the union(ed) rectangle
   */
  union(rect) {
    let x1 = Math.min(this.left, rect.left);
    let y1 = Math.min(this.top, rect.top);
    this.resize(
      Math.max(this.right, rect.right) - x1,
      Math.max(this.bottom, rect.bottom) - y1
    );
    this.pos.set(x1, y1);
    return this;
  }
  /**
   * check if this rectangle is intersecting with the specified one
   * @param {Rect} rect
   * @returns {boolean} true if overlaps
   */
  overlaps(rect) {
    return this.left < rect.right && rect.left < this.right && this.top < rect.bottom && rect.top < this.bottom;
  }
  /**
   * Returns true if the rectangle contains the given point or rectangle
   * @param {number|Vector2d|Rect} x -  x coordinate or a vector point, or a rectangle to test
   * @param {number} [y] - y coordinate
   * @returns {boolean} True if the rectangle contain the given point or rectangle, otherwise false
   * @example
   * if (rect.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (rect.contains(myVector2d)) {
   *   // do something
   * }
   * if (rect.contains(myRect)) {
   *   // do something
   * }
   */
  contains() {
    let arg0 = arguments[0];
    let _x1, _x2, _y1, _y2;
    if (arguments.length === 2) {
      _x1 = _x2 = arg0;
      _y1 = _y2 = arguments[1];
    } else {
      if (typeof arg0.bottom === "number") {
        _x1 = arg0.left;
        _x2 = arg0.right;
        _y1 = arg0.top;
        _y2 = arg0.bottom;
      } else {
        _x1 = _x2 = arg0.x;
        _y1 = _y2 = arg0.y;
      }
    }
    return _x1 >= this.left && _x2 <= this.right && _y1 >= this.top && _y2 <= this.bottom;
  }
  /**
   * check if this rectangle is identical to the specified one
   * @param {Rect} rect
   * @returns {boolean} true if equals
   */
  equals(rect) {
    return rect.left === this.left && rect.right === this.right && rect.top === this.top && rect.bottom === this.bottom;
  }
  /**
   * determines whether all coordinates of this rectangle are finite numbers.
   * @returns {boolean} false if all coordinates are positive or negative Infinity or NaN; otherwise, true.
   */
  isFinite() {
    return isFinite(this.left) && isFinite(this.top) && isFinite(this.width) && isFinite(this.height);
  }
  /**
   * Returns a polygon whose edges are the same as this box.
   * @returns {Polygon} a new Polygon that represents this rectangle.
   */
  toPolygon() {
    return pool.pull(
      "Polygon",
      this.left,
      this.top,
      this.points
    );
  }
};
var RoundRect = class _RoundRect extends Rect {
  /**
   * @param {number} x - position of the rounded rectangle
   * @param {number} y - position of the rounded rectangle
   * @param {number} width - the rectangle width
   * @param {number} height - the rectangle height
   * @param {number} [radius=20] - the radius of the rounded corner
   */
  constructor(x, y, width, height, radius = 20) {
    super(x, y, width, height);
    this.type = "RoundRect";
    this.radius = radius;
  }
  /** @ignore */
  onResetEvent(x, y, w, h, radius) {
    super.setShape(x, y, w, h);
    this.radius = radius;
  }
  /**
   * the radius of the rounded corner
   * @type {number}
   * @default 20
   */
  get radius() {
    return this._radius;
  }
  set radius(value) {
    if (this.width < 2 * value) {
      value = this.width / 2;
    }
    if (this.height < 2 * value) {
      value = this.height / 2;
    }
    this._radius = value;
  }
  /**
   * copy the position, size and radius of the given rounded rectangle into this one
   * @param {RoundRect} rrect - source rounded rectangle
   * @returns {RoundRect} new rectangle
   */
  copy(rrect) {
    super.setShape(rrect.pos.x, rrect.pos.y, rrect.width, rrect.height);
    this.radius = rrect.radius;
    return this;
  }
  /**
   * Returns true if the rounded rectangle contains the given point or rectangle
   * @param {number|Vector2d|Rect} x -  x coordinate or a vector point, or a Rect to test
   * @param {number} [y] - y coordinate
   * @returns {boolean} True if the rounded rectangle contain the given point or rectangle, otherwise false
   * @example
   * if (rect.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (rect.contains(myVector2d)) {
   *   // do something
   * }
   * if (rect.contains(myRect)) {
   *   // do something
   * }
   */
  contains() {
    let arg0 = arguments[0];
    let _x, _y;
    if (arguments.length === 2) {
      _x = arg0;
      _y = arguments[1];
    } else {
      if (typeof arg0.radius === "undefined" && typeof arg0.bottom === "number") {
        return super.contains(arg0);
      } else {
        _x = arg0.x;
        _y = arg0.y;
      }
    }
    if (_x < this.left || _x >= this.right || _y < this.top || _y >= this.bottom) {
      return false;
    }
    if (_x >= this.left + this.radius && _x <= this.right - this.radius || _y >= this.top + this.radius && _y <= this.bottom - this.radius) {
      return true;
    }
    let tx, ty;
    const radiusX = Math.max(0, Math.min(this.radius, this.width / 2));
    const radiusY = Math.max(0, Math.min(this.radius, this.height / 2));
    if (_x < this.left + radiusX && _y < this.top + radiusY) {
      tx = _x - this.left - radiusX;
      ty = _y - this.top - radiusY;
    } else if (_x > this.right - radiusX && _y < this.top + radiusY) {
      tx = _x - this.right + radiusX;
      ty = _y - this.top - radiusY;
    } else if (_x > this.right - radiusX && _y > this.bottom - radiusY) {
      tx = _x - this.right + radiusX;
      ty = _y - this.bottom + radiusY;
    } else if (_x < this.left + radiusX && _y > this.bottom - radiusY) {
      tx = _x - this.left - radiusX;
      ty = _y - this.bottom + radiusY;
    } else {
      return false;
    }
    return tx * tx + ty * ty <= radiusX * radiusY;
  }
  /**
   * check if this RoundRect is identical to the specified one
   * @param {RoundRect} rrect
   * @returns {boolean} true if equals
   */
  equals(rrect) {
    return super.equals(rrect) && this.radius === rrect.radius;
  }
  /**
   * clone this RoundRect
   * @returns {RoundRect} new RoundRect
   */
  clone() {
    return new _RoundRect(this.pos.x, this.pos.y, this.width, this.height, this.radius);
  }
};
function remove(arr, obj) {
  let i = Array.prototype.indexOf.call(arr, obj);
  if (i !== -1) {
    Array.prototype.splice.call(arr, i, 1);
  }
  return arr;
}
function random(arr) {
  return arr[random$1(0, arr.length)];
}
function weightedRandom(arr) {
  return arr[weightedRandom$1(0, arr.length)];
}
var array$1 = {
  __proto__: null,
  random,
  remove,
  weightedRandom
};
var QT_ARRAY = [];
function QT_ARRAY_POP(world, bounds, max_objects = 4, max_levels = 4, level2 = 0) {
  if (QT_ARRAY.length > 0) {
    let _qt = QT_ARRAY.pop();
    _qt.world = world;
    _qt.bounds = bounds;
    _qt.max_objects = max_objects;
    _qt.max_levels = max_levels;
    _qt.level = level2;
    return _qt;
  } else {
    return new QuadTree(world, bounds, max_objects, max_levels, level2);
  }
}
function QT_ARRAY_PUSH(qt) {
  QT_ARRAY.push(qt);
}
var QT_VECTOR = new Vector2d();
var QuadTree = class {
  /**
   * @param {World} world - the physic world this QuadTree belongs to
   * @param {Bounds} bounds - bounds of the node
   * @param {number} [max_objects=4] - max objects a node can hold before splitting into 4 subnodes
   * @param {number} [max_levels=4] - total max levels inside root Quadtree
   * @param {number} [level] - deepth level, required for subnodes
   */
  constructor(world, bounds, max_objects = 4, max_levels = 4, level2 = 0) {
    this.world = world;
    this.bounds = bounds;
    this.max_objects = max_objects;
    this.max_levels = max_levels;
    this.level = level2;
    this.objects = [];
    this.nodes = [];
  }
  /*
   * Split the node into 4 subnodes
   */
  split() {
    let nextLevel = this.level + 1, subWidth = this.bounds.width / 2, subHeight = this.bounds.height / 2, left = this.bounds.left, top = this.bounds.top;
    this.nodes[0] = QT_ARRAY_POP(
      this.world,
      {
        left: left + subWidth,
        top,
        width: subWidth,
        height: subHeight
      },
      this.max_objects,
      this.max_levels,
      nextLevel
    );
    this.nodes[1] = QT_ARRAY_POP(
      this.world,
      {
        left,
        top,
        width: subWidth,
        height: subHeight
      },
      this.max_objects,
      this.max_levels,
      nextLevel
    );
    this.nodes[2] = QT_ARRAY_POP(
      this.world,
      {
        left,
        top: top + subHeight,
        width: subWidth,
        height: subHeight
      },
      this.max_objects,
      this.max_levels,
      nextLevel
    );
    this.nodes[3] = QT_ARRAY_POP(
      this.world,
      {
        left: left + subWidth,
        top: top + subHeight,
        width: subWidth,
        height: subHeight
      },
      this.max_objects,
      this.max_levels,
      nextLevel
    );
  }
  /*
   * Determine which node the object belongs to
   * @param {Rect} rect bounds of the area to be checked
   * @returns Integer index of the subnode (0-3), or -1 if rect cannot completely fit within a subnode and is part of the parent node
   */
  getIndex(item) {
    let pos;
    let bounds = item.getBounds();
    if (item.isFloating === true) {
      pos = this.world.app.viewport.localToWorld(bounds.left, bounds.top, QT_VECTOR);
    } else {
      pos = QT_VECTOR.set(item.left, item.top);
    }
    let index2 = -1, rx = pos.x, ry = pos.y, rw = bounds.width, rh = bounds.height, verticalMidpoint = this.bounds.left + this.bounds.width / 2, horizontalMidpoint = this.bounds.top + this.bounds.height / 2, topQuadrant = ry < horizontalMidpoint && ry + rh < horizontalMidpoint, bottomQuadrant = ry > horizontalMidpoint;
    if (rx < verticalMidpoint && rx + rw < verticalMidpoint) {
      if (topQuadrant) {
        index2 = 1;
      } else if (bottomQuadrant) {
        index2 = 2;
      }
    } else if (rx > verticalMidpoint) {
      if (topQuadrant) {
        index2 = 0;
      } else if (bottomQuadrant) {
        index2 = 3;
      }
    }
    return index2;
  }
  /**
   * Insert the given object container into the node.
   * @name insertContainer
   * @memberof QuadTree
   * @param {Container} container - group of objects to be added
   */
  insertContainer(container) {
    const children = container.children;
    const childrenLength = children.length;
    for (let i = childrenLength, child; i--, child = children[i]; ) {
      if (child.isKinematic !== true) {
        if (typeof child.addChild === "function") {
          if (child.name !== "rootContainer") {
            this.insert(child);
          }
          this.insertContainer(child);
        } else {
          if (typeof child.getBounds === "function") {
            this.insert(child);
          }
        }
      }
    }
  }
  /**
   * Insert the given object into the node. If the node
   * exceeds the capacity, it will split and add all
   * objects to their corresponding subnodes.
   * @name insert
   * @memberof QuadTree
   * @param {object} item - object to be added
   */
  insert(item) {
    let index2 = -1;
    if (this.nodes.length > 0) {
      index2 = this.getIndex(item);
      if (index2 !== -1) {
        this.nodes[index2].insert(item);
        return;
      }
    }
    this.objects.push(item);
    if (this.objects.length > this.max_objects && this.level < this.max_levels) {
      if (this.nodes.length === 0) {
        this.split();
      }
      let i = 0;
      while (i < this.objects.length) {
        index2 = this.getIndex(this.objects[i]);
        if (index2 !== -1) {
          this.nodes[index2].insert(this.objects.splice(i, 1)[0]);
        } else {
          i = i + 1;
        }
      }
    }
  }
  /**
   * Return all objects that could collide with the given object
   * @name retrieve
   * @memberof QuadTree
   * @param {object} item - object to be checked against
   * @param {object} [fn] - a sorting function for the returned array
   * @returns {object[]} array with all detected objects
   */
  retrieve(item, fn) {
    let returnObjects = this.objects;
    if (this.nodes.length > 0) {
      let index2 = this.getIndex(item);
      if (index2 !== -1) {
        returnObjects = returnObjects.concat(this.nodes[index2].retrieve(item));
      } else {
        for (let i = 0; i < this.nodes.length; i = i + 1) {
          returnObjects = returnObjects.concat(this.nodes[i].retrieve(item));
        }
      }
    }
    if (typeof fn === "function") {
      returnObjects.sort(fn);
    }
    return returnObjects;
  }
  /**
   * Remove the given item from the quadtree.
   * (this function won't recalculate the impacted node)
   * @name remove
   * @memberof QuadTree
   * @param {object} item - object to be removed
   * @returns {boolean} true if the item was found and removed.
   */
  remove(item) {
    let found = false;
    if (typeof item.getBounds === "undefined") {
      return false;
    }
    if (this.nodes.length > 0) {
      let index2 = this.getIndex(item);
      if (index2 !== -1) {
        found = remove(this.nodes[index2], item);
        if (found && this.nodes[index2].isPrunable()) {
          this.nodes.splice(index2, 1);
        }
      }
    }
    if (found === false) {
      if (this.objects.indexOf(item) !== -1) {
        remove(this.objects, item);
        found = true;
      }
    }
    return found;
  }
  /**
   * return true if the node is prunable
   * @name isPrunable
   * @memberof QuadTree
   * @returns {boolean} true if the node is prunable
   */
  isPrunable() {
    return !(this.hasChildren() || this.objects.length > 0);
  }
  /**
   * return true if the node has any children
   * @name hasChildren
   * @memberof QuadTree
   * @returns {boolean} true if the node has any children
   */
  hasChildren() {
    for (let i = 0; i < this.nodes.length; i = i + 1) {
      const subnode = this.nodes[i];
      if (subnode.length > 0 || subnode.objects.length > 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * clear the quadtree
   * @name clear
   * @memberof QuadTree
   * @param {Bounds} [bounds=this.bounds] - the bounds to be cleared
   */
  clear(bounds) {
    this.objects.length = 0;
    for (let i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
      QT_ARRAY_PUSH(this.nodes[i]);
    }
    this.nodes.length = 0;
    if (typeof bounds !== "undefined") {
      this.bounds.setMinMax(bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y);
    }
  }
};
var Bounds = class _Bounds {
  /**
   * @param {Vector2d[]|Point[]} [vertices] - an array of Vector2d or Point
   */
  constructor(vertices) {
    this._center = new Vector2d();
    this.onResetEvent(vertices);
    this.type = "Bounds";
  }
  /**
   * @ignore
   */
  onResetEvent(vertices) {
    if (typeof this.min === "undefined") {
      this.min = { x: Infinity, y: Infinity };
      this.max = { x: -Infinity, y: -Infinity };
    } else {
      this.clear();
    }
    if (typeof vertices !== "undefined") {
      this.update(vertices);
    }
  }
  /**
   * reset the bound
   */
  clear() {
    this.setMinMax(Infinity, Infinity, -Infinity, -Infinity);
  }
  /**
   * sets the bounds to the given min and max value
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   */
  setMinMax(minX, minY, maxX, maxY) {
    this.min.x = minX;
    this.min.y = minY;
    this.max.x = maxX;
    this.max.y = maxY;
  }
  /**
   * x position of the bound
   * @type {number}
   */
  get x() {
    return this.min.x;
  }
  set x(value) {
    let deltaX = this.max.x - this.min.x;
    this.min.x = value;
    this.max.x = value + deltaX;
  }
  /**
   * y position of the bounds
   * @type {number}
   */
  get y() {
    return this.min.y;
  }
  set y(value) {
    let deltaY = this.max.y - this.min.y;
    this.min.y = value;
    this.max.y = value + deltaY;
  }
  /**
   * width of the bounds
   * @type {number}
   */
  get width() {
    return this.max.x - this.min.x;
  }
  set width(value) {
    this.max.x = this.min.x + value;
  }
  /**
   * width of the bounds
   * @type {number}
   */
  get height() {
    return this.max.y - this.min.y;
  }
  set height(value) {
    this.max.y = this.min.y + value;
  }
  /**
   * left coordinate of the bound
   * @type {number}
   */
  get left() {
    return this.min.x;
  }
  /**
   * right coordinate of the bound
   * @type {number}
   */
  get right() {
    return this.max.x;
  }
  /**
   * top coordinate of the bound
   * @type {number}
   */
  get top() {
    return this.min.y;
  }
  /**
   * bottom coordinate of the bound
   * @type {number}
   */
  get bottom() {
    return this.max.y;
  }
  /**
   * center position of the bound on the x axis
   * @type {number}
   */
  get centerX() {
    return this.min.x + this.width / 2;
  }
  /**
   * center position of the bound on the y axis
   * @type {number}
   */
  get centerY() {
    return this.min.y + this.height / 2;
  }
  /**
   * return the center position of the bound
   * @type {Vector2d}
   */
  get center() {
    return this._center.set(this.centerX, this.centerY);
  }
  /**
   * center the bounds position around the given coordinates
   * @param {number} x - the x coordinate around which to center this bounds
   * @param {number} y - the y coordinate around which to center this bounds
   */
  centerOn(x, y) {
    this.shift(x - this.width / 2, y - this.height / 2);
    return this;
  }
  /**
   * Updates bounds using the given vertices
   * @param {Vector2d[]|Point[]} vertices - an array of Vector2d or Point
   */
  update(vertices) {
    this.add(vertices, true);
  }
  /**
   * add the given vertices to the bounds definition.
   * @param {Vector2d[]|Point[]} vertices - an array of Vector2d or Point
   * @param {boolean} [clear=false] - either to reset the bounds before adding the new vertices
   */
  add(vertices, clear = false) {
    const verticeCount = vertices.length;
    if (clear === true) {
      this.clear();
    }
    for (let i = 0; i < verticeCount; i++) {
      const vertex = vertices[i];
      if (vertex.x > this.max.x) this.max.x = vertex.x;
      if (vertex.x < this.min.x) this.min.x = vertex.x;
      if (vertex.y > this.max.y) this.max.y = vertex.y;
      if (vertex.y < this.min.y) this.min.y = vertex.y;
    }
  }
  /**
   * add the given bounds to the bounds definition.
   * @param {Bounds} bounds
   * @param {boolean} [clear=false] - either to reset the bounds before adding the new vertices
   */
  addBounds(bounds, clear = false) {
    if (clear === true) {
      this.max.x = bounds.max.x;
      this.min.x = bounds.min.x;
      this.max.y = bounds.max.y;
      this.min.y = bounds.min.y;
    } else {
      if (bounds.max.x > this.max.x) this.max.x = bounds.max.x;
      if (bounds.min.x < this.min.x) this.min.x = bounds.min.x;
      if (bounds.max.y > this.max.y) this.max.y = bounds.max.y;
      if (bounds.min.y < this.min.y) this.min.y = bounds.min.y;
    }
  }
  /**
   * add the given point to the bounds definition.
   * @param {Vector2d|Point} point - the vector or point to be added to the bounds
   * @param {Matrix2d} [m] - an optional transform to apply to the given point (if the given point is a Vector2d)
   */
  addPoint(point, m) {
    if (typeof m !== "undefined") {
      point = m.apply(point);
    }
    this.min.x = Math.min(this.min.x, point.x);
    this.max.x = Math.max(this.max.x, point.x);
    this.min.y = Math.min(this.min.y, point.y);
    this.max.y = Math.max(this.max.y, point.y);
  }
  /**
   * add the given quad coordinates to this bound definition, multiplied by the given matrix
   * @param {number} x0 - left X coordinates of the quad
   * @param {number} y0 - top Y coordinates of the quad
   * @param {number} x1 - right X coordinates of the quad
   * @param {number} y1 - bottom y coordinates of the quad
   * @param {Matrix2d} [m] - an optional transform to apply to the given frame coordinates
   */
  addFrame(x0, y0, x1, y1, m) {
    let v = pool.pull("Point");
    this.addPoint(v.set(x0, y0), m);
    this.addPoint(v.set(x1, y0), m);
    this.addPoint(v.set(x0, y1), m);
    this.addPoint(v.set(x1, y1), m);
    pool.push(v);
  }
  /**
   * Returns true if the bounds contains the given point.
   * @param {number|Vector2d} x -  x coordinate or a vector point to check
   * @param {number} [y] - y coordinate
   * @returns {boolean} True if the bounds contain the point, otherwise false
   * @example
   * if (bounds.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (bounds.contains(myVector2d)) {
   *   // do something
   * }
   */
  contains() {
    let arg0 = arguments[0];
    let _x1, _x2, _y1, _y2;
    if (arguments.length === 2) {
      _x1 = _x2 = arg0;
      _y1 = _y2 = arguments[1];
    } else {
      if (typeof arg0.max !== "undefined") {
        _x1 = arg0.min.x;
        _x2 = arg0.max.x;
        _y1 = arg0.min.y;
        _y2 = arg0.max.y;
      } else {
        _x1 = _x2 = arg0.x;
        _y1 = _y2 = arg0.y;
      }
    }
    return _x1 >= this.min.x && _x2 <= this.max.x && _y1 >= this.min.y && _y2 <= this.max.y;
  }
  /**
   * Returns true if the two bounds intersect.
   * @param {Bounds|Rect} bounds
   * @returns {boolean} True if the bounds overlap, otherwise false
   */
  overlaps(bounds) {
    return !(this.right < bounds.left || this.left > bounds.right || this.bottom < bounds.top || this.top > bounds.bottom);
  }
  /**
   * determines whether all coordinates of this bounds are finite numbers.
   * @returns {boolean} false if all coordinates are positive or negative Infinity or NaN; otherwise, true.
   */
  isFinite() {
    return isFinite(this.min.x) && isFinite(this.max.x) && isFinite(this.min.y) && isFinite(this.max.y);
  }
  /**
   * Translates the bounds by the given point
   * @param {number|Vector2d} x -  x coordinate or a vector point to translate by
   * @param {number} [y]
   * @example
   * bounds.translate(10, 10);
   * // or
   * bounds.translate(myVector2d);
   */
  translate() {
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    this.min.x += _x;
    this.max.x += _x;
    this.min.y += _y;
    this.max.y += _y;
  }
  /**
   * Shifts the bounds to the given x, y position.
   * @param {number|Vector2d} x -  x coordinate or a vector point to shift to
   * @param {number} [y]
   * @example
   * bounds.shift(10, 10);
   * // or
   * bounds.shift(myVector2d);
   */
  shift() {
    let _x, _y;
    if (arguments.length === 2) {
      _x = arguments[0];
      _y = arguments[1];
    } else {
      _x = arguments[0].x;
      _y = arguments[0].y;
    }
    let deltaX = this.max.x - this.min.x, deltaY = this.max.y - this.min.y;
    this.min.x = _x;
    this.max.x = _x + deltaX;
    this.min.y = _y;
    this.max.y = _y + deltaY;
  }
  /**
   * clone this bounds
   * @returns {Bounds}
   */
  clone() {
    let bounds = new _Bounds();
    bounds.addBounds(this);
    return bounds;
  }
  /**
   * Returns a polygon whose edges are the same as this bounds.
   * @returns {Polygon} a new Polygon that represents this bounds.
   */
  toPolygon() {
    return pool.pull("Polygon", this.x, this.y, [
      pool.pull("Vector2d", 0, 0),
      pool.pull("Vector2d", this.width, 0),
      pool.pull("Vector2d", this.width, this.height),
      pool.pull("Vector2d", 0, this.height)
    ]);
  }
};
var collision = {
  /**
    * The maximum number of children that a quadtree node can contain before it is split into sub-nodes.
    * @name maxChildren
    * @memberof collision
    * @public
    * @type {number}
    * @default 8
    * @see game.world.broadphase
    */
  maxChildren: 8,
  /**
    * The maximum number of levels that the quadtree will create.
    * @name maxDepth
    * @memberof collision
    * @public
    * @type {number}
    * @default 4
    * @see game.world.broadphase
    */
  maxDepth: 4,
  /**
   * Enum for collision type values.
   * @property {number} NO_OBJECT to disable collision check
   * @property {number} PLAYER_OBJECT playbable characters
   * @property {number} NPC_OBJECT non playable characters
   * @property {number} ENEMY_OBJECT enemies objects
   * @property {number} COLLECTABLE_OBJECT collectable objects
   * @property {number} ACTION_OBJECT e.g. doors
   * @property {number} PROJECTILE_OBJECT e.g. missiles
   * @property {number} WORLD_SHAPE e.g. walls; for map collision shapes
   * @property {number} USER user-defined collision types (see example)
   * @property {number} ALL_OBJECT all of the above (including user-defined types)
   * @readonly
   * @enum {number}
   * @name types
   * @memberof collision
   * @see Body.setCollisionMask
   * @see Body.collisionType
   * @example
   * // set the body collision type
   * myEntity.body.collisionType = me.collision.types.PLAYER_OBJECT;
   *
   * // filter collision detection with collision shapes, enemies and collectables
   * myEntity.body.setCollisionMask(
   *     me.collision.types.WORLD_SHAPE |
   *     me.collision.types.ENEMY_OBJECT |
   *     me.collision.types.COLLECTABLE_OBJECT
   * );
   *
   * // User-defined collision types are defined using BITWISE LEFT-SHIFT:
   * game.collisionTypes = {
   *     LOCKED_DOOR : me.collision.types.USER << 0,
   *     OPEN_DOOR   : me.collision.types.USER << 1,
   *     LOOT        : me.collision.types.USER << 2,
   * };
   *
   * // Set collision type for a door entity
   * myDoorEntity.body.collisionType = game.collisionTypes.LOCKED_DOOR;
   *
   * // Set collision mask for the player entity, so it collides with locked doors and loot
   * myPlayerEntity.body.setCollisionMask(
   *     me.collision.types.ENEMY_OBJECT |
   *     me.collision.types.WORLD_SHAPE |
   *     game.collisionTypes.LOCKED_DOOR |
   *     game.collisionTypes.LOOT
   * );
   */
  types: {
    /** to disable collision check */
    NO_OBJECT: 0,
    PLAYER_OBJECT: 1 << 0,
    NPC_OBJECT: 1 << 1,
    ENEMY_OBJECT: 1 << 2,
    COLLECTABLE_OBJECT: 1 << 3,
    ACTION_OBJECT: 1 << 4,
    // door, etc...
    PROJECTILE_OBJECT: 1 << 5,
    // missiles, etc...
    WORLD_SHAPE: 1 << 6,
    // walls, etc...
    USER: 1 << 7,
    // user-defined types start here...
    ALL_OBJECT: 4294967295
    // all objects
  },
  /**
   * Checks for object colliding with the given line
   * @name rayCast
   * @memberof collision
   * @public
   * @param {Line} line - line to be tested for collision
   * @param {Array.<Renderable>} [result] - a user defined array that will be populated with intersecting physic objects.
   * @returns {Array.<Renderable>} an array of intersecting physic objects
   * @example
   *    // define a line accross the viewport
   *    let ray = new me.Line(
   *        // absolute position of the line
   *        0, 0, [
   *        // starting point relative to the initial position
   *        new me.Vector2d(0, 0),
   *        // ending point
   *        new me.Vector2d(me.game.viewport.width, me.game.viewport.height)
   *    ]);
   *
   *    // check for collition
   *    result = me.collision.rayCast(ray);
   *
   *    if (result.length > 0) {
   *        // ...
   *    }
   */
  rayCast(line, result) {
    return game.world.detector.rayCast(line, result);
  }
};
function defer(func, thisArg, ...args) {
  return setTimeout(func.bind(thisArg), 0.01, ...args);
}
function throttle(fn, delay, no_trailing) {
  let last = globalThis.performance.now(), deferTimer;
  if (typeof no_trailing !== "boolean") {
    no_trailing = false;
  }
  return function() {
    let now = globalThis.performance.now();
    let elasped = now - last;
    let args = arguments;
    if (elasped < delay) {
      if (no_trailing === false) {
        clearTimeout(deferTimer);
        deferTimer = setTimeout(() => {
          last = now;
          return fn.apply(null, args);
        }, elasped);
      }
    } else {
      last = now;
      return fn.apply(null, args);
    }
  };
}
var _function = {
  __proto__: null,
  defer,
  throttle
};
var eventemitter3$1 = { exports: {} };
var eventemitter3 = eventemitter3$1.exports;
(function(module) {
  "use strict";
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once2) {
    this.fn = fn;
    this.context = context;
    this.once = once2 || false;
  }
  function addListener(emitter, event2, fn, context, once2) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event2 : event2;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event2) {
    var evt = prefix ? prefix + event2 : event2, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event2) {
    var evt = prefix ? prefix + event2 : event2, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit2(event2, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event2 : event2;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event2, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event2, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event2, fn, context) {
    return addListener(this, event2, fn, context, false);
  };
  EventEmitter2.prototype.once = function once2(event2, fn, context) {
    return addListener(this, event2, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event2, fn, context, once2) {
    var evt = prefix ? prefix + event2 : event2;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event2) {
    var evt;
    if (event2) {
      evt = prefix ? prefix + event2 : event2;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  if (true) {
    module.exports = EventEmitter2;
  }
})(eventemitter3$1);
var eventemitter3Exports = eventemitter3$1.exports;
var EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
var eventEmitter = new EventEmitter();
var DOM_READY = "dom_ready";
var BOOT = "me.boot";
var TICK = "me.tick";
var BLUR = "me.blur";
var FOCUS = "me.focus";
var STATE_PAUSE = "me.state.onPause";
var STATE_RESUME = "me.state.onResume";
var STATE_STOP = "me.state.onStop";
var STATE_RESTART = "me.state.onRestart";
var STATE_CHANGE = "me.state.onChange";
var STAGE_RESET = "me.stage.onReset";
var VIDEO_INIT = "me.video.onInit";
var GAME_INIT = "me.game.onInit";
var GAME_RESET = "me.game.onReset";
var GAME_BEFORE_UPDATE = "me.game.beforeUpdate";
var GAME_AFTER_UPDATE = "me.game.afterUpdate";
var GAME_UPDATE = "me.game.onUpdate";
var GAME_BEFORE_DRAW = "me.game.beforeDraw";
var GAME_AFTER_DRAW = "me.game.afterDraw";
var WORLD_STEP = "me.world.step";
var LEVEL_LOADED = "me.game.onLevelLoaded";
var LOADER_COMPLETE = "me.loader.onload";
var LOADER_PROGRESS = "me.loader.onProgress";
var LOADER_ERROR = "me.loader.onError";
var KEYDOWN = "me.input.keydown";
var KEYUP = "me.input.keyup";
var GAMEPAD_CONNECTED = "gamepad.connected";
var GAMEPAD_DISCONNECTED = "gamepad.disconnected";
var GAMEPAD_UPDATE = "gamepad.update";
var POINTERMOVE = "me.event.pointermove";
var POINTERLOCKCHANGE = "me.event.pointerlockChange";
var DRAGSTART = "me.game.dragstart";
var DRAGEND = "me.game.dragend";
var WINDOW_ONRESIZE = "globalThis.onresize";
var CANVAS_ONRESIZE = "canvas.onresize";
var VIEWPORT_ONRESIZE = "viewport.onresize";
var WINDOW_ONORIENTATION_CHANGE = "globalThis.orientationchange";
var WINDOW_ONSCROLL = "globalThis.onscroll";
var VIEWPORT_ONCHANGE = "viewport.onchange";
var ONCONTEXT_LOST = "renderer.contextlost";
var ONCONTEXT_RESTORED = "renderer.contextrestored";
function emit(eventName, ...args) {
  return eventEmitter.emit(eventName, ...args);
}
function on(eventName, listener, context) {
  return eventEmitter.on(eventName, listener, context);
}
function once(eventName, listener, context) {
  return eventEmitter.once(eventName, listener, context);
}
function off(eventName, listener) {
  return eventEmitter.off(eventName, listener);
}
var event = {
  __proto__: null,
  BLUR,
  BOOT,
  CANVAS_ONRESIZE,
  DOM_READY,
  DRAGEND,
  DRAGSTART,
  FOCUS,
  GAMEPAD_CONNECTED,
  GAMEPAD_DISCONNECTED,
  GAMEPAD_UPDATE,
  GAME_AFTER_DRAW,
  GAME_AFTER_UPDATE,
  GAME_BEFORE_DRAW,
  GAME_BEFORE_UPDATE,
  GAME_INIT,
  GAME_RESET,
  GAME_UPDATE,
  KEYDOWN,
  KEYUP,
  LEVEL_LOADED,
  LOADER_COMPLETE,
  LOADER_ERROR,
  LOADER_PROGRESS,
  ONCONTEXT_LOST,
  ONCONTEXT_RESTORED,
  POINTERLOCKCHANGE,
  POINTERMOVE,
  STAGE_RESET,
  STATE_CHANGE,
  STATE_PAUSE,
  STATE_RESTART,
  STATE_RESUME,
  STATE_STOP,
  TICK,
  VIDEO_INIT,
  VIEWPORT_ONCHANGE,
  VIEWPORT_ONRESIZE,
  WINDOW_ONORIENTATION_CHANGE,
  WINDOW_ONRESIZE,
  WINDOW_ONSCROLL,
  WORLD_STEP,
  emit,
  off,
  on,
  once
};
var howler$1 = {};
(function(exports) {
  (function() {
    "use strict";
    var HowlerGlobal2 = function() {
      this.init();
    };
    HowlerGlobal2.prototype = {
      /**
       * Initialize the global Howler object.
       * @return {Howler}
       */
      init: function() {
        var self2 = this || Howler2;
        self2._counter = 1e3;
        self2._html5AudioPool = [];
        self2.html5PoolSize = 10;
        self2._codecs = {};
        self2._howls = [];
        self2._muted = false;
        self2._volume = 1;
        self2._canPlayEvent = "canplaythrough";
        self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
        self2.masterGain = null;
        self2.noAudio = false;
        self2.usingWebAudio = true;
        self2.autoSuspend = true;
        self2.ctx = null;
        self2.autoUnlock = true;
        self2._setup();
        return self2;
      },
      /**
       * Get/set the global volume for all sounds.
       * @param  {Float} vol Volume from 0.0 to 1.0.
       * @return {Howler/Float}     Returns self or current volume.
       */
      volume: function(vol) {
        var self2 = this || Howler2;
        vol = parseFloat(vol);
        if (!self2.ctx) {
          setupAudioContext();
        }
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          self2._volume = vol;
          if (self2._muted) {
            return self2;
          }
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (!self2._howls[i]._webAudio) {
              var ids = self2._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound2 = self2._howls[i]._soundById(ids[j]);
                if (sound2 && sound2._node) {
                  sound2._node.volume = sound2._volume * vol;
                }
              }
            }
          }
          return self2;
        }
        return self2._volume;
      },
      /**
       * Handle muting and unmuting globally.
       * @param  {Boolean} muted Is muted or not.
       */
      mute: function(muted2) {
        var self2 = this || Howler2;
        if (!self2.ctx) {
          setupAudioContext();
        }
        self2._muted = muted2;
        if (self2.usingWebAudio) {
          self2.masterGain.gain.setValueAtTime(muted2 ? 0 : self2._volume, Howler2.ctx.currentTime);
        }
        for (var i = 0; i < self2._howls.length; i++) {
          if (!self2._howls[i]._webAudio) {
            var ids = self2._howls[i]._getSoundIds();
            for (var j = 0; j < ids.length; j++) {
              var sound2 = self2._howls[i]._soundById(ids[j]);
              if (sound2 && sound2._node) {
                sound2._node.muted = muted2 ? true : sound2._muted;
              }
            }
          }
        }
        return self2;
      },
      /**
       * Handle stopping all sounds globally.
       */
      stop: function() {
        var self2 = this || Howler2;
        for (var i = 0; i < self2._howls.length; i++) {
          self2._howls[i].stop();
        }
        return self2;
      },
      /**
       * Unload and destroy all currently loaded Howl objects.
       * @return {Howler}
       */
      unload: function() {
        var self2 = this || Howler2;
        for (var i = self2._howls.length - 1; i >= 0; i--) {
          self2._howls[i].unload();
        }
        if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
          self2.ctx.close();
          self2.ctx = null;
          setupAudioContext();
        }
        return self2;
      },
      /**
       * Check for codec support of specific extension.
       * @param  {String} ext Audio file extention.
       * @return {Boolean}
       */
      codecs: function(ext) {
        return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
      },
      /**
       * Setup various state values for global tracking.
       * @return {Howler}
       */
      _setup: function() {
        var self2 = this || Howler2;
        self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
        self2._autoSuspend();
        if (!self2.usingWebAudio) {
          if (typeof Audio !== "undefined") {
            try {
              var test2 = new Audio();
              if (typeof test2.oncanplaythrough === "undefined") {
                self2._canPlayEvent = "canplay";
              }
            } catch (e) {
              self2.noAudio = true;
            }
          } else {
            self2.noAudio = true;
          }
        }
        try {
          var test2 = new Audio();
          if (test2.muted) {
            self2.noAudio = true;
          }
        } catch (e) {
        }
        if (!self2.noAudio) {
          self2._setupCodecs();
        }
        return self2;
      },
      /**
       * Check for browser support for various codecs and cache the results.
       * @return {Howler}
       */
      _setupCodecs: function() {
        var self2 = this || Howler2;
        var audioTest = null;
        try {
          audioTest = typeof Audio !== "undefined" ? new Audio() : null;
        } catch (err) {
          return self2;
        }
        if (!audioTest || typeof audioTest.canPlayType !== "function") {
          return self2;
        }
        var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
        var ua2 = self2._navigator ? self2._navigator.userAgent : "";
        var checkOpera = ua2.match(/OPR\/(\d+)/g);
        var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
        var checkSafari = ua2.indexOf("Safari") !== -1 && ua2.indexOf("Chrome") === -1;
        var safariVersion = ua2.match(/Version\/(.*?) /);
        var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
        self2._codecs = {
          mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
          mpeg: !!mpegTest,
          opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
          ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
          aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
          caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
          m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
          flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
        };
        return self2;
      },
      /**
       * Some browsers/devices will only allow audio to be played after a user interaction.
       * Attempt to automatically unlock audio on the first user interaction.
       * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
       * @return {Howler}
       */
      _unlockAudio: function() {
        var self2 = this || Howler2;
        if (self2._audioUnlocked || !self2.ctx) {
          return;
        }
        self2._audioUnlocked = false;
        self2.autoUnlock = false;
        if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
          self2._mobileUnloaded = true;
          self2.unload();
        }
        self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
        var unlock = function(e) {
          while (self2._html5AudioPool.length < self2.html5PoolSize) {
            try {
              var audioNode = new Audio();
              audioNode._unlocked = true;
              self2._releaseHtml5Audio(audioNode);
            } catch (e2) {
              self2.noAudio = true;
              break;
            }
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (!self2._howls[i]._webAudio) {
              var ids = self2._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound2 = self2._howls[i]._soundById(ids[j]);
                if (sound2 && sound2._node && !sound2._node._unlocked) {
                  sound2._node._unlocked = true;
                  sound2._node.load();
                }
              }
            }
          }
          self2._autoResume();
          var source = self2.ctx.createBufferSource();
          source.buffer = self2._scratchBuffer;
          source.connect(self2.ctx.destination);
          if (typeof source.start === "undefined") {
            source.noteOn(0);
          } else {
            source.start(0);
          }
          if (typeof self2.ctx.resume === "function") {
            self2.ctx.resume();
          }
          source.onended = function() {
            source.disconnect(0);
            self2._audioUnlocked = true;
            document.removeEventListener("touchstart", unlock, true);
            document.removeEventListener("touchend", unlock, true);
            document.removeEventListener("click", unlock, true);
            document.removeEventListener("keydown", unlock, true);
            for (var i2 = 0; i2 < self2._howls.length; i2++) {
              self2._howls[i2]._emit("unlock");
            }
          };
        };
        document.addEventListener("touchstart", unlock, true);
        document.addEventListener("touchend", unlock, true);
        document.addEventListener("click", unlock, true);
        document.addEventListener("keydown", unlock, true);
        return self2;
      },
      /**
       * Get an unlocked HTML5 Audio object from the pool. If none are left,
       * return a new Audio object and throw a warning.
       * @return {Audio} HTML5 Audio object.
       */
      _obtainHtml5Audio: function() {
        var self2 = this || Howler2;
        if (self2._html5AudioPool.length) {
          return self2._html5AudioPool.pop();
        }
        var testPlay = new Audio().play();
        if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
          testPlay.catch(function() {
            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
          });
        }
        return new Audio();
      },
      /**
       * Return an activated HTML5 Audio object to the pool.
       * @return {Howler}
       */
      _releaseHtml5Audio: function(audio2) {
        var self2 = this || Howler2;
        if (audio2._unlocked) {
          self2._html5AudioPool.push(audio2);
        }
        return self2;
      },
      /**
       * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
       * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
       * @return {Howler}
       */
      _autoSuspend: function() {
        var self2 = this;
        if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        for (var i = 0; i < self2._howls.length; i++) {
          if (self2._howls[i]._webAudio) {
            for (var j = 0; j < self2._howls[i]._sounds.length; j++) {
              if (!self2._howls[i]._sounds[j]._paused) {
                return self2;
              }
            }
          }
        }
        if (self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
        }
        self2._suspendTimer = setTimeout(function() {
          if (!self2.autoSuspend) {
            return;
          }
          self2._suspendTimer = null;
          self2.state = "suspending";
          var handleSuspension = function() {
            self2.state = "suspended";
            if (self2._resumeAfterSuspend) {
              delete self2._resumeAfterSuspend;
              self2._autoResume();
            }
          };
          self2.ctx.suspend().then(handleSuspension, handleSuspension);
        }, 3e4);
        return self2;
      },
      /**
       * Automatically resume the Web Audio AudioContext when a new sound is played.
       * @return {Howler}
       */
      _autoResume: function() {
        var self2 = this;
        if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
          self2._suspendTimer = null;
        } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
          self2.ctx.resume().then(function() {
            self2.state = "running";
            for (var i = 0; i < self2._howls.length; i++) {
              self2._howls[i]._emit("resume");
            }
          });
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          }
        } else if (self2.state === "suspending") {
          self2._resumeAfterSuspend = true;
        }
        return self2;
      }
    };
    var Howler2 = new HowlerGlobal2();
    var Howl2 = function(o) {
      var self2 = this;
      if (!o.src || o.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      self2.init(o);
    };
    Howl2.prototype = {
      /**
       * Initialize a new Howl group object.
       * @param  {Object} o Passed in properties for this group.
       * @return {Howl}
       */
      init: function(o) {
        var self2 = this;
        if (!Howler2.ctx) {
          setupAudioContext();
        }
        self2._autoplay = o.autoplay || false;
        self2._format = typeof o.format !== "string" ? o.format : [o.format];
        self2._html5 = o.html5 || false;
        self2._muted = o.mute || false;
        self2._loop = o.loop || false;
        self2._pool = o.pool || 5;
        self2._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
        self2._rate = o.rate || 1;
        self2._sprite = o.sprite || {};
        self2._src = typeof o.src !== "string" ? o.src : [o.src];
        self2._volume = o.volume !== void 0 ? o.volume : 1;
        self2._xhr = {
          method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
          headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
          withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
        };
        self2._duration = 0;
        self2._state = "unloaded";
        self2._sounds = [];
        self2._endTimers = {};
        self2._queue = [];
        self2._playLock = false;
        self2._onend = o.onend ? [{ fn: o.onend }] : [];
        self2._onfade = o.onfade ? [{ fn: o.onfade }] : [];
        self2._onload = o.onload ? [{ fn: o.onload }] : [];
        self2._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
        self2._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
        self2._onpause = o.onpause ? [{ fn: o.onpause }] : [];
        self2._onplay = o.onplay ? [{ fn: o.onplay }] : [];
        self2._onstop = o.onstop ? [{ fn: o.onstop }] : [];
        self2._onmute = o.onmute ? [{ fn: o.onmute }] : [];
        self2._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
        self2._onrate = o.onrate ? [{ fn: o.onrate }] : [];
        self2._onseek = o.onseek ? [{ fn: o.onseek }] : [];
        self2._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
        self2._onresume = [];
        self2._webAudio = Howler2.usingWebAudio && !self2._html5;
        if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
          Howler2._unlockAudio();
        }
        Howler2._howls.push(self2);
        if (self2._autoplay) {
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play();
            }
          });
        }
        if (self2._preload && self2._preload !== "none") {
          self2.load();
        }
        return self2;
      },
      /**
       * Load the audio file.
       * @return {Howler}
       */
      load: function() {
        var self2 = this;
        var url = null;
        if (Howler2.noAudio) {
          self2._emit("loaderror", null, "No audio support.");
          return;
        }
        if (typeof self2._src === "string") {
          self2._src = [self2._src];
        }
        for (var i = 0; i < self2._src.length; i++) {
          var ext, str;
          if (self2._format && self2._format[i]) {
            ext = self2._format[i];
          } else {
            str = self2._src[i];
            if (typeof str !== "string") {
              self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
              continue;
            }
            ext = /^data:audio\/([^;,]+);/i.exec(str);
            if (!ext) {
              ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
            }
            if (ext) {
              ext = ext[1].toLowerCase();
            }
          }
          if (!ext) {
            console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
          }
          if (ext && Howler2.codecs(ext)) {
            url = self2._src[i];
            break;
          }
        }
        if (!url) {
          self2._emit("loaderror", null, "No codec support for selected audio sources.");
          return;
        }
        self2._src = url;
        self2._state = "loading";
        if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
          self2._html5 = true;
          self2._webAudio = false;
        }
        new Sound2(self2);
        if (self2._webAudio) {
          loadBuffer(self2);
        }
        return self2;
      },
      /**
       * Play a sound or resume previous playback.
       * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Number}          Sound ID.
       */
      play: function(sprite, internal) {
        var self2 = this;
        var id2 = null;
        if (typeof sprite === "number") {
          id2 = sprite;
          sprite = null;
        } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
          return null;
        } else if (typeof sprite === "undefined") {
          sprite = "__default";
          if (!self2._playLock) {
            var num = 0;
            for (var i = 0; i < self2._sounds.length; i++) {
              if (self2._sounds[i]._paused && !self2._sounds[i]._ended) {
                num++;
                id2 = self2._sounds[i]._id;
              }
            }
            if (num === 1) {
              sprite = null;
            } else {
              id2 = null;
            }
          }
        }
        var sound2 = id2 ? self2._soundById(id2) : self2._inactiveSound();
        if (!sound2) {
          return null;
        }
        if (id2 && !sprite) {
          sprite = sound2._sprite || "__default";
        }
        if (self2._state !== "loaded") {
          sound2._sprite = sprite;
          sound2._ended = false;
          var soundId = sound2._id;
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play(soundId);
            }
          });
          return soundId;
        }
        if (id2 && !sound2._paused) {
          if (!internal) {
            self2._loadQueue("play");
          }
          return sound2._id;
        }
        if (self2._webAudio) {
          Howler2._autoResume();
        }
        var seek2 = Math.max(0, sound2._seek > 0 ? sound2._seek : self2._sprite[sprite][0] / 1e3);
        var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek2);
        var timeout = duration * 1e3 / Math.abs(sound2._rate);
        var start = self2._sprite[sprite][0] / 1e3;
        var stop2 = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
        sound2._sprite = sprite;
        sound2._ended = false;
        var setParams = function() {
          sound2._paused = false;
          sound2._seek = seek2;
          sound2._start = start;
          sound2._stop = stop2;
          sound2._loop = !!(sound2._loop || self2._sprite[sprite][2]);
        };
        if (seek2 >= stop2) {
          self2._ended(sound2);
          return;
        }
        var node = sound2._node;
        if (self2._webAudio) {
          var playWebAudio = function() {
            self2._playLock = false;
            setParams();
            self2._refreshBuffer(sound2);
            var vol = sound2._muted || self2._muted ? 0 : sound2._volume;
            node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            sound2._playStart = Howler2.ctx.currentTime;
            if (typeof node.bufferSource.start === "undefined") {
              sound2._loop ? node.bufferSource.noteGrainOn(0, seek2, 86400) : node.bufferSource.noteGrainOn(0, seek2, duration);
            } else {
              sound2._loop ? node.bufferSource.start(0, seek2, 86400) : node.bufferSource.start(0, seek2, duration);
            }
            if (timeout !== Infinity) {
              self2._endTimers[sound2._id] = setTimeout(self2._ended.bind(self2, sound2), timeout);
            }
            if (!internal) {
              setTimeout(function() {
                self2._emit("play", sound2._id);
                self2._loadQueue();
              }, 0);
            }
          };
          if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
            playWebAudio();
          } else {
            self2._playLock = true;
            self2.once("resume", playWebAudio);
            self2._clearTimer(sound2._id);
          }
        } else {
          var playHtml5 = function() {
            node.currentTime = seek2;
            node.muted = sound2._muted || self2._muted || Howler2._muted || node.muted;
            node.volume = sound2._volume * Howler2.volume();
            node.playbackRate = sound2._rate;
            try {
              var play2 = node.play();
              if (play2 && typeof Promise !== "undefined" && (play2 instanceof Promise || typeof play2.then === "function")) {
                self2._playLock = true;
                setParams();
                play2.then(function() {
                  self2._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self2._emit("play", sound2._id);
                  } else {
                    self2._loadQueue();
                  }
                }).catch(function() {
                  self2._playLock = false;
                  self2._emit("playerror", sound2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  sound2._ended = true;
                  sound2._paused = true;
                });
              } else if (!internal) {
                self2._playLock = false;
                setParams();
                self2._emit("play", sound2._id);
              }
              node.playbackRate = sound2._rate;
              if (node.paused) {
                self2._emit("playerror", sound2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                return;
              }
              if (sprite !== "__default" || sound2._loop) {
                self2._endTimers[sound2._id] = setTimeout(self2._ended.bind(self2, sound2), timeout);
              } else {
                self2._endTimers[sound2._id] = function() {
                  self2._ended(sound2);
                  node.removeEventListener("ended", self2._endTimers[sound2._id], false);
                };
                node.addEventListener("ended", self2._endTimers[sound2._id], false);
              }
            } catch (err) {
              self2._emit("playerror", sound2._id, err);
            }
          };
          if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
            node.src = self2._src;
            node.load();
          }
          var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
          if (node.readyState >= 3 || loadedNoReadyState) {
            playHtml5();
          } else {
            self2._playLock = true;
            self2._state = "loading";
            var listener = function() {
              self2._state = "loaded";
              playHtml5();
              node.removeEventListener(Howler2._canPlayEvent, listener, false);
            };
            node.addEventListener(Howler2._canPlayEvent, listener, false);
            self2._clearTimer(sound2._id);
          }
        }
        return sound2._id;
      },
      /**
       * Pause playback and save current position.
       * @param  {Number} id The sound ID (empty to pause all in group).
       * @return {Howl}
       */
      pause: function(id2) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "pause",
            action: function() {
              self2.pause(id2);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id2);
        for (var i = 0; i < ids.length; i++) {
          self2._clearTimer(ids[i]);
          var sound2 = self2._soundById(ids[i]);
          if (sound2 && !sound2._paused) {
            sound2._seek = self2.seek(ids[i]);
            sound2._rateSeek = 0;
            sound2._paused = true;
            self2._stopFade(ids[i]);
            if (sound2._node) {
              if (self2._webAudio) {
                if (!sound2._node.bufferSource) {
                  continue;
                }
                if (typeof sound2._node.bufferSource.stop === "undefined") {
                  sound2._node.bufferSource.noteOff(0);
                } else {
                  sound2._node.bufferSource.stop(0);
                }
                self2._cleanBuffer(sound2._node);
              } else if (!isNaN(sound2._node.duration) || sound2._node.duration === Infinity) {
                sound2._node.pause();
              }
            }
          }
          if (!arguments[1]) {
            self2._emit("pause", sound2 ? sound2._id : null);
          }
        }
        return self2;
      },
      /**
       * Stop playback and reset to start.
       * @param  {Number} id The sound ID (empty to stop all in group).
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Howl}
       */
      stop: function(id2, internal) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "stop",
            action: function() {
              self2.stop(id2);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id2);
        for (var i = 0; i < ids.length; i++) {
          self2._clearTimer(ids[i]);
          var sound2 = self2._soundById(ids[i]);
          if (sound2) {
            sound2._seek = sound2._start || 0;
            sound2._rateSeek = 0;
            sound2._paused = true;
            sound2._ended = true;
            self2._stopFade(ids[i]);
            if (sound2._node) {
              if (self2._webAudio) {
                if (sound2._node.bufferSource) {
                  if (typeof sound2._node.bufferSource.stop === "undefined") {
                    sound2._node.bufferSource.noteOff(0);
                  } else {
                    sound2._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound2._node);
                }
              } else if (!isNaN(sound2._node.duration) || sound2._node.duration === Infinity) {
                sound2._node.currentTime = sound2._start || 0;
                sound2._node.pause();
                if (sound2._node.duration === Infinity) {
                  self2._clearSound(sound2._node);
                }
              }
            }
            if (!internal) {
              self2._emit("stop", sound2._id);
            }
          }
        }
        return self2;
      },
      /**
       * Mute/unmute a single sound or all sounds in this Howl group.
       * @param  {Boolean} muted Set to true to mute and false to unmute.
       * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
       * @return {Howl}
       */
      mute: function(muted2, id2) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "mute",
            action: function() {
              self2.mute(muted2, id2);
            }
          });
          return self2;
        }
        if (typeof id2 === "undefined") {
          if (typeof muted2 === "boolean") {
            self2._muted = muted2;
          } else {
            return self2._muted;
          }
        }
        var ids = self2._getSoundIds(id2);
        for (var i = 0; i < ids.length; i++) {
          var sound2 = self2._soundById(ids[i]);
          if (sound2) {
            sound2._muted = muted2;
            if (sound2._interval) {
              self2._stopFade(sound2._id);
            }
            if (self2._webAudio && sound2._node) {
              sound2._node.gain.setValueAtTime(muted2 ? 0 : sound2._volume, Howler2.ctx.currentTime);
            } else if (sound2._node) {
              sound2._node.muted = Howler2._muted ? true : muted2;
            }
            self2._emit("mute", sound2._id);
          }
        }
        return self2;
      },
      /**
       * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
       *   volume() -> Returns the group's volume value.
       *   volume(id) -> Returns the sound id's current volume.
       *   volume(vol) -> Sets the volume of all sounds in this Howl group.
       *   volume(vol, id) -> Sets the volume of passed sound id.
       * @return {Howl/Number} Returns self or current volume.
       */
      volume: function() {
        var self2 = this;
        var args = arguments;
        var vol, id2;
        if (args.length === 0) {
          return self2._volume;
        } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id2 = parseInt(args[0], 10);
          } else {
            vol = parseFloat(args[0]);
          }
        } else if (args.length >= 2) {
          vol = parseFloat(args[0]);
          id2 = parseInt(args[1], 10);
        }
        var sound2;
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "volume",
              action: function() {
                self2.volume.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id2 === "undefined") {
            self2._volume = vol;
          }
          id2 = self2._getSoundIds(id2);
          for (var i = 0; i < id2.length; i++) {
            sound2 = self2._soundById(id2[i]);
            if (sound2) {
              sound2._volume = vol;
              if (!args[2]) {
                self2._stopFade(id2[i]);
              }
              if (self2._webAudio && sound2._node && !sound2._muted) {
                sound2._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              } else if (sound2._node && !sound2._muted) {
                sound2._node.volume = vol * Howler2.volume();
              }
              self2._emit("volume", sound2._id);
            }
          }
        } else {
          sound2 = id2 ? self2._soundById(id2) : self2._sounds[0];
          return sound2 ? sound2._volume : 0;
        }
        return self2;
      },
      /**
       * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id (omit to fade all sounds).
       * @return {Howl}
       */
      fade: function(from, to, len, id2) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "fade",
            action: function() {
              self2.fade(from, to, len, id2);
            }
          });
          return self2;
        }
        from = Math.min(Math.max(0, parseFloat(from)), 1);
        to = Math.min(Math.max(0, parseFloat(to)), 1);
        len = parseFloat(len);
        self2.volume(from, id2);
        var ids = self2._getSoundIds(id2);
        for (var i = 0; i < ids.length; i++) {
          var sound2 = self2._soundById(ids[i]);
          if (sound2) {
            if (!id2) {
              self2._stopFade(ids[i]);
            }
            if (self2._webAudio && !sound2._muted) {
              var currentTime = Howler2.ctx.currentTime;
              var end = currentTime + len / 1e3;
              sound2._volume = from;
              sound2._node.gain.setValueAtTime(from, currentTime);
              sound2._node.gain.linearRampToValueAtTime(to, end);
            }
            self2._startFadeInterval(sound2, from, to, len, ids[i], typeof id2 === "undefined");
          }
        }
        return self2;
      },
      /**
       * Starts the internal interval to fade a sound.
       * @param  {Object} sound Reference to sound to fade.
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id to fade.
       * @param  {Boolean} isGroup   If true, set the volume on the group.
       */
      _startFadeInterval: function(sound2, from, to, len, id2, isGroup) {
        var self2 = this;
        var vol = from;
        var diff2 = to - from;
        var steps = Math.abs(diff2 / 0.01);
        var stepLen = Math.max(4, steps > 0 ? len / steps : len);
        var lastTick = Date.now();
        sound2._fadeTo = to;
        sound2._interval = setInterval(function() {
          var tick = (Date.now() - lastTick) / len;
          lastTick = Date.now();
          vol += diff2 * tick;
          vol = Math.round(vol * 100) / 100;
          if (diff2 < 0) {
            vol = Math.max(to, vol);
          } else {
            vol = Math.min(to, vol);
          }
          if (self2._webAudio) {
            sound2._volume = vol;
          } else {
            self2.volume(vol, sound2._id, true);
          }
          if (isGroup) {
            self2._volume = vol;
          }
          if (to < from && vol <= to || to > from && vol >= to) {
            clearInterval(sound2._interval);
            sound2._interval = null;
            sound2._fadeTo = null;
            self2.volume(to, sound2._id);
            self2._emit("fade", sound2._id);
          }
        }, stepLen);
      },
      /**
       * Internal method that stops the currently playing fade when
       * a new fade starts, volume is changed or the sound is stopped.
       * @param  {Number} id The sound id.
       * @return {Howl}
       */
      _stopFade: function(id2) {
        var self2 = this;
        var sound2 = self2._soundById(id2);
        if (sound2 && sound2._interval) {
          if (self2._webAudio) {
            sound2._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
          }
          clearInterval(sound2._interval);
          sound2._interval = null;
          self2.volume(sound2._fadeTo, id2);
          sound2._fadeTo = null;
          self2._emit("fade", id2);
        }
        return self2;
      },
      /**
       * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
       *   loop() -> Returns the group's loop value.
       *   loop(id) -> Returns the sound id's loop value.
       *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
       *   loop(loop, id) -> Sets the loop value of passed sound id.
       * @return {Howl/Boolean} Returns self or current loop value.
       */
      loop: function() {
        var self2 = this;
        var args = arguments;
        var loop, id2, sound2;
        if (args.length === 0) {
          return self2._loop;
        } else if (args.length === 1) {
          if (typeof args[0] === "boolean") {
            loop = args[0];
            self2._loop = loop;
          } else {
            sound2 = self2._soundById(parseInt(args[0], 10));
            return sound2 ? sound2._loop : false;
          }
        } else if (args.length === 2) {
          loop = args[0];
          id2 = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id2);
        for (var i = 0; i < ids.length; i++) {
          sound2 = self2._soundById(ids[i]);
          if (sound2) {
            sound2._loop = loop;
            if (self2._webAudio && sound2._node && sound2._node.bufferSource) {
              sound2._node.bufferSource.loop = loop;
              if (loop) {
                sound2._node.bufferSource.loopStart = sound2._start || 0;
                sound2._node.bufferSource.loopEnd = sound2._stop;
                if (self2.playing(ids[i])) {
                  self2.pause(ids[i], true);
                  self2.play(ids[i], true);
                }
              }
            }
          }
        }
        return self2;
      },
      /**
       * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   rate() -> Returns the first sound node's current playback rate.
       *   rate(id) -> Returns the sound id's current playback rate.
       *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
       *   rate(rate, id) -> Sets the playback rate of passed sound id.
       * @return {Howl/Number} Returns self or the current playback rate.
       */
      rate: function() {
        var self2 = this;
        var args = arguments;
        var rate2, id2;
        if (args.length === 0) {
          id2 = self2._sounds[0]._id;
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id2 = parseInt(args[0], 10);
          } else {
            rate2 = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          rate2 = parseFloat(args[0]);
          id2 = parseInt(args[1], 10);
        }
        var sound2;
        if (typeof rate2 === "number") {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "rate",
              action: function() {
                self2.rate.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id2 === "undefined") {
            self2._rate = rate2;
          }
          id2 = self2._getSoundIds(id2);
          for (var i = 0; i < id2.length; i++) {
            sound2 = self2._soundById(id2[i]);
            if (sound2) {
              if (self2.playing(id2[i])) {
                sound2._rateSeek = self2.seek(id2[i]);
                sound2._playStart = self2._webAudio ? Howler2.ctx.currentTime : sound2._playStart;
              }
              sound2._rate = rate2;
              if (self2._webAudio && sound2._node && sound2._node.bufferSource) {
                sound2._node.bufferSource.playbackRate.setValueAtTime(rate2, Howler2.ctx.currentTime);
              } else if (sound2._node) {
                sound2._node.playbackRate = rate2;
              }
              var seek2 = self2.seek(id2[i]);
              var duration = (self2._sprite[sound2._sprite][0] + self2._sprite[sound2._sprite][1]) / 1e3 - seek2;
              var timeout = duration * 1e3 / Math.abs(sound2._rate);
              if (self2._endTimers[id2[i]] || !sound2._paused) {
                self2._clearTimer(id2[i]);
                self2._endTimers[id2[i]] = setTimeout(self2._ended.bind(self2, sound2), timeout);
              }
              self2._emit("rate", sound2._id);
            }
          }
        } else {
          sound2 = self2._soundById(id2);
          return sound2 ? sound2._rate : self2._rate;
        }
        return self2;
      },
      /**
       * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   seek() -> Returns the first sound node's current seek position.
       *   seek(id) -> Returns the sound id's current seek position.
       *   seek(seek) -> Sets the seek position of the first sound node.
       *   seek(seek, id) -> Sets the seek position of passed sound id.
       * @return {Howl/Number} Returns self or the current seek position.
       */
      seek: function() {
        var self2 = this;
        var args = arguments;
        var seek2, id2;
        if (args.length === 0) {
          if (self2._sounds.length) {
            id2 = self2._sounds[0]._id;
          }
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id2 = parseInt(args[0], 10);
          } else if (self2._sounds.length) {
            id2 = self2._sounds[0]._id;
            seek2 = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          seek2 = parseFloat(args[0]);
          id2 = parseInt(args[1], 10);
        }
        if (typeof id2 === "undefined") {
          return 0;
        }
        if (typeof seek2 === "number" && (self2._state !== "loaded" || self2._playLock)) {
          self2._queue.push({
            event: "seek",
            action: function() {
              self2.seek.apply(self2, args);
            }
          });
          return self2;
        }
        var sound2 = self2._soundById(id2);
        if (sound2) {
          if (typeof seek2 === "number" && seek2 >= 0) {
            var playing = self2.playing(id2);
            if (playing) {
              self2.pause(id2, true);
            }
            sound2._seek = seek2;
            sound2._ended = false;
            self2._clearTimer(id2);
            if (!self2._webAudio && sound2._node && !isNaN(sound2._node.duration)) {
              sound2._node.currentTime = seek2;
            }
            var seekAndEmit = function() {
              if (playing) {
                self2.play(id2, true);
              }
              self2._emit("seek", id2);
            };
            if (playing && !self2._webAudio) {
              var emitSeek = function() {
                if (!self2._playLock) {
                  seekAndEmit();
                } else {
                  setTimeout(emitSeek, 0);
                }
              };
              setTimeout(emitSeek, 0);
            } else {
              seekAndEmit();
            }
          } else {
            if (self2._webAudio) {
              var realTime = self2.playing(id2) ? Howler2.ctx.currentTime - sound2._playStart : 0;
              var rateSeek = sound2._rateSeek ? sound2._rateSeek - sound2._seek : 0;
              return sound2._seek + (rateSeek + realTime * Math.abs(sound2._rate));
            } else {
              return sound2._node.currentTime;
            }
          }
        }
        return self2;
      },
      /**
       * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
       * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
       * @return {Boolean} True if playing and false if not.
       */
      playing: function(id2) {
        var self2 = this;
        if (typeof id2 === "number") {
          var sound2 = self2._soundById(id2);
          return sound2 ? !sound2._paused : false;
        }
        for (var i = 0; i < self2._sounds.length; i++) {
          if (!self2._sounds[i]._paused) {
            return true;
          }
        }
        return false;
      },
      /**
       * Get the duration of this sound. Passing a sound id will return the sprite duration.
       * @param  {Number} id The sound id to check. If none is passed, return full source duration.
       * @return {Number} Audio duration in seconds.
       */
      duration: function(id2) {
        var self2 = this;
        var duration = self2._duration;
        var sound2 = self2._soundById(id2);
        if (sound2) {
          duration = self2._sprite[sound2._sprite][1] / 1e3;
        }
        return duration;
      },
      /**
       * Returns the current loaded state of this Howl.
       * @return {String} 'unloaded', 'loading', 'loaded'
       */
      state: function() {
        return this._state;
      },
      /**
       * Unload and destroy the current Howl object.
       * This will immediately stop all sound instances attached to this group.
       */
      unload: function() {
        var self2 = this;
        var sounds = self2._sounds;
        for (var i = 0; i < sounds.length; i++) {
          if (!sounds[i]._paused) {
            self2.stop(sounds[i]._id);
          }
          if (!self2._webAudio) {
            self2._clearSound(sounds[i]._node);
            sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
            sounds[i]._node.removeEventListener(Howler2._canPlayEvent, sounds[i]._loadFn, false);
            sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
            Howler2._releaseHtml5Audio(sounds[i]._node);
          }
          delete sounds[i]._node;
          self2._clearTimer(sounds[i]._id);
        }
        var index2 = Howler2._howls.indexOf(self2);
        if (index2 >= 0) {
          Howler2._howls.splice(index2, 1);
        }
        var remCache = true;
        for (i = 0; i < Howler2._howls.length; i++) {
          if (Howler2._howls[i]._src === self2._src || self2._src.indexOf(Howler2._howls[i]._src) >= 0) {
            remCache = false;
            break;
          }
        }
        if (cache2 && remCache) {
          delete cache2[self2._src];
        }
        Howler2.noAudio = false;
        self2._state = "unloaded";
        self2._sounds = [];
        self2 = null;
        return null;
      },
      /**
       * Listen to a custom event.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
       * @return {Howl}
       */
      on: function(event2, fn, id2, once2) {
        var self2 = this;
        var events = self2["_on" + event2];
        if (typeof fn === "function") {
          events.push(once2 ? { id: id2, fn, once: once2 } : { id: id2, fn });
        }
        return self2;
      },
      /**
       * Remove a custom event. Call without parameters to remove all events.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to remove. Leave empty to remove all.
       * @param  {Number}   id    (optional) Only remove events for this sound.
       * @return {Howl}
       */
      off: function(event2, fn, id2) {
        var self2 = this;
        var events = self2["_on" + event2];
        var i = 0;
        if (typeof fn === "number") {
          id2 = fn;
          fn = null;
        }
        if (fn || id2) {
          for (i = 0; i < events.length; i++) {
            var isId = id2 === events[i].id;
            if (fn === events[i].fn && isId || !fn && isId) {
              events.splice(i, 1);
              break;
            }
          }
        } else if (event2) {
          self2["_on" + event2] = [];
        } else {
          var keys2 = Object.keys(self2);
          for (i = 0; i < keys2.length; i++) {
            if (keys2[i].indexOf("_on") === 0 && Array.isArray(self2[keys2[i]])) {
              self2[keys2[i]] = [];
            }
          }
        }
        return self2;
      },
      /**
       * Listen to a custom event and remove it once fired.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @return {Howl}
       */
      once: function(event2, fn, id2) {
        var self2 = this;
        self2.on(event2, fn, id2, 1);
        return self2;
      },
      /**
       * Emit all events of a specific type and pass the sound id.
       * @param  {String} event Event name.
       * @param  {Number} id    Sound ID.
       * @param  {Number} msg   Message to go with event.
       * @return {Howl}
       */
      _emit: function(event2, id2, msg) {
        var self2 = this;
        var events = self2["_on" + event2];
        for (var i = events.length - 1; i >= 0; i--) {
          if (!events[i].id || events[i].id === id2 || event2 === "load") {
            setTimeout((function(fn) {
              fn.call(this, id2, msg);
            }).bind(self2, events[i].fn), 0);
            if (events[i].once) {
              self2.off(event2, events[i].fn, events[i].id);
            }
          }
        }
        self2._loadQueue(event2);
        return self2;
      },
      /**
       * Queue of actions initiated before the sound has loaded.
       * These will be called in sequence, with the next only firing
       * after the previous has finished executing (even if async like play).
       * @return {Howl}
       */
      _loadQueue: function(event2) {
        var self2 = this;
        if (self2._queue.length > 0) {
          var task = self2._queue[0];
          if (task.event === event2) {
            self2._queue.shift();
            self2._loadQueue();
          }
          if (!event2) {
            task.action();
          }
        }
        return self2;
      },
      /**
       * Fired when playback ends at the end of the duration.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _ended: function(sound2) {
        var self2 = this;
        var sprite = sound2._sprite;
        if (!self2._webAudio && sound2._node && !sound2._node.paused && !sound2._node.ended && sound2._node.currentTime < sound2._stop) {
          setTimeout(self2._ended.bind(self2, sound2), 100);
          return self2;
        }
        var loop = !!(sound2._loop || self2._sprite[sprite][2]);
        self2._emit("end", sound2._id);
        if (!self2._webAudio && loop) {
          self2.stop(sound2._id, true).play(sound2._id);
        }
        if (self2._webAudio && loop) {
          self2._emit("play", sound2._id);
          sound2._seek = sound2._start || 0;
          sound2._rateSeek = 0;
          sound2._playStart = Howler2.ctx.currentTime;
          var timeout = (sound2._stop - sound2._start) * 1e3 / Math.abs(sound2._rate);
          self2._endTimers[sound2._id] = setTimeout(self2._ended.bind(self2, sound2), timeout);
        }
        if (self2._webAudio && !loop) {
          sound2._paused = true;
          sound2._ended = true;
          sound2._seek = sound2._start || 0;
          sound2._rateSeek = 0;
          self2._clearTimer(sound2._id);
          self2._cleanBuffer(sound2._node);
          Howler2._autoSuspend();
        }
        if (!self2._webAudio && !loop) {
          self2.stop(sound2._id, true);
        }
        return self2;
      },
      /**
       * Clear the end timer for a sound playback.
       * @param  {Number} id The sound ID.
       * @return {Howl}
       */
      _clearTimer: function(id2) {
        var self2 = this;
        if (self2._endTimers[id2]) {
          if (typeof self2._endTimers[id2] !== "function") {
            clearTimeout(self2._endTimers[id2]);
          } else {
            var sound2 = self2._soundById(id2);
            if (sound2 && sound2._node) {
              sound2._node.removeEventListener("ended", self2._endTimers[id2], false);
            }
          }
          delete self2._endTimers[id2];
        }
        return self2;
      },
      /**
       * Return the sound identified by this ID, or return null.
       * @param  {Number} id Sound ID
       * @return {Object}    Sound object or null.
       */
      _soundById: function(id2) {
        var self2 = this;
        for (var i = 0; i < self2._sounds.length; i++) {
          if (id2 === self2._sounds[i]._id) {
            return self2._sounds[i];
          }
        }
        return null;
      },
      /**
       * Return an inactive sound from the pool or create a new one.
       * @return {Sound} Sound playback object.
       */
      _inactiveSound: function() {
        var self2 = this;
        self2._drain();
        for (var i = 0; i < self2._sounds.length; i++) {
          if (self2._sounds[i]._ended) {
            return self2._sounds[i].reset();
          }
        }
        return new Sound2(self2);
      },
      /**
       * Drain excess inactive sounds from the pool.
       */
      _drain: function() {
        var self2 = this;
        var limit = self2._pool;
        var cnt = 0;
        var i = 0;
        if (self2._sounds.length < limit) {
          return;
        }
        for (i = 0; i < self2._sounds.length; i++) {
          if (self2._sounds[i]._ended) {
            cnt++;
          }
        }
        for (i = self2._sounds.length - 1; i >= 0; i--) {
          if (cnt <= limit) {
            return;
          }
          if (self2._sounds[i]._ended) {
            if (self2._webAudio && self2._sounds[i]._node) {
              self2._sounds[i]._node.disconnect(0);
            }
            self2._sounds.splice(i, 1);
            cnt--;
          }
        }
      },
      /**
       * Get all ID's from the sounds pool.
       * @param  {Number} id Only return one ID if one is passed.
       * @return {Array}    Array of IDs.
       */
      _getSoundIds: function(id2) {
        var self2 = this;
        if (typeof id2 === "undefined") {
          var ids = [];
          for (var i = 0; i < self2._sounds.length; i++) {
            ids.push(self2._sounds[i]._id);
          }
          return ids;
        } else {
          return [id2];
        }
      },
      /**
       * Load the sound back into the buffer source.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _refreshBuffer: function(sound2) {
        var self2 = this;
        sound2._node.bufferSource = Howler2.ctx.createBufferSource();
        sound2._node.bufferSource.buffer = cache2[self2._src];
        if (sound2._panner) {
          sound2._node.bufferSource.connect(sound2._panner);
        } else {
          sound2._node.bufferSource.connect(sound2._node);
        }
        sound2._node.bufferSource.loop = sound2._loop;
        if (sound2._loop) {
          sound2._node.bufferSource.loopStart = sound2._start || 0;
          sound2._node.bufferSource.loopEnd = sound2._stop || 0;
        }
        sound2._node.bufferSource.playbackRate.setValueAtTime(sound2._rate, Howler2.ctx.currentTime);
        return self2;
      },
      /**
       * Prevent memory leaks by cleaning up the buffer source after playback.
       * @param  {Object} node Sound's audio node containing the buffer source.
       * @return {Howl}
       */
      _cleanBuffer: function(node) {
        var self2 = this;
        var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
        if (!node.bufferSource) {
          return self2;
        }
        if (Howler2._scratchBuffer && node.bufferSource) {
          node.bufferSource.onended = null;
          node.bufferSource.disconnect(0);
          if (isIOS) {
            try {
              node.bufferSource.buffer = Howler2._scratchBuffer;
            } catch (e) {
            }
          }
        }
        node.bufferSource = null;
        return self2;
      },
      /**
       * Set the source to a 0-second silence to stop any downloading (except in IE).
       * @param  {Object} node Audio node to clear.
       */
      _clearSound: function(node) {
        var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
        if (!checkIE) {
          node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        }
      }
    };
    var Sound2 = function(howl) {
      this._parent = howl;
      this.init();
    };
    Sound2.prototype = {
      /**
       * Initialize a new Sound object.
       * @return {Sound}
       */
      init: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        parent._sounds.push(self2);
        self2.create();
        return self2;
      },
      /**
       * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
       * @return {Sound}
       */
      create: function() {
        var self2 = this;
        var parent = self2._parent;
        var volume = Howler2._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
        if (parent._webAudio) {
          self2._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          self2._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
          self2._node.paused = true;
          self2._node.connect(Howler2.masterGain);
        } else if (!Howler2.noAudio) {
          self2._node = Howler2._obtainHtml5Audio();
          self2._errorFn = self2._errorListener.bind(self2);
          self2._node.addEventListener("error", self2._errorFn, false);
          self2._loadFn = self2._loadListener.bind(self2);
          self2._node.addEventListener(Howler2._canPlayEvent, self2._loadFn, false);
          self2._endFn = self2._endListener.bind(self2);
          self2._node.addEventListener("ended", self2._endFn, false);
          self2._node.src = parent._src;
          self2._node.preload = parent._preload === true ? "auto" : parent._preload;
          self2._node.volume = volume * Howler2.volume();
          self2._node.load();
        }
        return self2;
      },
      /**
       * Reset the parameters of this sound to the original state (for recycle).
       * @return {Sound}
       */
      reset: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._rateSeek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        return self2;
      },
      /**
       * HTML5 Audio error listener callback.
       */
      _errorListener: function() {
        var self2 = this;
        self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
        self2._node.removeEventListener("error", self2._errorFn, false);
      },
      /**
       * HTML5 Audio canplaythrough listener callback.
       */
      _loadListener: function() {
        var self2 = this;
        var parent = self2._parent;
        parent._duration = Math.ceil(self2._node.duration * 10) / 10;
        if (Object.keys(parent._sprite).length === 0) {
          parent._sprite = { __default: [0, parent._duration * 1e3] };
        }
        if (parent._state !== "loaded") {
          parent._state = "loaded";
          parent._emit("load");
          parent._loadQueue();
        }
        self2._node.removeEventListener(Howler2._canPlayEvent, self2._loadFn, false);
      },
      /**
       * HTML5 Audio ended listener callback.
       */
      _endListener: function() {
        var self2 = this;
        var parent = self2._parent;
        if (parent._duration === Infinity) {
          parent._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (parent._sprite.__default[1] === Infinity) {
            parent._sprite.__default[1] = parent._duration * 1e3;
          }
          parent._ended(self2);
        }
        self2._node.removeEventListener("ended", self2._endFn, false);
      }
    };
    var cache2 = {};
    var loadBuffer = function(self2) {
      var url = self2._src;
      if (cache2[url]) {
        self2._duration = cache2[url].duration;
        loadSound(self2);
        return;
      }
      if (/^data:[^;]+;base64,/.test(url)) {
        var data2 = atob(url.split(",")[1]);
        var dataView = new Uint8Array(data2.length);
        for (var i = 0; i < data2.length; ++i) {
          dataView[i] = data2.charCodeAt(i);
        }
        decodeAudioData(dataView.buffer, self2);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open(self2._xhr.method, url, true);
        xhr.withCredentials = self2._xhr.withCredentials;
        xhr.responseType = "arraybuffer";
        if (self2._xhr.headers) {
          Object.keys(self2._xhr.headers).forEach(function(key) {
            xhr.setRequestHeader(key, self2._xhr.headers[key]);
          });
        }
        xhr.onload = function() {
          var code = (xhr.status + "")[0];
          if (code !== "0" && code !== "2" && code !== "3") {
            self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
            return;
          }
          decodeAudioData(xhr.response, self2);
        };
        xhr.onerror = function() {
          if (self2._webAudio) {
            self2._html5 = true;
            self2._webAudio = false;
            self2._sounds = [];
            delete cache2[url];
            self2.load();
          }
        };
        safeXhrSend(xhr);
      }
    };
    var safeXhrSend = function(xhr) {
      try {
        xhr.send();
      } catch (e) {
        xhr.onerror();
      }
    };
    var decodeAudioData = function(arraybuffer, self2) {
      var error2 = function() {
        self2._emit("loaderror", null, "Decoding audio data failed.");
      };
      var success = function(buffer) {
        if (buffer && self2._sounds.length > 0) {
          cache2[self2._src] = buffer;
          loadSound(self2, buffer);
        } else {
          error2();
        }
      };
      if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
        Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error2);
      } else {
        Howler2.ctx.decodeAudioData(arraybuffer, success, error2);
      }
    };
    var loadSound = function(self2, buffer) {
      if (buffer && !self2._duration) {
        self2._duration = buffer.duration;
      }
      if (Object.keys(self2._sprite).length === 0) {
        self2._sprite = { __default: [0, self2._duration * 1e3] };
      }
      if (self2._state !== "loaded") {
        self2._state = "loaded";
        self2._emit("load");
        self2._loadQueue();
      }
    };
    var setupAudioContext = function() {
      if (!Howler2.usingWebAudio) {
        return;
      }
      try {
        if (typeof AudioContext !== "undefined") {
          Howler2.ctx = new AudioContext();
        } else if (typeof webkitAudioContext !== "undefined") {
          Howler2.ctx = new webkitAudioContext();
        } else {
          Howler2.usingWebAudio = false;
        }
      } catch (e) {
        Howler2.usingWebAudio = false;
      }
      if (!Howler2.ctx) {
        Howler2.usingWebAudio = false;
      }
      var iOS2 = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
      var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
      var version2 = appVersion ? parseInt(appVersion[1], 10) : null;
      if (iOS2 && version2 && version2 < 9) {
        var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
        if (Howler2._navigator && !safari) {
          Howler2.usingWebAudio = false;
        }
      }
      if (Howler2.usingWebAudio) {
        Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
        Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
        Howler2.masterGain.connect(Howler2.ctx.destination);
      }
      Howler2._setup();
    };
    if (false) {
      (void 0)([], function() {
        return {
          Howler: Howler2,
          Howl: Howl2
        };
      });
    }
    if (true) {
      exports.Howler = Howler2;
      exports.Howl = Howl2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.HowlerGlobal = HowlerGlobal2;
      commonjsGlobal.Howler = Howler2;
      commonjsGlobal.Howl = Howl2;
      commonjsGlobal.Sound = Sound2;
    } else if (typeof window !== "undefined") {
      window.HowlerGlobal = HowlerGlobal2;
      window.Howler = Howler2;
      window.Howl = Howl2;
      window.Sound = Sound2;
    }
  })();
  (function() {
    "use strict";
    HowlerGlobal.prototype._pos = [0, 0, 0];
    HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
    HowlerGlobal.prototype.stereo = function(pan) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      for (var i = self2._howls.length - 1; i >= 0; i--) {
        self2._howls[i].stereo(pan);
      }
      return self2;
    };
    HowlerGlobal.prototype.pos = function(x, y, z) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      y = typeof y !== "number" ? self2._pos[1] : y;
      z = typeof z !== "number" ? self2._pos[2] : z;
      if (typeof x === "number") {
        self2._pos = [x, y, z];
        if (typeof self2.ctx.listener.positionX !== "undefined") {
          self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
        }
      } else {
        return self2._pos;
      }
      return self2;
    };
    HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      var or = self2._orientation;
      y = typeof y !== "number" ? or[1] : y;
      z = typeof z !== "number" ? or[2] : z;
      xUp = typeof xUp !== "number" ? or[3] : xUp;
      yUp = typeof yUp !== "number" ? or[4] : yUp;
      zUp = typeof zUp !== "number" ? or[5] : zUp;
      if (typeof x === "number") {
        self2._orientation = [x, y, z, xUp, yUp, zUp];
        if (typeof self2.ctx.listener.forwardX !== "undefined") {
          self2.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
        }
      } else {
        return or;
      }
      return self2;
    };
    Howl.prototype.init = /* @__PURE__ */ function(_super) {
      return function(o) {
        var self2 = this;
        self2._orientation = o.orientation || [1, 0, 0];
        self2._stereo = o.stereo || null;
        self2._pos = o.pos || null;
        self2._pannerAttr = {
          coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
          coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
          coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
          distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
          maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
          panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
          refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
          rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
        };
        self2._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
        self2._onpos = o.onpos ? [{ fn: o.onpos }] : [];
        self2._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
        return _super.call(this, o);
      };
    }(Howl.prototype.init);
    Howl.prototype.stereo = function(pan, id2) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "stereo",
          action: function() {
            self2.stereo(pan, id2);
          }
        });
        return self2;
      }
      var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
      if (typeof id2 === "undefined") {
        if (typeof pan === "number") {
          self2._stereo = pan;
          self2._pos = [pan, 0, 0];
        } else {
          return self2._stereo;
        }
      }
      var ids = self2._getSoundIds(id2);
      for (var i = 0; i < ids.length; i++) {
        var sound2 = self2._soundById(ids[i]);
        if (sound2) {
          if (typeof pan === "number") {
            sound2._stereo = pan;
            sound2._pos = [pan, 0, 0];
            if (sound2._node) {
              sound2._pannerAttr.panningModel = "equalpower";
              if (!sound2._panner || !sound2._panner.pan) {
                setupPanner(sound2, pannerType);
              }
              if (pannerType === "spatial") {
                if (typeof sound2._panner.positionX !== "undefined") {
                  sound2._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                  sound2._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                  sound2._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                } else {
                  sound2._panner.setPosition(pan, 0, 0);
                }
              } else {
                sound2._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
              }
            }
            self2._emit("stereo", sound2._id);
          } else {
            return sound2._stereo;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pos = function(x, y, z, id2) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "pos",
          action: function() {
            self2.pos(x, y, z, id2);
          }
        });
        return self2;
      }
      y = typeof y !== "number" ? 0 : y;
      z = typeof z !== "number" ? -0.5 : z;
      if (typeof id2 === "undefined") {
        if (typeof x === "number") {
          self2._pos = [x, y, z];
        } else {
          return self2._pos;
        }
      }
      var ids = self2._getSoundIds(id2);
      for (var i = 0; i < ids.length; i++) {
        var sound2 = self2._soundById(ids[i]);
        if (sound2) {
          if (typeof x === "number") {
            sound2._pos = [x, y, z];
            if (sound2._node) {
              if (!sound2._panner || sound2._panner.pan) {
                setupPanner(sound2, "spatial");
              }
              if (typeof sound2._panner.positionX !== "undefined") {
                sound2._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                sound2._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                sound2._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
              } else {
                sound2._panner.setPosition(x, y, z);
              }
            }
            self2._emit("pos", sound2._id);
          } else {
            return sound2._pos;
          }
        }
      }
      return self2;
    };
    Howl.prototype.orientation = function(x, y, z, id2) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "orientation",
          action: function() {
            self2.orientation(x, y, z, id2);
          }
        });
        return self2;
      }
      y = typeof y !== "number" ? self2._orientation[1] : y;
      z = typeof z !== "number" ? self2._orientation[2] : z;
      if (typeof id2 === "undefined") {
        if (typeof x === "number") {
          self2._orientation = [x, y, z];
        } else {
          return self2._orientation;
        }
      }
      var ids = self2._getSoundIds(id2);
      for (var i = 0; i < ids.length; i++) {
        var sound2 = self2._soundById(ids[i]);
        if (sound2) {
          if (typeof x === "number") {
            sound2._orientation = [x, y, z];
            if (sound2._node) {
              if (!sound2._panner) {
                if (!sound2._pos) {
                  sound2._pos = self2._pos || [0, 0, -0.5];
                }
                setupPanner(sound2, "spatial");
              }
              if (typeof sound2._panner.orientationX !== "undefined") {
                sound2._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                sound2._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                sound2._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
              } else {
                sound2._panner.setOrientation(x, y, z);
              }
            }
            self2._emit("orientation", sound2._id);
          } else {
            return sound2._orientation;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pannerAttr = function() {
      var self2 = this;
      var args = arguments;
      var o, id2, sound2;
      if (!self2._webAudio) {
        return self2;
      }
      if (args.length === 0) {
        return self2._pannerAttr;
      } else if (args.length === 1) {
        if (typeof args[0] === "object") {
          o = args[0];
          if (typeof id2 === "undefined") {
            if (!o.pannerAttr) {
              o.pannerAttr = {
                coneInnerAngle: o.coneInnerAngle,
                coneOuterAngle: o.coneOuterAngle,
                coneOuterGain: o.coneOuterGain,
                distanceModel: o.distanceModel,
                maxDistance: o.maxDistance,
                refDistance: o.refDistance,
                rolloffFactor: o.rolloffFactor,
                panningModel: o.panningModel
              };
            }
            self2._pannerAttr = {
              coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
              coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
              coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self2._coneOuterGain,
              distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self2._distanceModel,
              maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self2._maxDistance,
              refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self2._refDistance,
              rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self2._rolloffFactor,
              panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self2._panningModel
            };
          }
        } else {
          sound2 = self2._soundById(parseInt(args[0], 10));
          return sound2 ? sound2._pannerAttr : self2._pannerAttr;
        }
      } else if (args.length === 2) {
        o = args[0];
        id2 = parseInt(args[1], 10);
      }
      var ids = self2._getSoundIds(id2);
      for (var i = 0; i < ids.length; i++) {
        sound2 = self2._soundById(ids[i]);
        if (sound2) {
          var pa = sound2._pannerAttr;
          pa = {
            coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
            coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
            coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
            distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
            maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
            refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
            rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
            panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
          };
          var panner2 = sound2._panner;
          if (!panner2) {
            if (!sound2._pos) {
              sound2._pos = self2._pos || [0, 0, -0.5];
            }
            setupPanner(sound2, "spatial");
            panner2 = sound2._panner;
          }
          panner2.coneInnerAngle = pa.coneInnerAngle;
          panner2.coneOuterAngle = pa.coneOuterAngle;
          panner2.coneOuterGain = pa.coneOuterGain;
          panner2.distanceModel = pa.distanceModel;
          panner2.maxDistance = pa.maxDistance;
          panner2.refDistance = pa.refDistance;
          panner2.rolloffFactor = pa.rolloffFactor;
          panner2.panningModel = pa.panningModel;
        }
      }
      return self2;
    };
    Sound.prototype.init = /* @__PURE__ */ function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        _super.call(this);
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        }
      };
    }(Sound.prototype.init);
    Sound.prototype.reset = /* @__PURE__ */ function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        } else if (self2._panner) {
          self2._panner.disconnect(0);
          self2._panner = void 0;
          parent._refreshBuffer(self2);
        }
        return _super.call(this);
      };
    }(Sound.prototype.reset);
    var setupPanner = function(sound2, type) {
      type = type || "spatial";
      if (type === "spatial") {
        sound2._panner = Howler.ctx.createPanner();
        sound2._panner.coneInnerAngle = sound2._pannerAttr.coneInnerAngle;
        sound2._panner.coneOuterAngle = sound2._pannerAttr.coneOuterAngle;
        sound2._panner.coneOuterGain = sound2._pannerAttr.coneOuterGain;
        sound2._panner.distanceModel = sound2._pannerAttr.distanceModel;
        sound2._panner.maxDistance = sound2._pannerAttr.maxDistance;
        sound2._panner.refDistance = sound2._pannerAttr.refDistance;
        sound2._panner.rolloffFactor = sound2._pannerAttr.rolloffFactor;
        sound2._panner.panningModel = sound2._pannerAttr.panningModel;
        if (typeof sound2._panner.positionX !== "undefined") {
          sound2._panner.positionX.setValueAtTime(sound2._pos[0], Howler.ctx.currentTime);
          sound2._panner.positionY.setValueAtTime(sound2._pos[1], Howler.ctx.currentTime);
          sound2._panner.positionZ.setValueAtTime(sound2._pos[2], Howler.ctx.currentTime);
        } else {
          sound2._panner.setPosition(sound2._pos[0], sound2._pos[1], sound2._pos[2]);
        }
        if (typeof sound2._panner.orientationX !== "undefined") {
          sound2._panner.orientationX.setValueAtTime(sound2._orientation[0], Howler.ctx.currentTime);
          sound2._panner.orientationY.setValueAtTime(sound2._orientation[1], Howler.ctx.currentTime);
          sound2._panner.orientationZ.setValueAtTime(sound2._orientation[2], Howler.ctx.currentTime);
        } else {
          sound2._panner.setOrientation(sound2._orientation[0], sound2._orientation[1], sound2._orientation[2]);
        }
      } else {
        sound2._panner = Howler.ctx.createStereoPanner();
        sound2._panner.pan.setValueAtTime(sound2._stereo, Howler.ctx.currentTime);
      }
      sound2._panner.connect(sound2._node);
      if (!sound2._paused) {
        sound2._parent.pause(sound2._id, true).play(sound2._id, true);
      }
    };
  })();
})(howler$1);
var howler = getDefaultExportFromCjs(howler$1);
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function isNumeric(str) {
  if (typeof str === "string") {
    str = str.trim();
  }
  return !isNaN(str) && /^[+-]?(\d+(\.\d+)?|\.\d+)$/.test(str);
}
function isBoolean(str) {
  const trimmed = str.trim();
  return trimmed === "true" || trimmed === "false";
}
function toHex(str) {
  let res = "", c = 0;
  while (c < str.length) {
    res += str.charCodeAt(c++).toString(16);
  }
  return res;
}
function isDataUrl(str) {
  return /^data:(.+);base64,(.+)$/.test(str);
}
var string$1 = {
  __proto__: null,
  capitalize,
  isBoolean,
  isDataUrl,
  isNumeric,
  toHex
};
var audioTracks = {};
var current_track_id = null;
var retry_counter = 0;
var audioExts = [];
var soundLoadError = function(sound_name, onerror_cb) {
  if (retry_counter++ > 3) {
    let errmsg = "melonJS: failed loading " + sound_name;
    if (stopOnAudioError === false) {
      disable();
      if (onerror_cb) {
        onerror_cb();
      }
      console.log(errmsg + ", disabling audio");
    } else {
      throw new Error(errmsg);
    }
  } else {
    audioTracks[sound_name].load();
  }
};
var stopOnAudioError = true;
function init$1(format = "mp3") {
  audioExts = format.split(",");
  return !howler$1.Howler.noAudio;
}
function hasFormat(codec) {
  return hasAudio() && howler$1.Howler.codecs(codec);
}
function hasAudio() {
  return !howler$1.Howler.noAudio;
}
function enable() {
  unmuteAll();
}
function disable() {
  muteAll();
}
function load$1(sound2, onloadcb, onerrorcb, settings = {}) {
  let urls = [];
  if (audioExts.length === 0) {
    throw new Error("target audio extension(s) should be set through me.audio.init() before calling the preloader.");
  }
  if (isDataUrl(sound2.src) === true) {
    urls.push(sound2.src);
  } else {
    for (let i = 0; i < audioExts.length; i++) {
      urls.push(sound2.src + sound2.name + "." + audioExts[i] + settings.nocache);
    }
  }
  audioTracks[sound2.name] = new howler$1.Howl({
    src: urls,
    volume: howler$1.Howler.volume(),
    autoplay: sound2.autoplay === true,
    loop: sound2.loop = true,
    html5: sound2.stream === true || sound2.html5 === true,
    xhrWithCredentials: settings.withCredentials,
    onloaderror() {
      soundLoadError.call(this, sound2.name, onerrorcb);
    },
    onload() {
      retry_counter = 0;
      if (typeof onloadcb === "function") {
        onloadcb();
      }
    }
  });
  return 1;
}
function play(sound_name, loop = false, onend, volume) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    let id2 = sound2.play();
    if (typeof loop === "boolean") {
      sound2.loop(loop, id2);
    }
    sound2.volume(typeof volume === "number" ? clamp(volume, 0, 1) : howler$1.Howler.volume(), id2);
    if (typeof onend === "function") {
      if (loop === true) {
        sound2.on("end", onend, id2);
      } else {
        sound2.once("end", onend, id2);
      }
    }
    return id2;
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function fade(sound_name, from, to, duration, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    sound2.fade(from, to, duration, id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function seek(sound_name, ...args) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    return sound2.seek(...args);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function rate(sound_name, ...args) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    return sound2.rate(...args);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function stereo(sound_name, pan, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    return sound2.stereo(pan, id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function position(sound_name, x, y, z, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    return sound2.pos(x, y, z, id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function orientation(sound_name, x, y, z, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    return sound2.orientation(x, y, z, id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function panner(sound_name, attributes, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    return sound2.pannerAttr(attributes, id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function stop(sound_name, id2) {
  if (typeof sound_name !== "undefined") {
    let sound2 = audioTracks[sound_name];
    if (sound2 && typeof sound2 !== "undefined") {
      sound2.stop(id2);
      sound2.off("end", void 0, id2);
    } else {
      throw new Error("audio clip " + sound_name + " does not exist");
    }
  } else {
    howler$1.Howler.stop();
  }
}
function pause(sound_name, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    sound2.pause(id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function resume(sound_name, id2) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    sound2.play(id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function playTrack(sound_name, volume) {
  current_track_id = sound_name;
  return play(
    current_track_id,
    true,
    null,
    volume
  );
}
function stopTrack() {
  if (current_track_id !== null) {
    audioTracks[current_track_id].stop();
    current_track_id = null;
  }
}
function pauseTrack() {
  if (current_track_id !== null) {
    audioTracks[current_track_id].pause();
  }
}
function resumeTrack() {
  if (current_track_id !== null) {
    audioTracks[current_track_id].play();
  }
}
function getCurrentTrack() {
  return current_track_id;
}
function setVolume(volume) {
  howler$1.Howler.volume(volume);
}
function getVolume() {
  return howler$1.Howler.volume();
}
function mute(sound_name, id2, mute2 = true) {
  let sound2 = audioTracks[sound_name];
  if (sound2 && typeof sound2 !== "undefined") {
    sound2.mute(mute2, id2);
  } else {
    throw new Error("audio clip " + sound_name + " does not exist");
  }
}
function unmute(sound_name, id2) {
  mute(sound_name, id2, false);
}
function muteAll() {
  howler$1.Howler.mute(true);
}
function unmuteAll() {
  howler$1.Howler.mute(false);
}
function muted() {
  return howler$1.Howler._muted;
}
function unload$1(sound_name) {
  if (!(sound_name in audioTracks)) {
    return false;
  }
  audioTracks[sound_name].unload();
  delete audioTracks[sound_name];
  return true;
}
function unloadAll$1() {
  for (let sound_name in audioTracks) {
    if (audioTracks.hasOwnProperty(sound_name)) {
      unload$1(sound_name);
    }
  }
}
var audio = {
  __proto__: null,
  disable,
  enable,
  fade,
  getCurrentTrack,
  getVolume,
  hasAudio,
  hasFormat,
  init: init$1,
  load: load$1,
  mute,
  muteAll,
  muted,
  orientation,
  panner,
  pause,
  pauseTrack,
  play,
  playTrack,
  position,
  rate,
  resume,
  resumeTrack,
  seek,
  setVolume,
  stereo,
  stop,
  stopOnAudioError,
  stopTrack,
  unload: unload$1,
  unloadAll: unloadAll$1,
  unmute,
  unmuteAll
};
var data = {};
var hasLocalStorage$1 = false;
try {
  hasLocalStorage$1 = typeof globalThis !== "undefined" && typeof globalThis.localStorage !== "undefined";
} catch {
  hasLocalStorage$1 = false;
}
function isReserved(key) {
  return key === "add" || key === "remove";
}
once(BOOT, () => {
  if (hasLocalStorage$1 === true) {
    let me_save_content = globalThis.localStorage.getItem("me.save");
    if (typeof me_save_content === "string" && me_save_content.length > 0) {
      let keys2 = JSON.parse(me_save_content) || [];
      keys2.forEach((key) => {
        data[key] = JSON.parse(globalThis.localStorage.getItem("me.save." + key));
      });
    }
  }
});
var save = {
  /**
   * Add new keys to localStorage and set them to the given default values if they do not exist
   * @name add
   * @memberof save
   * @param {object} props - key and corresponding values
   * @example
   * // Initialize "score" and "lives" with default values
   * me.save.add({ score : 0, lives : 3 });
   * // get or set the value through me.save
   * me.save.score = 1000;
   */
  add(props) {
    let obj = save;
    Object.keys(props).forEach((key) => {
      if (isReserved(key)) {
        return;
      }
      (function(prop) {
        Object.defineProperty(obj, prop, {
          configurable: true,
          enumerable: true,
          /**
           * @ignore
           */
          get() {
            return data[prop];
          },
          /**
           * @ignore
           */
          set(value) {
            data[prop] = value;
            if (hasLocalStorage$1 === true) {
              globalThis.localStorage.setItem("me.save." + prop, JSON.stringify(value));
            }
          }
        });
      })(key);
      if (!(key in data)) {
        obj[key] = props[key];
      }
    });
    if (hasLocalStorage$1 === true) {
      globalThis.localStorage.setItem("me.save", JSON.stringify(Object.keys(data)));
    }
  },
  /**
   * Remove a key from localStorage
   * @name remove
   * @memberof save
   * @param {string} key - key to be removed
   * @example
   * // Remove the "score" key from localStorage
   * me.save.remove("score");
   */
  remove(key) {
    if (!isReserved(key)) {
      if (typeof data[key] !== "undefined") {
        delete data[key];
        if (hasLocalStorage$1 === true) {
          globalThis.localStorage.removeItem("me.save." + key);
          globalThis.localStorage.setItem("me.save", JSON.stringify(Object.keys(data)));
        }
      }
    }
  }
};
var vendors = ["ms", "MS", "moz", "webkit", "o"];
function prefixed(name, obj) {
  obj = obj || globalThis;
  if (name in obj) {
    return obj[name];
  }
  let uc_name = capitalize(name);
  let result;
  vendors.some((vendor) => {
    let name2 = vendor + uc_name;
    return result = name2 in obj ? obj[name2] : void 0;
  });
  return result;
}
function setPrefixed(name, value, obj) {
  obj = obj || globalThis;
  if (name in obj) {
    obj[name] = value;
    return;
  }
  let uc_name = capitalize(name);
  vendors.some((vendor) => {
    let name2 = vendor + uc_name;
    if (name2 in obj) {
      obj[name2] = value;
      return true;
    }
    return false;
  });
  return false;
}
var agent$1 = {
  __proto__: null,
  prefixed,
  setPrefixed
};
var ua = typeof globalThis.navigator !== "undefined" ? globalThis.navigator.userAgent : "";
var iOS = /iPhone|iPad|iPod/i.test(ua);
var android = /Android/i.test(ua);
var android2 = /Android 2/i.test(ua);
var linux = /Linux/i.test(ua);
var chromeOS = /CrOS/.test(ua);
var wp = /Windows Phone/i.test(ua);
var BlackBerry = /BlackBerry/i.test(ua);
var Kindle = /Kindle|Silk.*Mobile Safari/i.test(ua);
var ejecta = typeof globalThis.ejecta !== "undefined";
var isWeixin = /MicroMessenger/i.test(ua);
var nodeJS = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node";
var isMobile$1 = /Mobi/i.test(ua) || iOS || android || wp || BlackBerry || Kindle || false;
var webApp = typeof globalThis.navigator !== "undefined" && globalThis.navigator.standalone === true || typeof globalThis.matchMedia !== "undefined" && globalThis.matchMedia("(display-mode: standalone)").matches;
var device_platform = {
  __proto__: null,
  BlackBerry,
  Kindle,
  android,
  android2,
  chromeOS,
  ejecta,
  iOS,
  isMobile: isMobile$1,
  isWeixin,
  linux,
  nodeJS,
  ua,
  webApp,
  wp
};
var readyBound = false;
var isDOMReady = false;
function _domReady() {
  if (!isDOMReady) {
    if (typeof globalThis.document !== "undefined" && !globalThis.document.body) {
      return setTimeout(_domReady, 13);
    }
    if (typeof globalThis.document !== "undefined" && typeof globalThis.document.removeEventListener === "function") {
      globalThis.document.removeEventListener(
        "DOMContentLoaded",
        _domReady,
        false
      );
    }
    if (typeof globalThis.removeEventListener === "function") {
      globalThis.removeEventListener("load", _domReady, false);
    }
    emit(DOM_READY);
    isDOMReady = true;
  }
}
function DOMContentLoaded(fn) {
  if (isDOMReady) {
    fn.call(globalThis, []);
  } else {
    once(DOM_READY, fn, globalThis);
    if (!readyBound) {
      if (nodeJS === true || typeof globalThis.document !== "undefined" && globalThis.document.readyState === "complete") {
        globalThis.setTimeout(_domReady, 0);
      } else {
        if (typeof globalThis.document !== "undefined" && typeof globalThis.document.addEventListener === "function") {
          globalThis.document.addEventListener("DOMContentLoaded", _domReady, false);
        }
        globalThis.addEventListener("load", _domReady, false);
      }
      readyBound = true;
    }
  }
}
var accelInitialized = false;
var deviceOrientationInitialized = false;
var swipeEnabled = true;
var domRect = { left: 0, top: 0, x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
var videoCodecs;
var WebGLSupport = -1;
function disableSwipeFn(e) {
  e.preventDefault();
  if (typeof globalThis.scroll === "function") {
    globalThis.scroll(0, 0);
  }
  return false;
}
function hasLocalStorage() {
  try {
    return !!globalThis.localStorage;
  } catch {
    return false;
  }
}
function hasOffscreenCanvas() {
  try {
    return typeof globalThis.OffscreenCanvas !== "undefined" && new globalThis.OffscreenCanvas(0, 0).getContext("2d") !== null;
  } catch {
    return false;
  }
}
function onDeviceMotion(e) {
  accelerationX = e.accelerationIncludingGravity.x;
  accelerationY = e.accelerationIncludingGravity.y;
  accelerationZ = e.accelerationIncludingGravity.z;
}
function onDeviceRotate(e) {
  gamma = e.gamma;
  beta = e.beta;
  alpha = e.alpha;
}
var platform = device_platform;
var touchEvent = !!("ontouchstart" in globalThis);
var pointerEvent = !!globalThis.PointerEvent;
var touch = touchEvent || pointerEvent && globalThis.navigator.maxTouchPoints > 0;
var maxTouchPoints = touch ? pointerEvent ? globalThis.navigator.maxTouchPoints || 1 : 10 : 1;
var wheel = typeof globalThis.document !== "undefined" && "onwheel" in globalThis.document.createElement("div");
var hasPointerLockSupport = typeof globalThis.document !== "undefined" && typeof globalThis.document.pointerLockElement !== "undefined";
var hasDeviceOrientation = !!globalThis.DeviceOrientationEvent;
var screenOrientation = typeof screen !== "undefined" && typeof screen.orientation !== "undefined";
var hasAccelerometer = !!globalThis.DeviceMotionEvent;
var hasFullscreenSupport = typeof globalThis.document !== "undefined" && (prefixed("fullscreenEnabled", globalThis.document) || globalThis.document.mozFullScreenEnabled);
if (hasFullscreenSupport === true) {
  globalThis.document.exitFullscreen = prefixed("cancelFullScreen", globalThis.document) || prefixed("exitFullscreen", globalThis.document);
}
var hasWebAudio = !!(globalThis.AudioContext || globalThis.webkitAudioContext);
var hasHTML5Audio = typeof globalThis.Audio !== "undefined";
var sound = hasWebAudio || hasHTML5Audio;
var hasVideo = typeof globalThis.document !== "undefined" && !!globalThis.document.createElement("video").canPlayType;
var localStorage = hasLocalStorage();
var offscreenCanvas = hasOffscreenCanvas();
var nativeBase64 = typeof globalThis.atob === "function";
var language = typeof globalThis.navigator !== "undefined" ? globalThis.navigator.language || globalThis.navigator.browserLanguage || globalThis.navigator.userLanguage || "en" : "en";
var devicePixelRatio = globalThis.devicePixelRatio || 1;
var isMobile = platform.isMobile;
var accelerationX = 0;
var accelerationY = 0;
var accelerationZ = 0;
var gamma = 0;
var beta = 0;
var alpha = 0;
var pauseOnBlur = true;
var resumeOnFocus = true;
var stopOnBlur = false;
var autoFocus = true;
function onReady(fn) {
  if (typeof globalThis.addEventListener === "function") {
    globalThis.addEventListener("blur", () => {
      emit(BLUR);
    }, false);
    globalThis.addEventListener("focus", () => {
      emit(FOCUS);
      if (autoFocus === true) {
        focus();
      }
    }, false);
  }
  if (typeof globalThis.document !== "undefined") {
    if (typeof globalThis.document.addEventListener === "function") {
      globalThis.document.addEventListener("visibilitychange", () => {
        if (globalThis.document.visibilityState === "visible") {
          emit(FOCUS);
          if (autoFocus === true) {
            focus();
          }
        } else {
          emit(BLUR);
        }
      }, false);
    }
  }
  DOMContentLoaded(fn);
}
function enableSwipe(enable2) {
  let moveEvent = pointerEvent ? "pointermove" : touchEvent ? "touchmove" : "mousemove";
  if (enable2 !== false) {
    if (swipeEnabled === false) {
      globalThis.document.removeEventListener(moveEvent, disableSwipeFn);
      swipeEnabled = true;
    }
  } else if (swipeEnabled === true) {
    globalThis.document.addEventListener(moveEvent, disableSwipeFn, { passive: false });
    swipeEnabled = false;
  }
}
function isFullscreen() {
  if (hasFullscreenSupport) {
    return !!(prefixed("fullscreenElement", globalThis.document) || globalThis.document.mozFullScreenElement);
  } else {
    return false;
  }
}
function requestFullscreen(element) {
  if (hasFullscreenSupport && !isFullscreen()) {
    element = element || getParent();
    element.requestFullscreen = prefixed("requestFullscreen", element) || element.mozRequestFullScreen;
    element.requestFullscreen();
  }
}
function exitFullscreen() {
  if (hasFullscreenSupport && isFullscreen()) {
    globalThis.document.exitFullscreen();
  }
}
function getScreenOrientation() {
  const PORTRAIT = "portrait";
  const LANDSCAPE = "landscape";
  let screen2 = globalThis.screen;
  if (screenOrientation === true) {
    let orientation2 = prefixed("orientation", screen2);
    if (typeof orientation2 !== "undefined" && typeof orientation2.type === "string") {
      return orientation2.type;
    } else if (typeof orientation2 === "string") {
      return orientation2;
    }
  }
  if (typeof globalThis.orientation === "number") {
    return Math.abs(globalThis.orientation) === 90 ? LANDSCAPE : PORTRAIT;
  }
  return globalThis.outerWidth > globalThis.outerHeight ? LANDSCAPE : PORTRAIT;
}
function lockOrientation(orientation2) {
  let screen2 = globalThis.screen;
  if (typeof screen2 !== "undefined") {
    let _lockOrientation = prefixed("lockOrientation", screen2);
    if (typeof _lockOrientation !== "undefined") {
      return _lockOrientation(orientation2);
    }
  }
  return false;
}
function unlockOrientation() {
  let screen2 = globalThis.screen;
  if (typeof screen2 !== "undefined") {
    let _unlockOrientation = prefixed("unlockOrientation", screen2);
    if (typeof _unlockOrientation !== "undefined") {
      return _unlockOrientation();
    }
  }
  return false;
}
function isPortrait() {
  return getScreenOrientation().includes("portrait");
}
function isLandscape() {
  return getScreenOrientation().includes("landscape");
}
function getStorage(type = "local") {
  switch (type) {
    case "local":
      return save;
    default:
      throw new Error("storage type " + type + " not supported");
  }
}
function getParentElement(element) {
  let target = getElement(element);
  if (target.parentNode !== null) {
    target = target.parentNode;
  }
  return target;
}
function getElement(element) {
  let target = null;
  if (element !== "undefined") {
    if (typeof element === "string") {
      target = globalThis.document.getElementById(element);
    } else if (typeof element === "object" && element.nodeType === Node.ELEMENT_NODE) {
      target = element;
    }
  }
  if (!target) {
    target = globalThis.document.body;
  }
  return target;
}
function getElementBounds(element) {
  if (typeof element === "object" && element !== globalThis.document.body && typeof element.getBoundingClientRect !== "undefined") {
    return element.getBoundingClientRect();
  } else {
    domRect.width = domRect.right = globalThis.innerWidth;
    domRect.height = domRect.bottom = globalThis.innerHeight;
    return domRect;
  }
}
function getParentBounds(element) {
  return getElementBounds(getParentElement(element));
}
function isWebGLSupported(options) {
  if (WebGLSupport === -1) {
    let _supported = false;
    try {
      let canvas = globalThis.document.createElement("canvas");
      let ctxOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: options.failIfMajorPerformanceCaveat
      };
      _supported = !!(globalThis.WebGLRenderingContext && (canvas.getContext("webgl", ctxOptions) || canvas.getContext("experimental-webgl", ctxOptions)));
      WebGLSupport = _supported ? 1 : 0;
    } catch {
      WebGLSupport = 0;
    }
  }
  return WebGLSupport === 1;
}
function focus() {
  if (typeof globalThis.focus === "function") {
    globalThis.focus();
  }
}
function watchAccelerometer() {
  if (hasAccelerometer && !accelInitialized) {
    if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === "function") {
      DeviceOrientationEvent.requestPermission().then((response) => {
        if (response === "granted") {
          globalThis.addEventListener("devicemotion", onDeviceMotion, false);
          accelInitialized = true;
        }
      }).catch(console.error);
    } else {
      globalThis.addEventListener("devicemotion", onDeviceMotion, false);
      accelInitialized = true;
    }
  }
  return accelInitialized;
}
function unwatchAccelerometer() {
  if (accelInitialized) {
    globalThis.removeEventListener("devicemotion", onDeviceMotion, false);
    accelInitialized = false;
  }
}
function watchDeviceOrientation() {
  if (hasDeviceOrientation && !deviceOrientationInitialized) {
    if (typeof DeviceOrientationEvent.requestPermission === "function") {
      DeviceOrientationEvent.requestPermission().then((response) => {
        if (response === "granted") {
          globalThis.addEventListener("deviceorientation", onDeviceRotate, false);
          deviceOrientationInitialized = true;
        }
      }).catch(console.error);
    } else {
      globalThis.addEventListener("deviceorientation", onDeviceRotate, false);
      deviceOrientationInitialized = true;
    }
  }
  return deviceOrientationInitialized;
}
function unwatchDeviceOrientation() {
  if (deviceOrientationInitialized) {
    globalThis.removeEventListener("deviceorientation", onDeviceRotate, false);
    deviceOrientationInitialized = false;
  }
}
function vibrate(pattern) {
  if (typeof globalThis.navigator !== "undefined" && typeof globalThis.navigator.vibrate === "function") {
    globalThis.navigator.vibrate(pattern);
  }
}
function hasVideoFormat(codec) {
  let result = false;
  if (hasVideo === true) {
    if (typeof videoCodecs === "undefined") {
      const videoElement = globalThis.document.createElement("video");
      videoCodecs = {
        h264: videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""),
        h265: videoElement.canPlayType('video/mp4; codecs="hev1"').replace(/^no$/, ""),
        ogg: videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""),
        mp4: videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""),
        m4v: videoElement.canPlayType("video/x-m4v").replace(/^no$/, ""),
        webm: videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ""),
        vp9: videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ""),
        hls: videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")
      };
    }
    result = !!videoCodecs[codec];
  }
  return result;
}
var device = {
  __proto__: null,
  get accelerationX() {
    return accelerationX;
  },
  get accelerationY() {
    return accelerationY;
  },
  get accelerationZ() {
    return accelerationZ;
  },
  get alpha() {
    return alpha;
  },
  autoFocus,
  get beta() {
    return beta;
  },
  devicePixelRatio,
  enableSwipe,
  exitFullscreen,
  focus,
  get gamma() {
    return gamma;
  },
  getElement,
  getElementBounds,
  getParentBounds,
  getParentElement,
  getScreenOrientation,
  getStorage,
  hasAccelerometer,
  hasDeviceOrientation,
  hasFullscreenSupport,
  hasHTML5Audio,
  hasPointerLockSupport,
  hasVideo,
  hasVideoFormat,
  hasWebAudio,
  isFullscreen,
  isLandscape,
  isMobile,
  isPortrait,
  isWebGLSupported,
  language,
  localStorage,
  lockOrientation,
  maxTouchPoints,
  nativeBase64,
  offscreenCanvas,
  onDeviceRotate,
  onReady,
  pauseOnBlur,
  platform,
  pointerEvent,
  requestFullscreen,
  resumeOnFocus,
  screenOrientation,
  sound,
  stopOnBlur,
  touch,
  touchEvent,
  unlockOrientation,
  unwatchAccelerometer,
  unwatchDeviceOrientation,
  vibrate,
  watchAccelerometer,
  watchDeviceOrientation,
  wheel
};
var ApplicationSettings = {
  parent: void 0,
  canvas: void 0,
  renderer: 2,
  // AUTO
  autoScale: false,
  scale: 1,
  scaleMethod: "manual",
  scaleTarget: void 0,
  preferWebGL1: false,
  depthTest: "sorting",
  powerPreference: "default",
  transparent: false,
  antiAlias: false,
  consoleHeader: true,
  premultipliedAlpha: true,
  blendMode: "normal",
  physic: "builtin",
  failIfMajorPerformanceCaveat: true,
  subPixel: false,
  verbose: false,
  legacy: false
};
var CANVAS = 0;
var WEBGL = 1;
var AUTO = 2;
var renderer = null;
function init(width, height, options) {
  if (!initialized) {
    throw new Error("me.video.init() called before engine initialization.");
  }
  try {
    game.init(width, height, Object.assign(ApplicationSettings, options || {}));
  } catch (e) {
    console.log(e.message);
    return false;
  }
  renderer = game.renderer;
  globalThis.addEventListener(
    "resize",
    throttle(
      (e) => {
        emit(WINDOW_ONRESIZE, e);
      },
      100
    ),
    false
  );
  globalThis.addEventListener(
    "orientationchange",
    (e) => {
      emit(WINDOW_ONORIENTATION_CHANGE, e);
    },
    false
  );
  globalThis.addEventListener(
    "onmozorientationchange",
    (e) => {
      emit(WINDOW_ONORIENTATION_CHANGE, e);
    },
    false
  );
  if (screenOrientation === true) {
    globalThis.screen.orientation.onchange = function(e) {
      emit(WINDOW_ONORIENTATION_CHANGE, e);
    };
  }
  globalThis.addEventListener("scroll", throttle((e) => {
    emit(WINDOW_ONSCROLL, e);
  }, 100), false);
  emit(VIDEO_INIT, game.renderer);
  return true;
}
function createCanvas(width, height, returnOffscreenCanvas = false) {
  let _canvas;
  if (width === 0 || height === 0) {
    throw new Error("width or height was zero, Canvas could not be initialized !");
  }
  if (offscreenCanvas === true && returnOffscreenCanvas === true) {
    _canvas = new globalThis.OffscreenCanvas(0, 0);
    if (typeof _canvas.style === "undefined") {
      _canvas.style = {};
    }
  } else {
    _canvas = globalThis.document.createElement("canvas");
  }
  _canvas.width = width;
  _canvas.height = height;
  return _canvas;
}
function getParent() {
  return game.getParentElement();
}
var video = {
  __proto__: null,
  AUTO,
  CANVAS,
  WEBGL,
  createCanvas,
  getParent,
  init,
  get renderer() {
    return renderer;
  }
};
var _keyStatus = {};
var _keyLock = {};
var _keyLocked = {};
var _keyRefs = {};
var _preventDefaultForKeys = {};
var _keyBindings = {};
var keyDownEvent = function(e, keyCode, mouseButton) {
  keyCode = keyCode || e.keyCode || e.button;
  let action = _keyBindings[keyCode];
  emit(
    KEYDOWN,
    action,
    keyCode,
    action ? !_keyLocked[action] : true
  );
  if (action) {
    if (!_keyLocked[action]) {
      let trigger = typeof mouseButton !== "undefined" ? mouseButton : keyCode;
      if (!_keyRefs[action][trigger]) {
        _keyStatus[action]++;
        _keyRefs[action][trigger] = true;
      }
    }
    if (_preventDefaultForKeys[keyCode] && typeof e.preventDefault === "function") {
      return e.preventDefault();
    } else {
      return true;
    }
  }
  return true;
};
var keyUpEvent = function(e, keyCode, mouseButton) {
  keyCode = keyCode || e.keyCode || e.button;
  let action = _keyBindings[keyCode];
  emit(KEYUP, action, keyCode);
  if (action) {
    let trigger = typeof mouseButton !== "undefined" ? mouseButton : keyCode;
    _keyRefs[action][trigger] = void 0;
    if (_keyStatus[action] > 0) {
      _keyStatus[action]--;
    }
    _keyLocked[action] = false;
    if (_preventDefaultForKeys[keyCode] && typeof e.preventDefault === "function") {
      return e.preventDefault();
    } else {
      return true;
    }
  }
  return true;
};
var keyBoardEventTarget = null;
var KEY = {
  "BACKSPACE": 8,
  /** @memberof input.KEY */
  "TAB": 9,
  /** @memberof input.KEY */
  "ENTER": 13,
  /** @memberof input.KEY */
  "SHIFT": 16,
  /** @memberof input.KEY */
  "CTRL": 17,
  /** @memberof input.KEY */
  "ALT": 18,
  /** @memberof input.KEY */
  "PAUSE": 19,
  /** @memberof input.KEY */
  "CAPS_LOCK": 20,
  /** @memberof input.KEY */
  "ESC": 27,
  /** @memberof input.KEY */
  "SPACE": 32,
  /** @memberof input.KEY */
  "PAGE_UP": 33,
  /** @memberof input.KEY */
  "PAGE_DOWN": 34,
  /** @memberof input.KEY */
  "END": 35,
  /** @memberof input.KEY */
  "HOME": 36,
  /** @memberof input.KEY */
  "LEFT": 37,
  /** @memberof input.KEY */
  "UP": 38,
  /** @memberof input.KEY */
  "RIGHT": 39,
  /** @memberof input.KEY */
  "DOWN": 40,
  /** @memberof input.KEY */
  "PRINT_SCREEN": 42,
  /** @memberof input.KEY */
  "INSERT": 45,
  /** @memberof input.KEY */
  "DELETE": 46,
  /** @memberof input.KEY */
  "NUM0": 48,
  /** @memberof input.KEY */
  "NUM1": 49,
  /** @memberof input.KEY */
  "NUM2": 50,
  /** @memberof input.KEY */
  "NUM3": 51,
  /** @memberof input.KEY */
  "NUM4": 52,
  /** @memberof input.KEY */
  "NUM5": 53,
  /** @memberof input.KEY */
  "NUM6": 54,
  /** @memberof input.KEY */
  "NUM7": 55,
  /** @memberof input.KEY */
  "NUM8": 56,
  /** @memberof input.KEY */
  "NUM9": 57,
  /** @memberof input.KEY */
  "A": 65,
  /** @memberof input.KEY */
  "B": 66,
  /** @memberof input.KEY */
  "C": 67,
  /** @memberof input.KEY */
  "D": 68,
  /** @memberof input.KEY */
  "E": 69,
  /** @memberof input.KEY */
  "F": 70,
  /** @memberof input.KEY */
  "G": 71,
  /** @memberof input.KEY */
  "H": 72,
  /** @memberof input.KEY */
  "I": 73,
  /** @memberof input.KEY */
  "J": 74,
  /** @memberof input.KEY */
  "K": 75,
  /** @memberof input.KEY */
  "L": 76,
  /** @memberof input.KEY */
  "M": 77,
  /** @memberof input.KEY */
  "N": 78,
  /** @memberof input.KEY */
  "O": 79,
  /** @memberof input.KEY */
  "P": 80,
  /** @memberof input.KEY */
  "Q": 81,
  /** @memberof input.KEY */
  "R": 82,
  /** @memberof input.KEY */
  "S": 83,
  /** @memberof input.KEY */
  "T": 84,
  /** @memberof input.KEY */
  "U": 85,
  /** @memberof input.KEY */
  "V": 86,
  /** @memberof input.KEY */
  "W": 87,
  /** @memberof input.KEY */
  "X": 88,
  /** @memberof input.KEY */
  "Y": 89,
  /** @memberof input.KEY */
  "Z": 90,
  /** @memberof input.KEY */
  "WINDOW_KEY": 91,
  /** @memberof input.KEY */
  "NUMPAD0": 96,
  /** @memberof input.KEY */
  "NUMPAD1": 97,
  /** @memberof input.KEY */
  "NUMPAD2": 98,
  /** @memberof input.KEY */
  "NUMPAD3": 99,
  /** @memberof input.KEY */
  "NUMPAD4": 100,
  /** @memberof input.KEY */
  "NUMPAD5": 101,
  /** @memberof input.KEY */
  "NUMPAD6": 102,
  /** @memberof input.KEY */
  "NUMPAD7": 103,
  /** @memberof input.KEY */
  "NUMPAD8": 104,
  /** @memberof input.KEY */
  "NUMPAD9": 105,
  /** @memberof input.KEY */
  "MULTIPLY": 106,
  /** @memberof input.KEY */
  "ADD": 107,
  /** @memberof input.KEY */
  "SUBSTRACT": 109,
  /** @memberof input.KEY */
  "DECIMAL": 110,
  /** @memberof input.KEY */
  "DIVIDE": 111,
  /** @memberof input.KEY */
  "F1": 112,
  /** @memberof input.KEY */
  "F2": 113,
  /** @memberof input.KEY */
  "F3": 114,
  /** @memberof input.KEY */
  "F4": 115,
  /** @memberof input.KEY */
  "F5": 116,
  /** @memberof input.KEY */
  "F6": 117,
  /** @memberof input.KEY */
  "F7": 118,
  /** @memberof input.KEY */
  "F8": 119,
  /** @memberof input.KEY */
  "F9": 120,
  /** @memberof input.KEY */
  "F10": 121,
  /** @memberof input.KEY */
  "F11": 122,
  /** @memberof input.KEY */
  "F12": 123,
  /** @memberof input.KEY */
  "TILDE": 126,
  /** @memberof input.KEY */
  "NUM_LOCK": 144,
  /** @memberof input.KEY */
  "SCROLL_LOCK": 145,
  /** @memberof input.KEY */
  "SEMICOLON": 186,
  /** @memberof input.KEY */
  "PLUS": 187,
  /** @memberof input.KEY */
  "COMMA": 188,
  /** @memberof input.KEY */
  "MINUS": 189,
  /** @memberof input.KEY */
  "PERIOD": 190,
  /** @memberof input.KEY */
  "FORWAND_SLASH": 191,
  /** @memberof input.KEY */
  "GRAVE_ACCENT": 192,
  /** @memberof input.KEY */
  "OPEN_BRACKET": 219,
  /** @memberof input.KEY */
  "BACK_SLASH": 220,
  /** @memberof input.KEY */
  "CLOSE_BRACKET": 221,
  /** @memberof input.KEY */
  "SINGLE_QUOTE": 222
};
function initKeyboardEvent() {
  if (keyBoardEventTarget === null && isMobile$1 === false) {
    keyBoardEventTarget = globalThis;
    if (typeof keyBoardEventTarget.addEventListener === "function") {
      keyBoardEventTarget.addEventListener("keydown", keyDownEvent, false);
      keyBoardEventTarget.addEventListener("keyup", keyUpEvent, false);
    }
  }
}
function isKeyPressed(action) {
  if (_keyStatus[action] && !_keyLocked[action]) {
    if (_keyLock[action]) {
      _keyLocked[action] = true;
    }
    return true;
  }
  return false;
}
function keyStatus(action) {
  return _keyStatus[action] > 0;
}
function triggerKeyEvent(keycode, status, mouseButton) {
  if (status === true) {
    keyDownEvent({}, keycode, mouseButton);
  } else {
    keyUpEvent({}, keycode, mouseButton);
  }
}
function bindKey(keycode, action, lock, preventDefault$1 = preventDefault) {
  _keyBindings[keycode] = action;
  _preventDefaultForKeys[keycode] = preventDefault$1;
  _keyStatus[action] = 0;
  _keyLock[action] = lock ? lock : false;
  _keyLocked[action] = false;
  _keyRefs[action] = {};
}
function getBindingKey(keycode) {
  return _keyBindings[keycode];
}
function unlockKey(action) {
  _keyLocked[action] = false;
}
function unbindKey(keycode) {
  let keybinding = _keyBindings[keycode];
  _keyStatus[keybinding] = 0;
  _keyLock[keybinding] = false;
  _keyRefs[keybinding] = {};
  _keyBindings[keycode] = null;
  _preventDefaultForKeys[keycode] = null;
}
var tmpVec = new Vector2d();
var Pointer = class extends Bounds {
  /**
   * @ignore
   */
  constructor(x = 0, y = 0, w = 1, h = 1) {
    super();
    this.setMinMax(x, y, x + w, y + h);
    this.LEFT = 0;
    this.MIDDLE = 1;
    this.RIGHT = 2;
    this.event = void 0;
    this.type = void 0;
    this.button = 0;
    this.isPrimary = false;
    this.pageX = 0;
    this.pageY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.movementX = 0;
    this.movementY = 0;
    this.deltaMode = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.deltaZ = 0;
    this.gameX = 0;
    this.gameY = 0;
    this.gameScreenX = 0;
    this.gameScreenY = 0;
    this.gameWorldX = 0;
    this.gameWorldY = 0;
    this.gameLocalX = 0;
    this.gameLocalY = 0;
    this.pointerId = void 0;
    this.isNormalized = false;
    this.locked = false;
    this.bind = [0, 0, 0];
  }
  /**
   * initialize the Pointer object using the given Event Object
   * @name Pointer#set
   * @private
   * @param {Event} event - the original Event object
   * @param {number} [pageX=0] - the horizontal coordinate at which the event occurred, relative to the left edge of the entire document
   * @param {number} [pageY=0] - the vertical coordinate at which the event occurred, relative to the left edge of the entire document
   * @param {number} [clientX=0] - the horizontal coordinate within the application's client area at which the event occurred
   * @param {number} [clientY=0] - the vertical coordinate within the application's client area at which the event occurred
   * @param {number} [pointerId=1] - the Pointer, Touch or Mouse event Id (1)
   */
  setEvent(event2, pageX = 0, pageY = 0, clientX = 0, clientY = 0, pointerId = 1) {
    this.event = event2;
    this.pageX = pageX;
    this.pageY = pageY;
    this.clientX = clientX;
    this.clientY = clientY;
    globalToLocal(this.pageX, this.pageY, tmpVec);
    this.gameScreenX = this.x = tmpVec.x;
    this.gameScreenY = this.y = tmpVec.y;
    this.isNormalized = typeof globalThis.PointerEvent !== "undefined" && !(event2 instanceof globalThis.PointerEvent);
    this.locked = locked;
    this.movementX = event2.movementX || 0;
    this.movementY = event2.movementY || 0;
    if (event2.type === "wheel") {
      this.deltaMode = event2.deltaMode || 0;
      this.deltaX = event2.deltaX || 0;
      this.deltaY = event2.deltaY || 0;
      this.deltaZ = event2.deltaZ || 0;
    } else {
      this.deltaMode = 0;
      this.deltaX = 0;
      this.deltaY = 0;
      this.deltaZ = 0;
    }
    this.pointerId = pointerId;
    this.isPrimary = typeof event2.isPrimary !== "undefined" ? event2.isPrimary : true;
    this.button = event2.button || 0;
    this.type = event2.type;
    if (typeof game.viewport !== "undefined") {
      game.viewport.localToWorld(this.gameScreenX, this.gameScreenY, tmpVec);
    }
    this.gameWorldX = tmpVec.x;
    this.gameWorldY = tmpVec.y;
    if (this.isNormalized === false) {
      this.width = event2.width || 1;
      this.height = event2.height || 1;
    } else if (typeof event2.radiusX === "number") {
      this.width = event2.radiusX * 2 || 1;
      this.height = event2.radiusY * 2 || 1;
    } else {
      this.width = this.height = 1;
    }
  }
};
var T_POINTERS = [];
var eventHandlers = /* @__PURE__ */ new Map();
var currentPointer;
var pointerInitialized = false;
var lastTimeStamp = 0;
var activeEventList = [];
var WHEEL = ["wheel"];
var POINTER_MOVE = ["pointermove", "mousemove", "touchmove"];
var POINTER_DOWN = ["pointerdown", "mousedown", "touchstart"];
var POINTER_UP = ["pointerup", "mouseup", "touchend"];
var POINTER_CANCEL = ["pointercancel", "mousecancel", "touchcancel"];
var POINTER_ENTER = ["pointerenter", "mouseenter", "touchenter"];
var POINTER_OVER = ["pointerover", "mouseover", "touchover"];
var POINTER_LEAVE = ["pointerleave", "mouseleave", "touchleave"];
var pointerEventList = [
  WHEEL[0],
  POINTER_MOVE[0],
  POINTER_DOWN[0],
  POINTER_UP[0],
  POINTER_CANCEL[0],
  POINTER_ENTER[0],
  POINTER_OVER[0],
  POINTER_LEAVE[0]
];
var mouseEventList = [
  WHEEL[0],
  POINTER_MOVE[1],
  POINTER_DOWN[1],
  POINTER_UP[1],
  POINTER_CANCEL[1],
  POINTER_ENTER[1],
  POINTER_OVER[1],
  POINTER_LEAVE[1]
];
var touchEventList = [
  POINTER_MOVE[2],
  POINTER_DOWN[2],
  POINTER_UP[2],
  POINTER_CANCEL[2],
  POINTER_ENTER[2],
  POINTER_OVER[2],
  POINTER_LEAVE[2]
];
var pointerEventMap = {
  wheel: WHEEL,
  pointermove: POINTER_MOVE,
  pointerdown: POINTER_DOWN,
  pointerup: POINTER_UP,
  pointercancel: POINTER_CANCEL,
  pointerenter: POINTER_ENTER,
  pointerover: POINTER_OVER,
  pointerleave: POINTER_LEAVE
};
var normalizedEvents = [];
function registerEventListener(eventList, callback) {
  for (let x = 0; x < eventList.length; x++) {
    if (POINTER_MOVE.indexOf(eventList[x]) === -1) {
      pointerEventTarget.addEventListener(eventList[x], callback, { passive: preventDefault === false });
    }
  }
}
function enablePointerEvent() {
  if (!pointerInitialized) {
    currentPointer = new Rect(0, 0, 1, 1);
    for (let v = 0; v < maxTouchPoints; v++) {
      T_POINTERS.push(new Pointer());
    }
    if (pointerEventTarget === null) {
      pointerEventTarget = renderer.getCanvas();
    }
    if (pointerEvent) {
      activeEventList = pointerEventList;
    } else {
      activeEventList = mouseEventList;
    }
    if (touch && !pointerEvent) {
      activeEventList = activeEventList.concat(touchEventList);
    }
    registerEventListener(activeEventList, onPointerEvent);
    if (typeof throttlingInterval === "undefined") {
      throttlingInterval = ~~(1e3 / timer.maxfps);
    }
    if (autoFocus === true) {
      focus();
      pointerEventTarget.addEventListener(
        activeEventList[2],
        // MOUSE/POINTER DOWN
        () => {
          focus();
        },
        { passive: preventDefault === false }
      );
    }
    let events = findAllActiveEvents(activeEventList, POINTER_MOVE);
    if (throttlingInterval < 17) {
      for (let i = 0; i < events.length; i++) {
        if (activeEventList.indexOf(events[i]) !== -1) {
          pointerEventTarget.addEventListener(
            events[i],
            onMoveEvent,
            { passive: true }
            // do not preventDefault on Move events
          );
        }
      }
    } else {
      for (let i = 0; i < events.length; i++) {
        if (activeEventList.indexOf(events[i]) !== -1) {
          pointerEventTarget.addEventListener(
            events[i],
            throttle(
              onMoveEvent,
              throttlingInterval,
              false
            ),
            { passive: true }
            // do not preventDefault on Move events
          );
        }
      }
    }
    setTouchAction(pointerEventTarget);
    if (hasPointerLockSupport) {
      globalThis.document.addEventListener("pointerlockchange", () => {
        locked = globalThis.document.pointerLockElement === game.getParentElement();
        emit(POINTERLOCKCHANGE, locked);
      }, true);
    }
    pointerInitialized = true;
  }
}
function findActiveEvent(activeEventList2, eventTypes) {
  for (let i = 0; i < eventTypes.length; i++) {
    const event2 = activeEventList2.indexOf(eventTypes[i]);
    if (event2 !== -1) {
      return eventTypes[i];
    }
  }
}
function findAllActiveEvents(activeEventList2, eventTypes) {
  let events = [];
  for (let i = 0; i < eventTypes.length; i++) {
    const event2 = activeEventList2.indexOf(eventTypes[i]);
    if (event2 !== -1) {
      events.push(eventTypes[i]);
    }
  }
  return events;
}
function triggerEvent(handlers, type, pointer2, pointerId) {
  let callback;
  if (handlers.callbacks[type]) {
    handlers.pointerId = pointerId;
    for (let i = handlers.callbacks[type].length - 1; i >= 0 && (callback = handlers.callbacks[type][i]); i--) {
      if (callback(pointer2) === false) {
        return true;
      }
    }
  }
  return false;
}
function dispatchEvent(normalizedEvents2) {
  let handled = false;
  while (normalizedEvents2.length > 0) {
    let pointer2 = normalizedEvents2.pop();
    T_POINTERS.push(pointer2);
    if (pointer2.isNormalized === true && typeof pointer2.event.timeStamp !== "undefined") {
      if (pointer2.event.timeStamp < lastTimeStamp) {
        continue;
      }
      lastTimeStamp = pointer2.event.timeStamp;
    }
    currentPointer.setShape(
      pointer2.gameWorldX,
      pointer2.gameWorldY,
      pointer2.width,
      pointer2.height
    );
    if (POINTER_MOVE.includes(pointer2.type)) {
      pointer2.gameX = pointer2.gameLocalX = pointer2.gameScreenX;
      pointer2.gameY = pointer2.gameLocalY = pointer2.gameScreenY;
      emit(POINTERMOVE, pointer2);
    }
    let candidates = game.world.broadphase.retrieve(currentPointer, game.world._sortReverseZ);
    candidates = candidates.concat([game.viewport]);
    for (let c = candidates.length, candidate; c--, candidate = candidates[c]; ) {
      if (eventHandlers.has(candidate) && candidate.isKinematic !== true) {
        const handlers = eventHandlers.get(candidate);
        const region = handlers.region;
        const ancestor = region.ancestor;
        const bounds = region.getBounds();
        let eventInBounds = false;
        if (region.isFloating === true) {
          pointer2.gameX = pointer2.gameLocalX = pointer2.gameScreenX;
          pointer2.gameY = pointer2.gameLocalY = pointer2.gameScreenY;
        } else {
          pointer2.gameX = pointer2.gameLocalX = pointer2.gameWorldX;
          pointer2.gameY = pointer2.gameLocalY = pointer2.gameWorldY;
        }
        if (typeof ancestor !== "undefined") {
          let parentBounds = ancestor.getBounds();
          pointer2.gameLocalX = pointer2.gameX - parentBounds.x;
          pointer2.gameLocalY = pointer2.gameY - parentBounds.y;
        }
        eventInBounds = bounds.contains(pointer2.gameX, pointer2.gameY);
        switch (pointer2.type) {
          case POINTER_MOVE[0]:
          case POINTER_MOVE[1]:
          case POINTER_MOVE[2]:
          case POINTER_MOVE[3]:
            if (handlers.pointerId === pointer2.pointerId && !eventInBounds) {
              if (triggerEvent(handlers, findActiveEvent(activeEventList, POINTER_LEAVE), pointer2, null)) {
                handled = true;
                break;
              }
            } else if (handlers.pointerId === null && eventInBounds) {
              if (triggerEvent(handlers, findActiveEvent(activeEventList, POINTER_ENTER), pointer2, pointer2.pointerId)) {
                handled = true;
                break;
              }
            }
            if (eventInBounds && triggerEvent(handlers, pointer2.type, pointer2, pointer2.pointerId)) {
              handled = true;
              break;
            }
            break;
          case POINTER_UP[0]:
          case POINTER_UP[1]:
          case POINTER_UP[2]:
          case POINTER_UP[3]:
            if (handlers.pointerId === pointer2.pointerId && eventInBounds) {
              if (triggerEvent(handlers, pointer2.type, pointer2, null)) {
                handled = true;
                break;
              }
            }
            break;
          case POINTER_CANCEL[0]:
          case POINTER_CANCEL[1]:
          case POINTER_CANCEL[2]:
          case POINTER_CANCEL[3]:
            if (handlers.pointerId === pointer2.pointerId) {
              if (triggerEvent(handlers, pointer2.type, pointer2, null)) {
                handled = true;
                break;
              }
            }
            break;
          default:
            if (eventInBounds) {
              if (triggerEvent(handlers, pointer2.type, pointer2, pointer2.pointerId)) {
                handled = true;
                break;
              }
            }
            break;
        }
      }
      if (handled === true) {
        break;
      }
    }
  }
  return handled;
}
function normalizeEvent(originalEvent) {
  let _pointer;
  if (touchEvent && originalEvent.changedTouches) {
    for (let i = 0, l = originalEvent.changedTouches.length; i < l; i++) {
      const touchEvent2 = originalEvent.changedTouches[i];
      _pointer = T_POINTERS.pop();
      _pointer.setEvent(
        originalEvent,
        touchEvent2.pageX,
        touchEvent2.pageY,
        touchEvent2.clientX,
        touchEvent2.clientY,
        touchEvent2.identifier
      );
      normalizedEvents.push(_pointer);
    }
  } else {
    _pointer = T_POINTERS.pop();
    _pointer.setEvent(
      originalEvent,
      originalEvent.pageX,
      originalEvent.pageY,
      originalEvent.clientX,
      originalEvent.clientY,
      originalEvent.pointerId
    );
    normalizedEvents.push(_pointer);
  }
  if (originalEvent.isPrimary === false) {
    return normalizedEvents;
  }
  normalizedEvents[0].isPrimary = true;
  Object.assign(pointer, normalizedEvents[0]);
  return normalizedEvents;
}
function onMoveEvent(e) {
  dispatchEvent(normalizeEvent(e));
}
function onPointerEvent(e) {
  normalizeEvent(e);
  let button = normalizedEvents[0].button;
  if (dispatchEvent(normalizedEvents) || e.type === "wheel") {
    if (preventDefault === true) {
      e.preventDefault();
    }
  }
  let keycode = pointer.bind[button];
  if (keycode) {
    triggerKeyEvent(keycode, POINTER_DOWN.includes(e.type), button + 1);
  }
}
var pointerEventTarget = null;
var pointer = new Pointer(0, 0, 1, 1);
var locked = false;
var throttlingInterval;
function hasActiveEvents() {
  return normalizedEvents.length > 0;
}
function hasRegisteredEvents() {
  return eventHandlers.size > 0;
}
function globalToLocal(x, y, v) {
  v = v || pool.pull("Vector2d");
  let rect = getElementBounds(renderer.getCanvas());
  let pixelRatio = globalThis.devicePixelRatio || 1;
  x -= rect.left + (globalThis.pageXOffset || 0);
  y -= rect.top + (globalThis.pageYOffset || 0);
  let scale2 = renderer.scaleRatio;
  if (scale2.x !== 1 || scale2.y !== 1) {
    x /= scale2.x;
    y /= scale2.y;
  }
  return v.set(x * pixelRatio, y * pixelRatio);
}
function setTouchAction(element, value) {
  element.style["touch-action"] = value || "none";
}
function bindPointer() {
  let button = arguments.length < 2 ? pointer.LEFT : arguments[0];
  let keyCode = arguments.length < 2 ? arguments[0] : arguments[1];
  enablePointerEvent();
  if (!getBindingKey(keyCode)) {
    throw new Error("no action defined for keycode " + keyCode);
  }
  pointer.bind[button] = keyCode;
}
function unbindPointer(button) {
  pointer.bind[typeof button === "undefined" ? pointer.LEFT : button] = null;
}
function registerPointerEvent(eventType, region, callback) {
  enablePointerEvent();
  if (pointerEventList.indexOf(eventType) === -1) {
    throw new Error("invalid event type : " + eventType);
  }
  if (typeof region === "undefined") {
    throw new Error("registerPointerEvent: region for " + toString(region) + " event is undefined ");
  }
  let eventTypes = findAllActiveEvents(activeEventList, pointerEventMap[eventType]);
  if (!eventHandlers.has(region)) {
    eventHandlers.set(region, {
      region,
      callbacks: {},
      pointerId: null
    });
  }
  let handlers = eventHandlers.get(region);
  for (let i = 0; i < eventTypes.length; i++) {
    const eventType2 = eventTypes[i];
    if (handlers.callbacks[eventType2]) {
      handlers.callbacks[eventType2].push(callback);
    } else {
      handlers.callbacks[eventType2] = [callback];
    }
  }
}
function releasePointerEvent(eventType, region, callback) {
  if (pointerEventList.indexOf(eventType) === -1) {
    throw new Error("invalid event type : " + eventType);
  }
  let eventTypes = findAllActiveEvents(activeEventList, pointerEventMap[eventType]);
  let handlers = eventHandlers.get(region);
  if (typeof handlers !== "undefined") {
    for (let i = 0; i < eventTypes.length; i++) {
      const eventType2 = eventTypes[i];
      if (handlers.callbacks[eventType2]) {
        if (typeof callback !== "undefined") {
          remove(handlers.callbacks[eventType2], callback);
        } else {
          while (handlers.callbacks[eventType2].length > 0) {
            handlers.callbacks[eventType2].pop();
          }
        }
        if (handlers.callbacks[eventType2].length === 0) {
          delete handlers.callbacks[eventType2];
        }
      }
    }
    if (Object.keys(handlers.callbacks).length === 0) {
      eventHandlers.delete(region);
    }
  }
}
function releaseAllPointerEvents(region) {
  if (eventHandlers.has(region)) {
    for (let i = 0; i < pointerEventList.length; i++) {
      releasePointerEvent(pointerEventList[i], region);
    }
  }
}
function requestPointerLock() {
  if (hasPointerLockSupport) {
    let element = game.getParentElement();
    element.requestPointerLock();
    return true;
  }
  return false;
}
function exitPointerLock() {
  if (hasPointerLockSupport) {
    globalThis.document.exitPointerLock();
    return true;
  }
  return false;
}
var deadzone = 0.1;
function wiredXbox360NormalizeFn(value, axis, button) {
  if (button === this.GAMEPAD.BUTTONS.L2 || button === this.GAMEPAD.BUTTONS.R2) {
    return (value + 1) / 2;
  }
  return value;
}
function ouyaNormalizeFn(value, axis, button) {
  if (value > 0) {
    if (button === this.GAMEPAD.BUTTONS.L2) {
      value = Math.max(0, value - 2e4) / 111070;
    } else {
      value = (value - 1) / 131070;
    }
  } else {
    value = (65536 + value) / 131070 + 0.5;
  }
  return value;
}
var vendorProductRE = /^([0-9a-f]{1,4})-([0-9a-f]{1,4})-/i;
var leadingZeroRE = /^0+/;
function addMapping(id2, mapping) {
  const expanded_id = id2.replace(
    vendorProductRE,
    (_, a, b) => "000".slice(a.length - 1) + a + "-" + "000".slice(b.length - 1) + b + "-"
  );
  const sparse_id = id2.replace(
    vendorProductRE,
    (_, a, b) => a.replace(leadingZeroRE, "") + "-" + b.replace(leadingZeroRE, "") + "-"
  );
  mapping.analog = mapping.analog || mapping.buttons.map(() => -1);
  mapping.normalize_fn = mapping.normalize_fn || function(value) {
    return value;
  };
  remap.set(expanded_id, mapping);
  remap.set(sparse_id, mapping);
}
var bindings = {};
var remap = /* @__PURE__ */ new Map();
var updateEventHandler;
[
  // Firefox mappings
  [
    "45e-28e-Xbox 360 Wired Controller",
    {
      "axes": [0, 1, 3, 4],
      "buttons": [11, 12, 13, 14, 8, 9, -1, -1, 5, 4, 6, 7, 0, 1, 2, 3, 10],
      "analog": [-1, -1, -1, -1, -1, -1, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      "normalize_fn": wiredXbox360NormalizeFn
    }
  ],
  [
    "54c-268-PLAYSTATION(R)3 Controller",
    {
      "axes": [0, 1, 2, 3],
      "buttons": [14, 13, 15, 12, 10, 11, 8, 9, 0, 3, 1, 2, 4, 6, 7, 5, 16]
    }
  ],
  [
    "54c-5c4-Wireless Controller",
    // PS4 Controller
    {
      "axes": [0, 1, 2, 3],
      "buttons": [1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15, 16, 17, 12, 13]
    }
  ],
  [
    "2836-1-OUYA Game Controller",
    {
      "axes": [0, 3, 7, 9],
      "buttons": [3, 6, 4, 5, 7, 8, 15, 16, -1, -1, 9, 10, 11, 12, 13, 14, -1],
      "analog": [-1, -1, -1, -1, -1, -1, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      "normalize_fn": ouyaNormalizeFn
    }
  ],
  // Chrome mappings
  [
    "OUYA Game Controller (Vendor: 2836 Product: 0001)",
    {
      "axes": [0, 1, 3, 4],
      "buttons": [0, 3, 1, 2, 4, 5, 12, 13, -1, -1, 6, 7, 8, 9, 10, 11, -1],
      "analog": [-1, -1, -1, -1, -1, -1, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      "normalize_fn": ouyaNormalizeFn
    }
  ]
].forEach((value) => {
  addMapping(value[0], value[1]);
});
var updateGamepads = function() {
  let gamepads = navigator.getGamepads();
  Object.keys(bindings).forEach((index2) => {
    let gamepad = gamepads[index2];
    if (!gamepad) {
      return;
    }
    let mapping = null;
    if (gamepad.mapping !== "standard") {
      mapping = remap.get(gamepad.id);
    }
    let binding = bindings[index2];
    Object.keys(binding.buttons).forEach((button) => {
      let last = binding.buttons[button];
      let mapped_button = button;
      let mapped_axis = -1;
      if (mapping) {
        mapped_button = mapping.buttons[button];
        mapped_axis = mapping.analog[button];
        if (mapped_button < 0 && mapped_axis < 0) {
          return;
        }
      }
      let current = gamepad.buttons[mapped_button] || {};
      if (mapping) {
        if (mapped_axis >= 0) {
          let value = mapping.normalize_fn(gamepad.axes[mapped_axis], -1, +button);
          current = {
            "value": value,
            "pressed": current.pressed || Math.abs(value) >= deadzone
          };
        }
      }
      emit(GAMEPAD_UPDATE, index2, "buttons", +button, current);
      if (!last.pressed && current.pressed) {
        triggerKeyEvent(last.keyCode, true, mapped_button + 256);
      } else if (last.pressed && !current.pressed) {
        triggerKeyEvent(last.keyCode, false, mapped_button + 256);
      }
      last.value = current.value;
      last.pressed = current.pressed;
    });
    Object.keys(binding.axes).forEach((axis) => {
      let last = binding.axes[axis];
      let mapped_axis = axis;
      if (mapping) {
        mapped_axis = mapping.axes[axis];
        if (mapped_axis < 0) {
          return;
        }
      }
      let value = gamepad.axes[mapped_axis];
      if (typeof value === "undefined") {
        return;
      }
      if (mapping) {
        value = mapping.normalize_fn(value, +axis, -1);
      }
      let range2 = Math.sign(value) || 1;
      if (last[range2].keyCode === 0) {
        return;
      }
      let pressed = Math.abs(value) >= deadzone + Math.abs(last[range2].threshold);
      emit(GAMEPAD_UPDATE, index2, "axes", +axis, value);
      if (!last[range2].pressed && pressed) {
        if (last[-range2].pressed) {
          triggerKeyEvent(last[-range2].keyCode, false, mapped_axis + 256);
          last[-range2].value = 0;
          last[-range2].pressed = false;
        }
        triggerKeyEvent(last[range2].keyCode, true, mapped_axis + 256);
      } else if ((last[range2].pressed || last[-range2].pressed) && !pressed) {
        range2 = last[range2].pressed ? range2 : -range2;
        triggerKeyEvent(last[range2].keyCode, false, mapped_axis + 256);
      }
      last[range2].value = value;
      last[range2].pressed = pressed;
    });
  });
};
if (globalThis.navigator && typeof globalThis.navigator.getGamepads === "function") {
  globalThis.addEventListener("gamepadconnected", (e) => {
    emit(GAMEPAD_CONNECTED, e.gamepad);
  }, false);
  globalThis.addEventListener("gamepaddisconnected", (e) => {
    emit(GAMEPAD_DISCONNECTED, e.gamepad);
  }, false);
}
var GAMEPAD = {
  /**
   * Standard gamepad mapping information for axes<br>
   * <ul>
   *   <li>Left control stick: <code>LX</code> (horizontal), <code>LY</code> (vertical)</li>
   *   <li>Right control stick: <code>RX</code> (horizontal), <code>RY</code> (vertical)</li>
   *   <li>Extras: <code>EXTRA_1</code>, <code>EXTRA_2</code>, <code>EXTRA_3</code>, <code>EXTRA_4</code></li>
   * </ul>
   * @public
   * @name AXES
   * @enum {number}
   * @memberof input.GAMEPAD
   * @see https://w3c.github.io/gamepad/#remapping
   */
  "AXES": {
    "LX": 0,
    "LY": 1,
    "RX": 2,
    "RY": 3,
    "EXTRA_1": 4,
    "EXTRA_2": 5,
    "EXTRA_3": 6,
    "EXTRA_4": 7
  },
  /**
   * Standard gamepad mapping information for buttons<br>
   * <ul>
   *   <li>Face buttons: <code>FACE_1</code>, <code>FACE_2</code>, <code>FACE_3</code>, <code>FACE_4</code></li>
   *   <li>D-Pad: <code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code></li>
   *   <li>Shoulder buttons: <code>L1</code>, <code>L2</code>, <code>R1</code>, <code>R2</code></li>
   *   <li>Analog stick (clicks): <code>L3</code>, <code>R3</code></li>
   *   <li>Navigation: <code>SELECT</code> (<code>BACK</code>), <code>START</code> (<code>FORWARD</code>), <code>HOME</code></li>
   *   <li>Extras: <code>EXTRA_1</code>, <code>EXTRA_2</code>, <code>EXTRA_3</code>, <code>EXTRA_4</code></li>
   * </ul>
   * @public
   * @name BUTTONS
   * @enum {number}
   * @memberof input.GAMEPAD
   * @see https://w3c.github.io/gamepad/#remapping
   */
  "BUTTONS": {
    "FACE_1": 0,
    "FACE_2": 1,
    "FACE_3": 2,
    "FACE_4": 3,
    "L1": 4,
    "R1": 5,
    "L2": 6,
    "R2": 7,
    "SELECT": 8,
    "BACK": 8,
    "START": 9,
    "FORWARD": 9,
    "L3": 10,
    "R3": 11,
    "UP": 12,
    "DOWN": 13,
    "LEFT": 14,
    "RIGHT": 15,
    "HOME": 16,
    "EXTRA_1": 17,
    "EXTRA_2": 18,
    "EXTRA_3": 19,
    "EXTRA_4": 20
  }
};
function bindGamepad(index2, button, keyCode) {
  if (!getBindingKey(keyCode)) {
    throw new Error("no action defined for keycode " + keyCode);
  }
  if (typeof updateEventHandler === "undefined" && typeof navigator.getGamepads === "function") {
    updateEventHandler = on(GAME_BEFORE_UPDATE, updateGamepads);
  }
  if (!bindings[index2]) {
    bindings[index2] = {
      "axes": {},
      "buttons": {}
    };
  }
  let mapping = {
    "keyCode": keyCode,
    "value": 0,
    "pressed": false,
    "threshold": button.threshold
    // can be undefined
  };
  let binding = bindings[index2][button.type];
  if (button.type === "buttons") {
    binding[button.code] = mapping;
  } else if (button.type === "axes") {
    let range2 = Math.sign(button.threshold) || 1;
    if (!binding[button.code]) {
      binding[button.code] = {};
    }
    let axes = binding[button.code];
    axes[range2] = mapping;
    if (!axes[-range2]) {
      axes[-range2] = {
        "keyCode": 0,
        "value": 0,
        "pressed": false,
        "threshold": -range2
      };
    }
  }
}
function unbindGamepad(index2, button) {
  if (!bindings[index2]) {
    throw new Error("no bindings for gamepad " + index2);
  }
  bindings[index2].buttons[button] = {};
}
function setGamepadDeadzone(value) {
  deadzone = value;
}
var setGamepadMapping = addMapping;
var preventDefault = true;
var input = {
  __proto__: null,
  GAMEPAD,
  KEY,
  bindGamepad,
  bindKey,
  bindPointer,
  exitPointerLock,
  getBindingKey,
  globalToLocal,
  hasActiveEvents,
  hasRegisteredEvents,
  initKeyboardEvent,
  isKeyPressed,
  get keyBoardEventTarget() {
    return keyBoardEventTarget;
  },
  keyStatus,
  get locked() {
    return locked;
  },
  pointer,
  get pointerEventTarget() {
    return pointerEventTarget;
  },
  preventDefault,
  registerPointerEvent,
  releaseAllPointerEvents,
  releasePointerEvent,
  requestPointerLock,
  setGamepadDeadzone,
  setGamepadMapping,
  setTouchAction,
  get throttlingInterval() {
    return throttlingInterval;
  },
  triggerKeyEvent,
  unbindGamepad,
  unbindKey,
  unbindPointer,
  unlockKey
};
var fnHash = {
  "bool": "1i",
  "int": "1i",
  "float": "1f",
  "vec2": "2fv",
  "vec3": "3fv",
  "vec4": "4fv",
  "bvec2": "2iv",
  "bvec3": "3iv",
  "bvec4": "4iv",
  "ivec2": "2iv",
  "ivec3": "3iv",
  "ivec4": "4iv",
  "mat2": "Matrix2fv",
  "mat3": "Matrix3fv",
  "mat4": "Matrix4fv",
  "sampler2D": "1i"
};
function extractUniforms(gl, shader) {
  let uniforms = {}, uniRx = /uniform\s+(\w+)\s+(\w+)/g, uniformsData = {}, descriptor = {}, locations = {}, match2;
  [shader.vertex, shader.fragment].forEach((shader2) => {
    while (match2 = uniRx.exec(shader2)) {
      uniformsData[match2[2]] = match2[1];
    }
  });
  Object.keys(uniformsData).forEach((name) => {
    let type = uniformsData[name];
    locations[name] = gl.getUniformLocation(shader.program, name);
    descriptor[name] = {
      "get": /* @__PURE__ */ function(name2) {
        return function() {
          return locations[name2];
        };
      }(name),
      "set": function(name2, type2, fn) {
        if (type2.indexOf("mat") === 0) {
          return function(val) {
            gl[fn](locations[name2], false, val);
          };
        } else {
          return function(val) {
            let fnv = fn;
            if (val.length && fn.slice(-1) !== "v") {
              fnv += "v";
            }
            gl[fnv](locations[name2], val);
          };
        }
      }(name, type, "uniform" + fnHash[type])
    };
  });
  Object.defineProperties(uniforms, descriptor);
  return uniforms;
}
function extractAttributes(gl, shader) {
  let attributes = {}, attrRx = /attribute\s+\w+\s+(\w+)/g, match2, i = 0;
  while (match2 = attrRx.exec(shader.vertex)) {
    attributes[match2[1]] = i++;
  }
  return attributes;
}
function compileShader(gl, type, source) {
  let shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}
function compileProgram(gl, vertex, fragment, attributes) {
  let vertShader = compileShader(gl, gl.VERTEX_SHADER, vertex);
  let fragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragment);
  let program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  for (let location in attributes) {
    gl.bindAttribLocation(program, attributes[location], location);
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    let error_msg = "Error initializing Shader " + this + "\ngl.VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\ngl.getError()" + gl.getError() + "\ngl.getProgramInfoLog()" + gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    program = null;
    throw new Error(error_msg);
  }
  gl.useProgram(program);
  gl.deleteShader(vertShader);
  gl.deleteShader(fragShader);
  return program;
}
function setPrecision(src, precision) {
  if (src.substring(0, 9) !== "precision") {
    return "precision " + precision + " float;" + src;
  }
  return src;
}
function getMaxShaderPrecision(gl) {
  if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
    return "highp";
  }
  if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
    return "mediump";
  }
  return "lowp";
}
function minify(src) {
  src = src.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1");
  src = src.replace(/(\\n\s+)|(\s+\\n)/g, "");
  src = src.replace(/(\\r|\\n)+/g, "");
  src = src.replace(/\s*([;,[\](){}\\\/\-+*|^&!=<>?~%])\s*/g, "$1");
  return src;
}
var GLShader = class {
  /**
   * @param {WebGLRenderingContext} gl - the current WebGL rendering context
   * @param {string} vertex - a string containing the GLSL source code to set
   * @param {string} fragment - a string containing the GLSL source code to set
   * @param {string} [precision=auto detected] - float precision ('lowp', 'mediump' or 'highp').
   * @see https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders
   * @example
   * // create a basic shader
   * let myShader = new me.GLShader(
   *    // WebGL rendering context
   *    gl,
   *    // vertex shader
   *    [
   *        "void main() {",
   *        "    gl_Position = doMathToMakeClipspaceCoordinates;",
   *        "}"
   *    ].join("\n"),
   *    // fragment shader
   *    [
   *        "void main() {",
   *        "    gl_FragColor = doMathToMakeAColor;",
   *        "}"
   *    ].join("\n")
   *  )
   * // use the shader
   * myShader.bind();
   */
  constructor(gl, vertex, fragment, precision) {
    this.gl = gl;
    this.vertex = setPrecision(minify(vertex), precision || getMaxShaderPrecision(this.gl));
    this.fragment = setPrecision(minify(fragment), precision || getMaxShaderPrecision(this.gl));
    this.attributes = extractAttributes(this.gl, this);
    this.program = compileProgram(this.gl, this.vertex, this.fragment, this.attributes);
    this.uniforms = extractUniforms(this.gl, this);
    on(ONCONTEXT_LOST, this.destroy, this);
  }
  /**
   * Installs this shader program as part of current rendering state
   */
  bind() {
    this.gl.useProgram(this.program);
  }
  /**
   * returns the location of an attribute variable in this shader program
   * @param {string} name - the name of the attribute variable whose location to get.
   * @returns {GLint} number indicating the location of the variable name if found. Returns -1 otherwise
   */
  getAttribLocation(name) {
    let attr = this.attributes[name];
    if (typeof attr !== "undefined") {
      return attr;
    } else {
      return -1;
    }
  }
  /**
   * Set the uniform to the given value
   * @param {string} name - the uniform name
   * @param {object|Float32Array} value - the value to assign to that uniform
   * @example
   * myShader.setUniform("uProjectionMatrix", this.projectionMatrix);
   */
  setUniform(name, value) {
    let uniforms = this.uniforms;
    if (typeof uniforms[name] !== "undefined") {
      if (typeof value === "object" && typeof value.toArray === "function") {
        uniforms[name] = value.toArray();
      } else {
        uniforms[name] = value;
      }
    } else {
      throw new Error("undefined (" + name + ") uniform for shader " + this);
    }
  }
  /**
   * activate the given vertex attribute for this shader
   * @param {WebGLRenderingContext} gl - the current WebGL rendering context
   * @param {object[]} attributes - an array of vertex attributes
   * @param {number} vertexByteSize - the size of a single vertex in bytes
   */
  setVertexAttributes(gl, attributes, vertexByteSize) {
    for (let index2 = 0; index2 < attributes.length; ++index2) {
      let element = attributes[index2];
      let location = this.getAttribLocation(element.name);
      if (location !== -1) {
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, element.size, element.type, element.normalized, vertexByteSize, element.offset);
      } else {
        gl.disableVertexAttribArray(index2);
      }
    }
  }
  /**
   * destroy this shader objects resources (program, attributes, uniforms)
   */
  destroy() {
    this.uniforms = null;
    this.attributes = null;
    this.gl.deleteProgram(this.program);
    this.vertex = null;
    this.fragment = null;
  }
};
var Renderable = class _Renderable extends Rect {
  /**
   * @param {number} x - position of the renderable object (accessible through inherited pos.x property)
   * @param {number} y - position of the renderable object (accessible through inherited pos.y property)
   * @param {number} width - object width
   * @param {number} height - object height
   */
  constructor(x, y, width, height) {
    super(x, y, width, height);
    if (this.pos instanceof ObservableVector3d) {
      this.pos.setMuted(x, y, 0).setCallback(this.updateBoundsPos, this);
    } else {
      this.pos = pool.pull("ObservableVector3d", x, y, 0, { onUpdate: this.updateBoundsPos, scope: this });
    }
    if (this.anchorPoint instanceof ObservableVector2d) {
      this.anchorPoint.setMuted(0.5, 0.5).setCallback(this.onAnchorUpdate, this);
    } else {
      this.anchorPoint = pool.pull("ObservableVector2d", 0.5, 0.5, { onUpdate: this.onAnchorUpdate, scope: this });
    }
    if (typeof this.currentTransform === "undefined") {
      this.currentTransform = pool.pull("Matrix2d");
    }
    this.currentTransform.identity();
    this.body = void 0;
    this.GUID = void 0;
    this.onVisibilityChange = void 0;
    this.alwaysUpdate = false;
    this.updateWhenPaused = false;
    this.isPersistent = false;
    this.floating = false;
    this.autoTransform = true;
    this.alpha = 1;
    this.ancestor = void 0;
    this.mask = void 0;
    this.shader = void 0;
    this.blendMode = "normal";
    this.name = "";
    this.isRenderable = true;
    this.isKinematic = true;
    this.isDirty = true;
    this._flip = {
      x: false,
      y: false
    };
    this._inViewport = false;
    this._parentApp = void 0;
    this._tint = pool.pull("Color", 255, 255, 255, 1);
    this.setOpacity(1);
  }
  /**
   * returns the parent application (or game) to which this renderable is attached to
   * @return {Application} the parent application or undefined if not attached to any container/app
   */
  get parentApp() {
    if (typeof this._parentApp === "undefined") {
      if (typeof this.ancestor !== "undefined" && typeof this.ancestor.getRootAncestor === "function") {
        this._parentApp = this.ancestor.getRootAncestor().app;
      }
    }
    return this._parentApp;
  }
  /**
   * Whether the renderable object is floating (i.e. used screen coordinates), or contained in a floating parent container
   * @see Renderable#floating
   * @type {boolean}
   */
  get isFloating() {
    return this.floating === true || typeof this.ancestor !== "undefined" && this.ancestor.isFloating === true;
  }
  /**
   * define a tint for this renderable. a (255, 255, 255) r, g, b value will remove the tint effect.
   * @type {Color}
   * @default (255, 255, 255)
   * @example
   * // add a red tint to this renderable
   * this.tint.setColor(255, 128, 128);
   * // remove the tint
   * this.tint.setColor(255, 255, 255);
   */
  get tint() {
    return this._tint;
  }
  set tint(value) {
    this._tint.copy(value);
    this.isDirty = true;
  }
  /**
   * the depth of this renderable on the z axis
   * @type {number}
   */
  get depth() {
    return this.pos.z;
  }
  set depth(value) {
    this.pos.z = value;
    this.isDirty = true;
  }
  /**
   * Whether the renderable object is visible and within the viewport
   * @type {boolean}
   * @default false
   */
  get inViewport() {
    return this._inViewport;
  }
  set inViewport(value) {
    if (this._inViewport !== value) {
      this._inViewport = value;
      if (typeof this.onVisibilityChange === "function") {
        this.onVisibilityChange.call(this, value);
      }
    }
  }
  /**
   * returns true if this renderable is flipped on the horizontal axis
   * @public
   * @see Renderable#flipX
   * @type {boolean}
   */
  get isFlippedX() {
    return this._flip.x === true;
  }
  /**
   * returns true if this renderable is flipped on the vertical axis
   * @public
   * @see Renderable#flipY
   * @type {boolean}
   */
  get isFlippedY() {
    return this._flip.y === true;
  }
  /**
   * returns the bounding box for this renderable
   * @returns {Bounds} bounding box Rectangle object
   */
  getBounds() {
    if (typeof this._bounds === "undefined") {
      super.getBounds();
      if (this.isFinite()) {
        this.updateBounds();
      } else {
        this._bounds.setMinMax(this.pos.x, this.pos.y, this.width, this.height);
      }
    }
    return this._bounds;
  }
  /**
   * get the renderable alpha channel value<br>
   * @returns {number} current opacity value between 0 and 1
   */
  getOpacity() {
    return this.alpha;
  }
  /**
   * set the renderable alpha channel value<br>
   * @param {number} alpha - opacity value between 0.0 and 1.0
   */
  setOpacity(alpha2) {
    if (typeof alpha2 === "number") {
      this.alpha = clamp(alpha2, 0, 1);
      if (isNaN(this.alpha)) {
        this.alpha = 1;
      }
      this.isDirty = true;
    }
  }
  /**
   * flip the renderable on the horizontal axis (around the center of the renderable)
   * @see Matrix2d#scaleX
   * @param {boolean} [flip=true] - `true` to flip this renderable.
   * @returns {Renderable} Reference to this object for method chaining
   */
  flipX(flip = true) {
    this._flip.x = !!flip;
    this.isDirty = true;
    return this;
  }
  /**
   * flip the renderable on the vertical axis (around the center of the renderable)
   * @see Matrix2d#scaleY
   * @param {boolean} [flip=true] - `true` to flip this renderable.
   * @returns {Renderable} Reference to this object for method chaining
   */
  flipY(flip = true) {
    this._flip.y = !!flip;
    this.isDirty = true;
    return this;
  }
  /**
   * multiply the renderable currentTransform with the given matrix
   * @see Renderable#currentTransform
   * @param {Matrix2d} m - the transformation matrix
   * @returns {Renderable} Reference to this object for method chaining
   */
  transform(m) {
    this.currentTransform.multiply(m);
    this.updateBounds();
    this.isDirty = true;
    return this;
  }
  /**
   * return the angle to the specified target
   * @param {Renderable|Vector2d|Vector3d} target
   * @returns {number} angle in radians
   */
  angleTo(target) {
    let a = this.getBounds();
    let ax, ay;
    if (target instanceof _Renderable) {
      let b = target.getBounds();
      ax = b.centerX - a.centerX;
      ay = b.centerY - a.centerY;
    } else {
      ax = target.x - a.centerX;
      ay = target.y - a.centerY;
    }
    return Math.atan2(ay, ax);
  }
  /**
   * return the distance to the specified target
   * @param {Renderable|Vector2d|Vector3d} target
   * @returns {number} distance
   */
  distanceTo(target) {
    let a = this.getBounds();
    let dx, dy;
    if (target instanceof _Renderable) {
      let b = target.getBounds();
      dx = a.centerX - b.centerX;
      dy = a.centerY - b.centerY;
    } else {
      dx = a.centerX - target.x;
      dy = a.centerY - target.y;
    }
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Rotate this renderable towards the given target.
   * @param {Renderable|Vector2d|Vector3d} target - the renderable or position to look at
   * @returns {Renderable} Reference to this object for method chaining
   */
  lookAt(target) {
    let position2;
    if (target instanceof _Renderable) {
      position2 = target.pos;
    } else {
      position2 = target;
    }
    let angle = this.angleTo(position2);
    this.rotate(angle);
    return this;
  }
  /**
   * Rotate this renderable by the specified angle (in radians).
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d|ObservableVector2d} [v] - an optional point to rotate around
   * @returns {Renderable} Reference to this object for method chaining
   */
  rotate(angle, v) {
    if (angle !== 0) {
      this.currentTransform.rotate(angle, v);
      this.updateBounds();
      this.isDirty = true;
    }
    return this;
  }
  /**
   * scale the renderable around his anchor point.  Scaling actually applies changes
   * to the currentTransform member wich is used by the renderer to scale the object
   * when rendering.  It does not scale the object itself.  For example if the renderable
   * is an image, the image.width and image.height properties are unaltered but the currentTransform
   * member will be changed.
   * @param {number} x - a number representing the abscissa of the scaling vector.
   * @param {number} [y=x] - a number representing the ordinate of the scaling vector.
   * @returns {Renderable} Reference to this object for method chaining
   */
  scale(x, y = x) {
    this.currentTransform.scale(x, y);
    this.updateBounds();
    this.isDirty = true;
    return this;
  }
  /**
   * scale the renderable around his anchor point
   * @param {Vector2d} v - scaling vector
   * @returns {Renderable} Reference to this object for method chaining
   */
  scaleV(v) {
    this.scale(v.x, v.y);
    return this;
  }
  /**
   * update function (automatically called by melonJS).
   * @param {number} dt - time since the last update in milliseconds.
   * @returns {boolean} true if the renderable is dirty
   */
  update(dt) {
    return this.isDirty;
  }
  /**
   * update the bounding box for this shape.
   * @param {boolean} [absolute=true] - update the bounds size and position in (world) absolute coordinates
   * @returns {Bounds} this shape bounding box Rectangle object
   */
  updateBounds(absolute = true) {
    if (this.isRenderable) {
      let bounds = this.getBounds();
      bounds.clear();
      if (this.autoTransform === true && !this.currentTransform.isIdentity()) {
        this.currentTransform.translate(
          -this.width * this.anchorPoint.x,
          -this.height * this.anchorPoint.y
        );
        bounds.addFrame(
          0,
          0,
          this.width,
          this.height,
          this.currentTransform
        );
        this.currentTransform.translate(
          this.width * this.anchorPoint.x,
          this.height * this.anchorPoint.y
        );
      } else {
        bounds.addFrame(
          0,
          0,
          this.width,
          this.height
        );
        bounds.translate(
          -this.width * this.anchorPoint.x,
          -this.height * this.anchorPoint.y
        );
      }
      if (absolute === true) {
        let absPos = this.getAbsolutePosition();
        bounds.centerOn(absPos.x + bounds.x + bounds.width / 2, absPos.y + bounds.y + bounds.height / 2);
      }
      return bounds;
    } else {
      return super.updateBounds(absolute);
    }
  }
  /**
   * update the renderable's bounding rect (private)
   * @ignore
   */
  updateBoundsPos(newX = this.pos.x, newY = this.pos.y) {
    this.getBounds().translate(newX - this.pos.x, newY - this.pos.y);
  }
  /**
    * return the renderable absolute position in the game world
    * @returns {Vector2d}
    */
  getAbsolutePosition() {
    if (typeof this._absPos === "undefined") {
      this._absPos = pool.pull("Vector2d");
    }
    this._absPos.set(this.pos.x, this.pos.y);
    if (typeof this.ancestor !== "undefined" && typeof this.ancestor.getAbsolutePosition === "function" && this.floating !== true) {
      this._absPos.add(this.ancestor.getAbsolutePosition());
    }
    return this._absPos;
  }
  /**
   * called when the anchor point value is changed
   * @private
   * @param {number} x - the new X value to be set for the anchor
   * @param {number} y - the new Y value to be set for the anchor
   */
  onAnchorUpdate(x, y) {
    this.anchorPoint.setMuted(x, y);
    this.updateBounds();
    this.isDirty = true;
  }
  /**
   * Prepare the rendering context before drawing (automatically called by melonJS).
   * This will apply any defined transforms, anchor point, tint or blend mode and translate the context accordingly to this renderable position.
   * @see Renderable#draw
   * @see Renderable#postDraw
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer object
   */
  preDraw(renderer2) {
    let ax = this.width * this.anchorPoint.x, ay = this.height * this.anchorPoint.y;
    renderer2.save();
    renderer2.setGlobalAlpha(renderer2.globalAlpha() * this.getOpacity());
    if (this._flip.x || this._flip.y) {
      var dx = this._flip.x ? this.centerX - ax : 0, dy = this._flip.y ? this.centerY - ay : 0;
      renderer2.translate(dx, dy);
      renderer2.scale(this._flip.x ? -1 : 1, this._flip.y ? -1 : 1);
      renderer2.translate(-dx, -dy);
    }
    if (typeof this.mask !== "undefined") {
      renderer2.translate(this.pos.x, this.pos.y);
      renderer2.setMask(this.mask);
      renderer2.translate(-this.pos.x, -this.pos.y);
    }
    if (typeof this.shader === "object" && typeof renderer2.gl !== "undefined") {
      renderer2.customShader = this.shader;
    }
    if (this.autoTransform === true && !this.currentTransform.isIdentity()) {
      renderer2.translate(this.pos.x, this.pos.y);
      renderer2.transform(this.currentTransform);
      renderer2.translate(-this.pos.x, -this.pos.y);
    }
    renderer2.translate(-ax, -ay);
    renderer2.setTint(this.tint, this.getOpacity());
    if (this.blendMode !== renderer2.getBlendMode()) {
      renderer2.setBlendMode(this.blendMode);
    }
  }
  /**
   * Draw this renderable (automatically called by melonJS).
   * All draw operations for renderable are made respectively
   * to the position or transforms set or applied by the preDraw method.
   * The main draw loop will first call preDraw() to prepare the context for drawing the renderable,
   * then draw() to draw the renderable, and finally postDraw() to clear the context.
   * If you override this method, be mindful about the drawing logic; for example if you draw a shape
   * from the draw method, you should make sure that your draw it at the 0, 0 coordinates.
   * @see Renderable#preDraw
   * @see Renderable#postDraw
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
  }
  /**
   * restore the rendering context after drawing (automatically called by melonJS).
   * @see Renderable#preDraw
   * @see Renderable#draw
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer object
   */
  postDraw(renderer2) {
    renderer2.clearTint();
    if (typeof this.mask !== "undefined") {
      renderer2.clearMask();
    }
    if (typeof this.shader === "object" && typeof renderer2.gl !== "undefined") {
      renderer2.customShader = void 0;
    }
    renderer2.restore();
    this.isDirty = false;
  }
  /**
   * onCollision callback, triggered in case of collision,
   * when this renderable body is colliding with another one
   * @param {ResponseObject} response - the collision response object
   * @param {Renderable} other - the other renderable touching this one (a reference to response.a or response.b)
   * @returns {boolean} true if the object should respond to the collision (its position and velocity will be corrected)
   * @example
   * // colision handler
   * onCollision(response) {
   *     if (response.b.body.collisionType === me.collision.types.ENEMY_OBJECT) {
   *         // makes the other object solid, by substracting the overlap vector to the current position
   *         this.pos.sub(response.overlapV);
   *         this.hurt();
   *         // not solid
   *         return false;
   *     }
   *     // Make the object solid
   *     return true;
   * },
   */
  onCollision(response, other) {
    return false;
  }
  /**
   * Destroy function<br>
   * @ignore
   */
  destroy() {
    pool.push(this.currentTransform);
    this.currentTransform = void 0;
    pool.push(this.anchorPoint);
    this.anchorPoint = void 0;
    pool.push(this.pos);
    this.pos = void 0;
    if (typeof this._absPos !== "undefined") {
      pool.push(this._absPos);
      this._absPos = void 0;
    }
    if (this._bounds instanceof Bounds) {
      pool.push(this._bounds);
      this._bounds = void 0;
    }
    this.onVisibilityChange = void 0;
    if (typeof this.mask !== "undefined") {
      pool.push(this.mask);
      this.mask = void 0;
    }
    if (this._tint instanceof Color) {
      pool.push(this._tint);
      this._tint = void 0;
    }
    this.ancestor = void 0;
    this._parentApp = void 0;
    if (this.body instanceof Body) {
      this.body.destroy.apply(this.body, arguments);
      this.body = void 0;
    }
    releaseAllPointerEvents(this);
    this.onDestroyEvent.apply(this, arguments);
    if (this.shader instanceof GLShader) {
      this.shader.destroy();
      this.shader = void 0;
    }
  }
  /**
   * OnDestroy Notification function<br>
   * Called by engine before deleting the object
   */
  onDestroyEvent() {
  }
};
var MIN = Math.min;
var MAX = Math.max;
var targetV = new Vector2d();
var Camera2d = class extends Renderable {
  /**
   * @param {number} minX - start x offset
   * @param {number} minY - start y offset
   * @param {number} maxX - end x offset
   * @param {number} maxY - end y offset
   */
  constructor(minX, minY, maxX, maxY) {
    super(minX, minY, maxX - minX, maxY - minY);
    this.AXIS = {
      NONE: 0,
      HORIZONTAL: 1,
      VERTICAL: 2,
      BOTH: 3
    };
    this.bounds = pool.pull("Bounds");
    this.smoothFollow = true;
    this.damping = 1;
    this.near = -1e3;
    this.far = 1e3;
    this.projectionMatrix = new Matrix3d();
    this.invCurrentTransform = new Matrix2d();
    this.offset = new Vector2d();
    this.target = null;
    this.follow_axis = this.AXIS.NONE;
    this._shake = {
      intensity: 0,
      duration: 0,
      axis: this.AXIS.BOTH,
      onComplete: null
    };
    this._fadeOut = {
      color: null,
      tween: null
    };
    this._fadeIn = {
      color: null,
      tween: null
    };
    this.name = "default";
    this.setDeadzone(this.width / 6, this.height / 6);
    this.anchorPoint.set(0, 0);
    this.isKinematic = false;
    this.bounds.setMinMax(minX, minY, maxX, maxY);
    this._updateProjectionMatrix();
    on(GAME_RESET, this.reset, this);
    on(CANVAS_ONRESIZE, this.resize, this);
  }
  // -- some private function ---
  /** @ignore */
  // update the projection matrix based on the projection frame (a rectangle)
  _updateProjectionMatrix() {
    this.projectionMatrix.ortho(0, this.width, this.height, 0, this.near, this.far);
  }
  /** @ignore */
  _followH(target) {
    let targetX = this.pos.x;
    if (target.x - this.pos.x > this.deadzone.right) {
      targetX = MIN(target.x - this.deadzone.right, this.bounds.width - this.width);
    } else if (target.x - this.pos.x < this.deadzone.pos.x) {
      targetX = MAX(target.x - this.deadzone.pos.x, this.bounds.left);
    }
    return targetX;
  }
  /** @ignore */
  _followV(target) {
    let targetY = this.pos.y;
    if (target.y - this.pos.y > this.deadzone.bottom) {
      targetY = MIN(target.y - this.deadzone.bottom, this.bounds.height - this.height);
    } else if (target.y - this.pos.y < this.deadzone.pos.y) {
      targetY = MAX(target.y - this.deadzone.pos.y, this.bounds.top);
    }
    return targetY;
  }
  // -- public function ---
  /**
   * reset the camera position to specified coordinates
   * @name reset
   * @memberof Camera2d
   * @param {number} [x=0] - initial position of the camera on the x axis
   * @param {number} [y=0] - initial position of the camera on the y axis
   */
  reset(x = 0, y = 0) {
    this.pos.x = x;
    this.pos.y = y;
    this.unfollow();
    this.smoothFollow = true;
    this.damping = 1;
    this.currentTransform.identity();
    this.invCurrentTransform.identity().invert();
    this._updateProjectionMatrix();
  }
  /**
   * change the deadzone settings.
   * the "deadzone" defines an area within the current camera in which
   * the followed renderable can move without scrolling the camera.
   * @name setDeadzone
   * @see Camera2d.follow
   * @memberof Camera2d
   * @param {number} w - deadzone width
   * @param {number} h - deadzone height
   */
  setDeadzone(w, h) {
    if (typeof this.deadzone === "undefined") {
      this.deadzone = new Rect(0, 0, 0, 0);
    }
    this.deadzone.pos.set(
      ~~((this.width - w) / 2),
      ~~((this.height - h) / 2 - h * 0.25)
    );
    this.deadzone.resize(w, h);
    this.smoothFollow = false;
    this.updateTarget();
    this.smoothFollow = true;
  }
  /**
   * resize the camera
   * @name resize
   * @memberof Camera2d
   * @param {number} w - new width of the camera
   * @param {number} h - new height of the camera
   * @returns {Camera2d} this camera
   */
  resize(w, h) {
    super.resize(w, h);
    this.smoothFollow = false;
    this.setBounds(0, 0, w, h);
    this.setDeadzone(w / 6, h / 6);
    this.update();
    this.smoothFollow = true;
    this._updateProjectionMatrix();
    emit(VIEWPORT_ONRESIZE, this.width, this.height, this);
    return this;
  }
  /**
   * set the camera boundaries (set to the world limit by default).
   * the camera is bound to the given coordinates and cannot move/be scrolled outside of it.
   * @name setBounds
   * @memberof Camera2d
   * @param {number} x - world left limit
   * @param {number} y - world top limit
   * @param {number} w - world width limit
   * @param {number} h - world height limit
   */
  setBounds(x, y, w, h) {
    this.smoothFollow = false;
    this.bounds.setMinMax(x, y, w + x, h + y);
    this.moveTo(this.pos.x, this.pos.y);
    this.update();
    this.smoothFollow = true;
  }
  /**
   * set the camera to follow the specified renderable. <br>
   * (this will put the camera center around the given target)
   * @name follow
   * @memberof Camera2d
   * @param {Renderable|Vector2d} target - renderable or position vector to follow
   * @param {number} [axis=me.game.viewport.AXIS.BOTH] - Which axis to follow (see {@link Camera2d.AXIS})
   * @param {number} [damping=1] - default damping value
   * @example
   * // set the camera to follow this renderable on both axis, and enable damping
   * me.game.viewport.follow(this, me.game.viewport.AXIS.BOTH, 0.1);
   */
  follow(target, axis, damping) {
    if (target instanceof Renderable) {
      this.target = target.pos;
    } else if (target instanceof Vector2d || target instanceof Vector3d || target instanceof ObservableVector2d || target instanceof ObservableVector3d) {
      this.target = target;
    } else {
      throw new Error("invalid target for me.Camera2d.follow");
    }
    this.follow_axis = typeof axis === "undefined" ? this.AXIS.BOTH : axis;
    this.smoothFollow = false;
    if (typeof damping !== "number") {
      this.damping = 1;
    } else {
      this.damping = clamp(damping, 0, 1);
    }
    this.updateTarget();
    this.smoothFollow = true;
  }
  /**
   * unfollow the current target
   * @name unfollow
   * @memberof Camera2d
   */
  unfollow() {
    this.target = null;
    this.follow_axis = this.AXIS.NONE;
  }
  /**
   * move the camera upper-left position by the specified offset.
   * @name move
   * @memberof Camera2d
   * @see Camera2d.focusOn
   * @param {number} x - horizontal offset
   * @param {number} y - vertical offset
   * @example
   * // Move the camera up by four pixels
   * me.game.viewport.move(0, -4);
   */
  move(x, y) {
    this.moveTo(this.pos.x + x, this.pos.y + y);
  }
  /**
   * move the camera upper-left position to the specified coordinates
   * @name moveTo
   * @memberof Camera2d
   * @see Camera2d.focusOn
   * @param {number} x
   * @param {number} y
   */
  moveTo(x, y) {
    let _x = this.pos.x;
    let _y = this.pos.y;
    this.pos.x = clamp(
      x,
      this.bounds.left,
      this.bounds.width
    );
    this.pos.y = clamp(
      y,
      this.bounds.top,
      this.bounds.height
    );
    if (_x !== this.pos.x || _y !== this.pos.y) {
      this.isDirty = true;
    }
  }
  /** @ignore */
  updateTarget() {
    if (this.target) {
      targetV.setV(this.pos);
      switch (this.follow_axis) {
        case this.AXIS.NONE:
          break;
        case this.AXIS.HORIZONTAL:
          targetV.x = this._followH(this.target);
          break;
        case this.AXIS.VERTICAL:
          targetV.y = this._followV(this.target);
          break;
        case this.AXIS.BOTH:
          targetV.x = this._followH(this.target);
          targetV.y = this._followV(this.target);
          break;
        default:
          break;
      }
      if (!this.pos.equals(targetV)) {
        if (this.smoothFollow === true && this.damping < 1) {
          if (toBeCloseTo(targetV.x, this.pos.x, 2) && toBeCloseTo(targetV.y, this.pos.y, 2)) {
            this.pos.setV(targetV);
            return;
          } else {
            this.pos.lerp(targetV, this.damping);
          }
        } else {
          this.pos.setV(targetV);
        }
        this.isDirty = true;
      }
    }
  }
  /** @ignore */
  update(dt) {
    this.updateTarget(dt);
    if (this._shake.duration > 0) {
      this._shake.duration -= dt;
      if (this._shake.duration <= 0) {
        this._shake.duration = 0;
        this.offset.setZero();
        if (typeof this._shake.onComplete === "function") {
          this._shake.onComplete();
        }
      } else {
        if (this._shake.axis === this.AXIS.BOTH || this._shake.axis === this.AXIS.HORIZONTAL) {
          this.offset.x = (Math.random() - 0.5) * this._shake.intensity;
        }
        if (this._shake.axis === this.AXIS.BOTH || this._shake.axis === this.AXIS.VERTICAL) {
          this.offset.y = (Math.random() - 0.5) * this._shake.intensity;
        }
      }
      this.isDirty = true;
    }
    if (this.isDirty === true) {
      emit(VIEWPORT_ONCHANGE, this.pos);
    }
    if (this._fadeIn.tween != null || this._fadeOut.tween != null) {
      this.isDirty = true;
    }
    if (!this.currentTransform.isIdentity()) {
      this.invCurrentTransform.copy(this.currentTransform).invert();
    } else {
      this.invCurrentTransform.identity();
    }
    return super.update(dt);
  }
  /**
   * shake the camera
   * @name shake
   * @memberof Camera2d
   * @param {number} intensity - maximum offset that the screen can be moved
   * while shaking
   * @param {number} duration - expressed in milliseconds
   * @param {number} [axis=me.game.viewport.AXIS.BOTH] - specify on which axis to apply the shake effect (see {@link Camera2d.AXIS})
   * @param {Function} [onComplete] - callback once shaking effect is over
   * @param {boolean} [force] - if true this will override the current effect
   * @example
   * // shake it baby !
   * me.game.viewport.shake(10, 500, me.game.viewport.AXIS.BOTH);
   */
  shake(intensity, duration, axis, onComplete, force) {
    if (this._shake.duration === 0 || force === true) {
      this._shake.intensity = intensity;
      this._shake.duration = duration;
      this._shake.axis = axis || this.AXIS.BOTH;
      this._shake.onComplete = typeof onComplete === "function" ? onComplete : void 0;
    }
  }
  /**
   * fadeOut(flash) effect<p>
   * screen is filled with the specified color and slowly goes back to normal
   * @name fadeOut
   * @memberof Camera2d
   * @param {Color|string} color - a CSS color value
   * @param {number} [duration=1000] - expressed in milliseconds
   * @param {Function} [onComplete] - callback once effect is over
   * @example
   * // fade the camera to white upon dying, reload the level, and then fade out back
   * me.game.viewport.fadeIn("#fff", 150, function() {
   *     me.audio.play("die", false);
   *     me.level.reload();
   *     me.game.viewport.fadeOut("#fff", 150);
   * });
   */
  fadeOut(color, duration = 1e3, onComplete) {
    this._fadeOut.color = pool.pull("Color").copy(color);
    this._fadeOut.tween = pool.pull("Tween", this._fadeOut.color).to({ alpha: 0 }, duration).onComplete(onComplete || null);
    this._fadeOut.tween.isPersistent = true;
    this._fadeOut.tween.start();
  }
  /**
   * fadeIn effect <p>
   * fade to the specified color
   * @name fadeIn
   * @memberof Camera2d
   * @param {Color|string} color - a CSS color value
   * @param {number} [duration=1000] - expressed in milliseconds
   * @param {Function} [onComplete] - callback once effect is over
   * @example
   * // flash the camera to white for 75ms
   * me.game.viewport.fadeIn("#FFFFFF", 75);
   */
  fadeIn(color, duration = 1e3, onComplete) {
    this._fadeIn.color = pool.pull("Color").copy(color);
    let _alpha = this._fadeIn.color.alpha;
    this._fadeIn.color.alpha = 0;
    this._fadeIn.tween = pool.pull("Tween", this._fadeIn.color).to({ alpha: _alpha }, duration).onComplete(onComplete || null);
    this._fadeIn.tween.isPersistent = true;
    this._fadeIn.tween.start();
  }
  /**
   * set the camera position around the specified object
   * @name focusOn
   * @memberof Camera2d
   * @param {Renderable|Entity|Sprite|NineSliceSprite} target - the renderable to focus the camera on
   */
  focusOn(target) {
    let bounds = target.getBounds();
    this.moveTo(
      target.pos.x + bounds.left + bounds.width / 2,
      target.pos.y + bounds.top + bounds.height / 2
    );
  }
  /**
   * check if the specified renderable is in the camera
   * @name isVisible
   * @memberof Camera2d
   * @param {Renderable|Entity|Sprite|NineSliceSprite} obj - to be checked against
   * @param {boolean} [floating = obj.floating] - if visibility check should be done against screen coordinates
   * @returns {boolean} true if within the viewport
   */
  isVisible(obj, floating = obj.floating) {
    if (floating === true || obj.floating === true) {
      return renderer.overlaps(obj.getBounds());
    } else {
      return obj.getBounds().overlaps(this);
    }
  }
  /**
   * convert the given "local" (screen) coordinates into world coordinates
   * @name localToWorld
   * @memberof Camera2d
   * @param {number} x - the x coordinate of the local point to be converted
   * @param {number} y - the y coordinate of the local point to be converted
   * @param {number} [v] - an optional vector object where to set the converted value
   * @returns {Vector2d}
   */
  localToWorld(x, y, v) {
    v = v || pool.pull("Vector2d");
    v.set(x, y).add(this.pos).sub(game.world.pos);
    if (!this.currentTransform.isIdentity()) {
      this.invCurrentTransform.apply(v);
    }
    return v;
  }
  /**
   * convert the given world coordinates into "local" (screen) coordinates
   * @name worldToLocal
   * @memberof Camera2d
   * @param {number} x
   * @param {number} y
   * @param {number} [v] - an optional vector object where to set the converted value
   * @returns {Vector2d} a vector with the converted local coordinates
   */
  worldToLocal(x, y, v) {
    v = v || pool.pull("Vector2d");
    v.set(x, y);
    if (!this.currentTransform.isIdentity()) {
      this.currentTransform.apply(v);
    }
    return v.sub(this.pos).add(game.world.pos);
  }
  /**
   * render the camera effects
   * @ignore
   */
  drawFX(renderer2) {
    if (this._fadeIn.tween) {
      renderer2.save();
      renderer2.resetTransform();
      renderer2.setColor(this._fadeIn.color);
      renderer2.fillRect(0, 0, this.width, this.height);
      renderer2.restore();
      if (this._fadeIn.color.alpha === 1) {
        this._fadeIn.tween = null;
        pool.push(this._fadeIn.color);
        this._fadeIn.color = null;
      }
    }
    if (this._fadeOut.tween) {
      renderer2.save();
      renderer2.resetTransform();
      renderer2.setColor(this._fadeOut.color);
      renderer2.fillRect(0, 0, this.width, this.height);
      renderer2.restore();
      if (this._fadeOut.color.alpha === 0) {
        this._fadeOut.tween = null;
        pool.push(this._fadeOut.color);
        this._fadeOut.color = null;
      }
    }
  }
  /**
   * draw all object visibile in this viewport
   * @ignore
   */
  draw(renderer2, container) {
    let translateX = this.pos.x + this.offset.x;
    let translateY = this.pos.y + this.offset.y;
    container.currentTransform.translate(-translateX, -translateY);
    renderer2.setProjection(this.projectionMatrix);
    renderer2.clipRect(
      0,
      0,
      this.width,
      this.height
    );
    this.preDraw(renderer2);
    container.preDraw(renderer2, this);
    container.draw(renderer2, this);
    this.drawFX(renderer2);
    container.postDraw(renderer2, this);
    this.postDraw(renderer2);
    container.currentTransform.translate(translateX, translateY);
  }
};
var default_camera;
var default_settings = {
  cameras: []
};
var Stage = class {
  /**
   * @param {object} [settings] - The stage` parameters
   * @param {Camera2d[]} [settings.cameras=[new me.Camera2d()]] - a list of cameras (experimental)
   * @param {Function} [settings.onResetEvent] - called by the state manager when reseting the object
   * @param {Function} [settings.onDestroyEvent] - called by the state manager before switching to another state
   */
  constructor(settings) {
    this.cameras = /* @__PURE__ */ new Map();
    this.lights = /* @__PURE__ */ new Map();
    this.ambientLight = new Color(0, 0, 0, 0);
    this.settings = Object.assign(default_settings, settings || {});
  }
  /**
   * Object reset function
   * @ignore
   */
  reset() {
    this.settings.cameras.forEach((camera) => {
      this.cameras.set(camera.name, camera);
    });
    if (this.cameras.has("default") === false) {
      if (typeof default_camera === "undefined") {
        let width = renderer.width;
        let height = renderer.height;
        default_camera = new Camera2d(0, 0, width, height);
      }
      this.cameras.set("default", default_camera);
    }
    emit(STAGE_RESET, this);
    this.onResetEvent.apply(this, arguments);
  }
  /**
   * update function
   * @name update
   * @memberof Stage
   * @ignore
   * @param {number} dt - time since the last update in milliseconds.
   * @returns {boolean}
   */
  update(dt) {
    let isDirty = false;
    this.cameras.forEach((camera) => {
      if (camera.update(dt) === true) {
        isDirty = true;
      }
    });
    this.lights.forEach((light) => {
      if (light.update(dt) === true) {
        isDirty = true;
      }
    });
    return isDirty;
  }
  /**
   * draw the current stage
   * @name draw
   * @memberof Stage
   * @ignore
   * @param {Renderer} renderer - the renderer object to draw with
   * @param {World} world - the world object to draw
   */
  draw(renderer2, world) {
    this.cameras.forEach((camera) => {
      camera.draw(renderer2, world);
      if (this.ambientLight.alpha !== 0) {
        renderer2.save();
        this.lights.forEach((light) => {
          renderer2.setMask(light.getVisibleArea(), true);
        });
        renderer2.setColor(this.ambientLight);
        renderer2.fillRect(0, 0, camera.width, camera.height);
        renderer2.clearMask();
        renderer2.restore();
      }
      this.lights.forEach((light) => {
        light.preDraw(renderer2, world);
        light.draw(renderer2, world);
        light.postDraw(renderer2, world);
      });
    });
  }
  /**
   * destroy function
   * @ignore
   */
  destroy() {
    this.cameras.clear();
    this.lights.forEach((light) => {
      light.destroy();
    });
    this.lights.clear();
    this.onDestroyEvent.apply(this, arguments);
  }
  /**
   * onResetEvent function<br>
   * called by the state manager when reseting the object
   * this is typically where you will load a level, add renderables, etc...
   * @name onResetEvent
   * @memberof Stage
   * @param {...*} [args] - optional arguments passed when switching state
   * @see state#change
   */
  onResetEvent() {
    if (typeof this.settings.onResetEvent === "function") {
      this.settings.onResetEvent.apply(this, arguments);
    }
  }
  /**
   * onDestroyEvent function<br>
   * called by the state manager before switching to another state
   * @name onDestroyEvent
   * @memberof Stage
   */
  onDestroyEvent() {
    if (typeof this.settings.onDestroyEvent === "function") {
      this.settings.onDestroyEvent.apply(this, arguments);
    }
  }
};
var PATH = /^.*(\\|\/|\:)/;
var EXT = /\.[^\.]*$/;
function getBasename(path) {
  return path.replace(PATH, "").replace(EXT, "");
}
function getPath(path) {
  return path.match(PATH)[0];
}
function getExtension(path) {
  return path.substring(path.lastIndexOf(".") + 1, path.length);
}
var file$1 = {
  __proto__: null,
  getBasename,
  getExtension,
  getPath
};
var imgList = {};
var tmxList = {};
var binList = {};
var jsonList = {};
var videoList = {};
var fontList = {};
function fetchData(url, responseType, settings = {}) {
  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "GET",
      // internally nocache is a string with a generated random number
      cache: settings.nocache === "" ? "no-cache" : "reload",
      credentials: settings.withCredentials === true ? "include" : "omit",
      // see setting.crossorigin, "anonymous" is used for cross-origin requests
      mode: settings.crossOrigin === "anonymous" ? "cors" : "no-cors"
    }).then((response) => {
      if (!response.ok) {
        if (response.status !== 0) {
          if (typeof onerror === "function") {
            reject(new Error("`Network response was not ok ${response.statusText}`"));
          }
        }
      }
      switch (responseType) {
        case "json":
          return response.json();
        case "text":
          return response.text();
        case "blob":
          return response.blob();
        case "arrayBuffer":
          return response.arrayBuffer();
        default:
          reject(new Error("Invalid response type"));
      }
    }).then((data2) => resolve(data2)).catch((error2) => reject(error2));
  });
}
function parseDDS() {
  throw new Error("unsupported format");
}
function parseKTX() {
  throw new Error("unsupported format");
}
function parseKTX2() {
  throw new Error("unsupported format");
}
function parsePVR() {
  throw new Error("unsupported format");
}
function parsePKM() {
  throw new Error("unsupported format");
}
var _renderer;
once(VIDEO_INIT, (renderer2) => {
  _renderer = renderer2;
});
function parseCompressedImage(arrayBuffer, imgExt) {
  let texture;
  if (_renderer.type.includes("WebGL")) {
    switch (imgExt) {
      case "dds":
        texture = parseDDS(arrayBuffer);
        break;
      case "pvr":
        texture = parsePVR(arrayBuffer);
        break;
      case "pkm":
        texture = parsePKM(arrayBuffer);
        break;
      case "ktx":
        texture = parseKTX(arrayBuffer);
        break;
      case "ktx2":
        texture = parseKTX2(arrayBuffer);
        break;
    }
  }
  if (typeof texture !== "undefined") {
    if (_renderer.hasSupportedCompressedFormats(texture.format)) {
      console.log("Compressed texture format supported: " + texture.format);
      return texture;
    }
  }
  throw "unsupported texture format:" + imgExt + texture ? " (" + texture.format + ")" : "";
}
function preloadImage(img2, onload2, onerror2, settings) {
  if (typeof imgList[img2.name] !== "undefined") {
    return 0;
  }
  let sources = Array.isArray(img2.src) ? img2.src : [img2.src];
  let isFormatSupported = false;
  for (const imgPath of sources) {
    const imgExt = getExtension(imgPath);
    switch (imgExt) {
      case "dds":
      case "pvr":
      case "pkm":
      case "ktx":
      case "ktx2":
        fetchData(imgPath, "arrayBuffer", settings).then((arrayBuffer) => {
          try {
            imgList[img2.name] = parseCompressedImage(arrayBuffer, imgExt);
            isFormatSupported = true;
            if (typeof onload2 === "function") {
              onload2();
            }
          } catch {
          }
        }).catch((error2) => {
          if (typeof onerror2 === "function") {
            onerror2(error2);
          }
        });
        break;
      case "svg":
        fetchData(imgPath, "text", settings).then((svgText) => {
          const svgImage = new Image();
          svgImage.onload = function() {
            imgList[img2.name] = svgImage;
            if (typeof onload2 === "function") {
              onload2();
            }
          };
          svgImage.onerror = function(error2) {
            if (typeof onerror2 === "function") {
              onerror2(error2);
            }
          };
          svgImage.src = "data:image/svg+xml;charset=utf8," + encodeURIComponent(svgText);
        }).catch((error2) => {
          if (typeof onerror2 === "function") {
            onerror2(error2);
          }
        });
        isFormatSupported = true;
        break;
      default:
        fetchData(imgPath, "blob", settings).then((blob) => {
          globalThis.createImageBitmap(blob).then((bitmap) => {
            imgList[img2.name] = bitmap;
            if (typeof onload2 === "function") {
              onload2();
            }
          });
        }).catch((error2) => {
          if (typeof onerror2 === "function") {
            onerror2(error2);
          }
        });
        isFormatSupported = true;
        break;
    }
    if (isFormatSupported === true) {
      return 1;
    }
  }
  throw new Error(
    "No supported Image file format found for " + img2.name
  );
}
function preloadFontFace(data2, onload2, onerror2) {
  const fontFaceSet = typeof globalThis.document !== "undefined" ? globalThis.document.fonts : void 0;
  if (isDataUrl(data2.src) === true) {
    if (!data2.src.startsWith("url(")) {
      data2.src = "url(" + data2.src + ")";
    }
  }
  if (typeof fontFaceSet !== "undefined") {
    let font = new FontFace(data2.name, data2.src);
    font.load().then(() => {
      fontList[data2.name] = font;
      fontFaceSet.add(font);
      if (typeof onload2 === "function") {
        onload2();
      }
    }, () => {
      if (typeof onerror2 === "function") {
        onerror2(data2.name);
      }
    });
  } else {
    if (typeof onerror2 === "function") {
      onerror2(error);
    }
  }
  return 1;
}
var re$3 = { exports: {} };
var SEMVER_SPEC_VERSION = "2.0.0";
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
var RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
var constants$2 = getDefaultExportFromCjs(constants$1);
var debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
var debug$2 = getDefaultExportFromCjs(debug_1);
var re_1 = re$3.exports;
(function(module, exports) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const safeRe = exports.safeRe = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index2 = R++;
    debug2(name, index2, value);
    t2[name] = index2;
    src[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$3, re$3.exports);
var reExports = re$3.exports;
var re$2 = getDefaultExportFromCjs(reExports);
var looseOption = Object.freeze({ loose: true });
var emptyOpts = Object.freeze({});
var parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
var parseOptions$2 = getDefaultExportFromCjs(parseOptions_1);
var numeric = /^[0-9]+$/;
var compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
var rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
var identifiers$2 = getDefaultExportFromCjs(identifiers$1);
var debug = debug_1;
var { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
var { safeRe: re$1, t: t$1 } = reExports;
var parseOptions = parseOptions_1;
var { compareIdentifiers } = identifiers$1;
var SemVer$d = class SemVer {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version2.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$1 = SemVer$d;
var semver$2 = getDefaultExportFromCjs(semver$1);
var SemVer$c = semver$1;
var parse$7 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$7;
var parse$8 = getDefaultExportFromCjs(parse_1);
var parse$6 = parse_1;
var valid$3 = (version2, options) => {
  const v = parse$6(version2, options);
  return v ? v.version : null;
};
var valid_1 = valid$3;
var valid$4 = getDefaultExportFromCjs(valid_1);
var parse$5 = parse_1;
var clean$1 = (version2, options) => {
  const s = parse$5(version2.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
var clean$2 = getDefaultExportFromCjs(clean_1);
var SemVer$b = semver$1;
var inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
var inc$2 = getDefaultExportFromCjs(inc_1);
var parse$4 = parse_1;
var diff$1 = (version1, version2) => {
  const v1 = parse$4(version1, null, true);
  const v2 = parse$4(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
var diff$2 = getDefaultExportFromCjs(diff_1);
var SemVer$a = semver$1;
var major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
var major$2 = getDefaultExportFromCjs(major_1);
var SemVer$9 = semver$1;
var minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
var minor$2 = getDefaultExportFromCjs(minor_1);
var SemVer$8 = semver$1;
var patch$2 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$2;
var patch$3 = getDefaultExportFromCjs(patch_1);
var parse$3 = parse_1;
var prerelease$1 = (version2, options) => {
  const parsed = parse$3(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
var prerelease$2 = getDefaultExportFromCjs(prerelease_1);
var SemVer$7 = semver$1;
var compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
var compare$c = getDefaultExportFromCjs(compare_1);
var compare$a = compare_1;
var rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
var rcompare$2 = getDefaultExportFromCjs(rcompare_1);
var compare$9 = compare_1;
var compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
var compareLoose$2 = getDefaultExportFromCjs(compareLoose_1);
var SemVer$6 = semver$1;
var compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
var compareBuild$4 = getDefaultExportFromCjs(compareBuild_1);
var compareBuild$2 = compareBuild_1;
var sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
var sort$2 = getDefaultExportFromCjs(sort_1);
var compareBuild$1 = compareBuild_1;
var rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
var rsort$2 = getDefaultExportFromCjs(rsort_1);
var compare$8 = compare_1;
var gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
var gt$5 = getDefaultExportFromCjs(gt_1);
var compare$7 = compare_1;
var lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
var lt$4 = getDefaultExportFromCjs(lt_1);
var compare$6 = compare_1;
var eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
var eq$3 = getDefaultExportFromCjs(eq_1);
var compare$5 = compare_1;
var neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
var neq$3 = getDefaultExportFromCjs(neq_1);
var compare$4 = compare_1;
var gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
var gte$4 = getDefaultExportFromCjs(gte_1);
var compare$3 = compare_1;
var lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
var lte$4 = getDefaultExportFromCjs(lte_1);
var eq$1 = eq_1;
var neq$1 = neq_1;
var gt$3 = gt_1;
var gte$2 = gte_1;
var lt$2 = lt_1;
var lte$2 = lte_1;
var cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
var cmp$2 = getDefaultExportFromCjs(cmp_1);
var SemVer$5 = semver$1;
var parse$2 = parse_1;
var { safeRe: re, t } = reExports;
var coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match2 = null;
  if (!options.rtl) {
    match2 = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
      if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
        match2 = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match2 === null) {
    return null;
  }
  const major2 = match2[2];
  const minor2 = match2[3] || "0";
  const patch2 = match2[4] || "0";
  const prerelease2 = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
  const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
  return parse$2(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
var coerce$2 = getDefaultExportFromCjs(coerce_1);
var LRUCache = class {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.map.get(key);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
  set(key, value) {
    const deleted = this.delete(key);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key, value);
    }
    return this;
  }
};
var lrucache = LRUCache;
var lrucache$1 = getDefaultExportFromCjs(lrucache);
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lrucache;
  const cache2 = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
var Range$9 = requireRange();
var satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
var satisfies$5 = getDefaultExportFromCjs(satisfies_1);
var Range$8 = requireRange();
var toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
var toComparators$2 = getDefaultExportFromCjs(toComparators_1);
var SemVer$4 = semver$1;
var Range$7 = requireRange();
var maxSatisfying$1 = (versions2, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions2.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
var maxSatisfying$2 = getDefaultExportFromCjs(maxSatisfying_1);
var SemVer$3 = semver$1;
var Range$6 = requireRange();
var minSatisfying$1 = (versions2, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions2.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
var minSatisfying$2 = getDefaultExportFromCjs(minSatisfying_1);
var SemVer$2 = semver$1;
var Range$5 = requireRange();
var gt$2 = gt_1;
var minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
var minVersion$2 = getDefaultExportFromCjs(minVersion_1);
var Range$4 = requireRange();
var validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
var valid$2 = getDefaultExportFromCjs(valid$1);
var SemVer$1 = semver$1;
var Comparator$2 = requireComparator();
var { ANY: ANY$1 } = Comparator$2;
var Range$3 = requireRange();
var satisfies$3 = satisfies_1;
var gt$1 = gt_1;
var lt$1 = lt_1;
var lte$1 = lte_1;
var gte$1 = gte_1;
var outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
var outside$4 = getDefaultExportFromCjs(outside_1);
var outside$2 = outside_1;
var gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
var gtr$2 = getDefaultExportFromCjs(gtr_1);
var outside$1 = outside_1;
var ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
var ltr$2 = getDefaultExportFromCjs(ltr_1);
var Range$2 = requireRange();
var intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
var intersects$2 = getDefaultExportFromCjs(intersects_1);
var satisfies$2 = satisfies_1;
var compare$2 = compare_1;
var simplify = (versions2, range2, options) => {
  const set2 = [];
  let first = null;
  let prev = null;
  const v = versions2.sort((a, b) => compare$2(a, b, options));
  for (const version2 of v) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first) {
        first = version2;
      }
    } else {
      if (prev) {
        set2.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set2.push([first, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
var simplify$1 = getDefaultExportFromCjs(simplify);
var Range$1 = requireRange();
var Comparator$1 = requireComparator();
var { ANY } = Comparator$1;
var satisfies$1 = satisfies_1;
var compare$1 = compare_1;
var subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
var minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
var minimumVersion = [new Comparator$1(">=0.0.0")];
var simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
var higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
var lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
var subset$2 = getDefaultExportFromCjs(subset_1);
var internalRe = reExports;
var constants = constants$1;
var SemVer2 = semver$1;
var identifiers = identifiers$1;
var parse$1 = parse_1;
var valid = valid_1;
var clean = clean_1;
var inc = inc_1;
var diff = diff_1;
var major = major_1;
var minor = minor_1;
var patch$1 = patch_1;
var prerelease = prerelease_1;
var compare = compare_1;
var rcompare = rcompare_1;
var compareLoose = compareLoose_1;
var compareBuild = compareBuild_1;
var sort = sort_1;
var rsort = rsort_1;
var gt = gt_1;
var lt = lt_1;
var eq = eq_1;
var neq = neq_1;
var gte = gte_1;
var lte = lte_1;
var cmp = cmp_1;
var coerce = coerce_1;
var Comparator = requireComparator();
var Range = requireRange();
var satisfies = satisfies_1;
var toComparators = toComparators_1;
var maxSatisfying = maxSatisfying_1;
var minSatisfying = minSatisfying_1;
var minVersion = minVersion_1;
var validRange = valid$1;
var outside = outside_1;
var gtr = gtr_1;
var ltr = ltr_1;
var intersects = intersects_1;
var simplifyRange = simplify;
var subset = subset_1;
var semver = {
  parse: parse$1,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch: patch$1,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var index = getDefaultExportFromCjs(semver);
var GUID_base = "";
var GUID_index = 0;
function checkVersion(v1, v2) {
  if (/^\d+$/.test(v1)) {
    v1 += ".0.0";
  } else if (/^\d+\.\d+$/.test(v1)) {
    v1 += ".0";
  }
  if (/^\d+$/.test(v2)) {
    v2 += ".0.0";
  } else if (/^\d+\.\d+$/.test(v2)) {
    v2 += ".0";
  }
  return semver.compare(v1, v2);
}
function getUriFragment(url) {
  let hash = {};
  if (typeof url === "undefined") {
    if (typeof globalThis.document !== "undefined") {
      let location = globalThis.document.location;
      if (location && location.hash) {
        url = location.hash;
      } else {
        return hash;
      }
    } else {
      return hash;
    }
  } else {
    let index2 = url.indexOf("#");
    if (index2 !== -1) {
      url = url.slice(index2, url.length);
    } else {
      return hash;
    }
  }
  url.slice(1).split("&").filter((value) => value !== "").forEach((value) => {
    let kv = value.split("=");
    let k = kv.shift();
    let v = kv.join("=");
    hash[k] = v || true;
  });
  return hash;
}
function resetGUID(base, index2 = 0) {
  GUID_base = toHex(base.toString().toUpperCase());
  GUID_index = index2;
}
function createGUID(index2 = 1) {
  GUID_index += index2;
  return GUID_base + "-" + (index2 || GUID_index);
}
var utils = {
  __proto__: null,
  agent: agent$1,
  array: array$1,
  checkVersion,
  createGUID,
  file: file$1,
  function: _function,
  getUriFragment,
  resetGUID,
  string: string$1
};
var TMXTileset = class {
  /**
   *  @param {object} tileset - tileset data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#tileset})
   */
  constructor(tileset) {
    this.TileProperties = [];
    this.imageCollection = [];
    this.firstgid = this.lastgid = +tileset.firstgid;
    if (typeof tileset.source !== "undefined") {
      let src = tileset.source;
      let ext = getExtension(src);
      if (ext === "tsx" || ext === "json") {
        tileset = getTMX(getBasename(src));
        if (!tileset) {
          throw new Error(src + " external TSX/JSON tileset not found");
        }
      }
    }
    this.name = tileset.name;
    this.tilewidth = +tileset.tilewidth;
    this.tileheight = +tileset.tileheight;
    this.spacing = +tileset.spacing || 0;
    this.margin = +tileset.margin || 0;
    this.tileoffset = new Vector2d();
    this.isAnimated = false;
    this.isCollection = false;
    this.class = tileset.class;
    this.animations = /* @__PURE__ */ new Map();
    this._lastUpdate = 0;
    let tiles = tileset.tiles;
    for (let i in tiles) {
      if (tiles.hasOwnProperty(i)) {
        if ("animation" in tiles[i]) {
          this.isAnimated = true;
          this.animations.set(tiles[+i].animation[0].tileid, {
            dt: 0,
            idx: 0,
            frames: tiles[+i].animation,
            cur: tiles[+i].animation[0]
          });
        }
        if ("properties" in tiles[i]) {
          if (Array.isArray(tiles[i].properties)) {
            let tileProperty = {};
            for (let j in tiles[i].properties) {
              tileProperty[tiles[i].properties[j].name] = tiles[i].properties[j].value;
            }
            this.setTileProperty(+tiles[i].id + this.firstgid, tileProperty);
          } else {
            this.setTileProperty(+i + this.firstgid, tiles[i].properties);
          }
        }
        if ("image" in tiles[i]) {
          let image = getImage(tiles[i].image);
          if (!image) {
            throw new Error("melonJS: '" + tiles[i].image + "' file for tile '" + (+i + this.firstgid) + "' not found!");
          }
          this.imageCollection[+i + this.firstgid] = image;
        }
      }
    }
    this.isCollection = this.imageCollection.length > 0;
    let offset = tileset.tileoffset;
    if (offset) {
      this.tileoffset.x = +offset.x;
      this.tileoffset.y = +offset.y;
    }
    let tileInfo = tileset.tileproperties;
    if (tileInfo) {
      for (let i in tileInfo) {
        if (tileInfo.hasOwnProperty(i)) {
          this.setTileProperty(+i + this.firstgid, tileInfo[i]);
        }
      }
    }
    if (this.isCollection === false) {
      this.image = getImage(tileset.image);
      if (!this.image) {
        throw new Error("melonJS: '" + tileset.image + "' file for tileset '" + this.name + "' not found!");
      }
      this.texture = renderer.cache.get(this.image, {
        framewidth: this.tilewidth,
        frameheight: this.tileheight,
        margin: this.margin,
        spacing: this.spacing
      });
      this.atlas = this.texture.getAtlas();
      let hTileCount = +tileset.columns || Math.round(this.image.width / (this.tilewidth + this.spacing));
      let vTileCount = Math.round(this.image.height / (this.tileheight + this.spacing));
      if (tileset.tilecount % hTileCount > 0) {
        ++vTileCount;
      }
      this.lastgid = this.firstgid + (hTileCount * vTileCount - 1 || 0);
      if (tileset.tilecount && this.lastgid - this.firstgid + 1 !== +tileset.tilecount) {
        console.warn(
          "Computed tilecount (" + (this.lastgid - this.firstgid + 1) + ") does not match expected tilecount (" + tileset.tilecount + ")"
        );
      }
    }
  }
  /**
   * return the tile image from a "Collection of Image" tileset
   * @param {number} gid
   * @returns {Image} corresponding image or undefined
   */
  getTileImage(gid) {
    return this.imageCollection[gid];
  }
  /**
   * set the tile properties
   * @ignore
   */
  setTileProperty(gid, prop) {
    this.TileProperties[gid] = prop;
  }
  /**
   * return true if the gid belongs to the tileset
   * @param {number} gid
   * @returns {boolean}
   */
  contains(gid) {
    return gid >= this.firstgid && gid <= this.lastgid;
  }
  /**
   * Get the view (local) tile ID from a GID, with animations applied
   * @param {number} gid - Global tile ID
   * @returns {number} View tile ID
   */
  getViewTileId(gid) {
    let localId = gid - this.firstgid;
    if (this.animations.has(localId)) {
      return this.animations.get(localId).cur.tileid;
    }
    return localId;
  }
  /**
   * return the properties of the specified tile
   * @param {number} tileId
   * @returns {object}
   */
  getTileProperties(tileId) {
    return this.TileProperties[tileId];
  }
  // update tile animations
  update(dt) {
    let duration = 0, now = timer.getTime(), result = false;
    if (this._lastUpdate !== now) {
      this._lastUpdate = now;
      this.animations.forEach((anim) => {
        anim.dt += dt;
        duration = anim.cur.duration;
        while (anim.dt >= duration) {
          anim.dt -= duration;
          anim.idx = (anim.idx + 1) % anim.frames.length;
          anim.cur = anim.frames[anim.idx];
          duration = anim.cur.duration;
          result = true;
        }
      });
    }
    return result;
  }
  // draw the x,y tile
  drawTile(renderer2, dx, dy, tmxTile) {
    if (tmxTile.flipped) {
      renderer2.save();
      renderer2.translate(dx, dy);
      renderer2.transform(tmxTile.currentTransform);
      dx = dy = 0;
    }
    if (this.isCollection === true) {
      renderer2.drawImage(
        this.imageCollection[tmxTile.tileId],
        0,
        0,
        tmxTile.width,
        tmxTile.height,
        dx,
        dy,
        tmxTile.width,
        tmxTile.height
      );
    } else {
      let offset = this.atlas[this.getViewTileId(tmxTile.tileId)].offset;
      renderer2.drawImage(
        this.image,
        offset.x,
        offset.y,
        this.tilewidth,
        this.tileheight,
        dx,
        dy,
        this.tilewidth + renderer2.uvOffset,
        this.tileheight + renderer2.uvOffset
      );
    }
    if (tmxTile.flipped) {
      renderer2.restore();
    }
  }
};
var TMX_FLIP_H = 2147483648;
var TMX_FLIP_V = 1073741824;
var TMX_FLIP_AD = 536870912;
var TMX_CLEAR_BIT_MASK = ~(TMX_FLIP_H | TMX_FLIP_V | TMX_FLIP_AD);
var COLLISION_GROUP = "collision";
var TMXTilesetGroup = class {
  constructor() {
    this.tilesets = [];
    this.length = 0;
  }
  /**
   * add a tileset to the tileset group
   * @param {TMXTileset} tileset
   */
  add(tileset) {
    this.tilesets.push(tileset);
    this.length++;
  }
  /**
   * return the tileset at the specified index
   * @param {number} i
   * @returns {TMXTileset} corresponding tileset
   */
  getTilesetByIndex(i) {
    return this.tilesets[i];
  }
  /**
   * return the tileset corresponding to the specified id <br>
   * will throw an exception if no matching tileset is found
   * @param {number} gid
   * @returns {TMXTileset} corresponding tileset
   */
  getTilesetByGid(gid) {
    let invalidRange = -1;
    gid &= TMX_CLEAR_BIT_MASK;
    for (let i = 0, len = this.tilesets.length; i < len; i++) {
      if (this.tilesets[i].contains(gid)) {
        return this.tilesets[i];
      }
      if (this.tilesets[i].firstgid === this.tilesets[i].lastgid && gid >= this.tilesets[i].firstgid) {
        invalidRange = i;
      }
    }
    if (invalidRange !== -1) {
      return this.tilesets[invalidRange];
    } else {
      throw new Error("no matching tileset found for gid " + gid);
    }
  }
};
var inflateFunction;
function setTMXValue(name, type, value) {
  let match2;
  if (typeof value !== "string") {
    return value;
  }
  switch (type) {
    case "int":
    case "float":
      value = Number(value);
      break;
    case "bool":
      value = value === "true";
      break;
    default:
      if (!value || isBoolean(value)) {
        value = value ? value === "true" : true;
      } else if (isNumeric(value)) {
        value = Number(value);
      } else if (value.search(/^json:/i) === 0) {
        match2 = value.split(/^json:/i)[1];
        try {
          value = JSON.parse(match2);
        } catch {
          throw new Error("Unable to parse JSON: " + match2);
        }
      } else if (value.search(/^eval:/i) === 0) {
        match2 = value.split(/^eval:/i)[1];
        try {
          value = Function("'use strict';return (" + match2 + ")")();
        } catch {
          throw new Error("Unable to evaluate: " + match2);
        }
      } else if ((match2 = value.match(/^#([\da-fA-F])([\da-fA-F]{3})$/)) || (match2 = value.match(/^#([\da-fA-F]{2})([\da-fA-F]{6})$/))) {
        value = "#" + match2[2] + match2[1];
      }
      if (name.search(/^(ratio|anchorPoint)$/) === 0) {
        if (typeof value === "number") {
          value = {
            "x": value,
            "y": value
          };
        }
      }
  }
  return value;
}
function parseAttributes(obj, elt) {
  if (elt.attributes && elt.attributes.length > 0) {
    for (let j = 0; j < elt.attributes.length; j++) {
      const attribute = elt.attributes.item(j);
      if (typeof attribute.name !== "undefined") {
        obj[attribute.name] = attribute.value;
      } else {
        obj[attribute.nodeName] = attribute.nodeValue;
      }
    }
  }
}
function normalize(obj, item) {
  let nodeName = item.nodeName;
  switch (nodeName) {
    case "data": {
      let data2 = parse(item);
      data2.encoding = data2.encoding || "xml";
      if (typeof data2.chunks !== "undefined") {
        obj.chunks = obj.chunks || [];
        data2.chunks.forEach((chunk) => {
          obj.chunks.push({
            x: +chunk.x,
            y: +chunk.y,
            // chunk width is in tiles
            width: +chunk.width,
            // chunk height is in tiles
            height: +chunk.height,
            data: decode(chunk.text, data2.encoding, data2.compression)
          });
        });
        obj.encoding = "none";
      }
      if (typeof data2.text !== "undefined" && typeof obj.chunks === "undefined") {
        obj.data = decode(data2.text, data2.encoding, data2.compression);
        obj.encoding = "none";
      }
      break;
    }
    case "chunk":
      obj.chunks = obj.chunks || [];
      obj.chunks.push(parse(item));
      break;
    case "imagelayer":
    case "layer":
    case "objectgroup":
    case "group": {
      let layer = parse(item);
      layer.type = nodeName === "layer" ? "tilelayer" : nodeName;
      if (layer.image) {
        layer.image = layer.image.source;
      }
      obj.layers = obj.layers || [];
      obj.layers.push(layer);
      break;
    }
    case "animation":
      obj.animation = parse(item).frames;
      break;
    case "frame":
    case "object": {
      const name = nodeName + "s";
      obj[name] = obj[name] || [];
      obj[name].push(parse(item));
      break;
    }
    case "tile": {
      let tile = parse(item);
      if (tile.image) {
        tile.imagewidth = tile.image.width;
        tile.imageheight = tile.image.height;
        tile.image = tile.image.source;
      }
      obj.tiles = obj.tiles || {};
      obj.tiles[tile.id] = tile;
      break;
    }
    case "tileset": {
      let tileset = parse(item);
      if (tileset.image) {
        tileset.imagewidth = tileset.image.width;
        tileset.imageheight = tileset.image.height;
        tileset.image = tileset.image.source;
      }
      obj.tilesets = obj.tilesets || [];
      obj.tilesets.push(tileset);
      break;
    }
    case "polygon":
    case "polyline": {
      obj[nodeName] = [];
      let points = parse(item).points.split(" ");
      for (let i = 0; i < points.length; i++) {
        const v = points[i].split(",");
        obj[nodeName].push({
          "x": +v[0],
          "y": +v[1]
        });
      }
      break;
    }
    case "properties":
      obj.properties = parse(item);
      break;
    case "property": {
      const property = parse(item);
      const value = typeof property.value !== "undefined" ? property.value : property.text;
      obj[property.name] = setTMXValue(
        property.name,
        // in XML type is undefined for "string" values
        property.type || "string",
        value
      );
      break;
    }
    default:
      obj[nodeName] = parse(item);
      break;
  }
}
function decompress(data2, format) {
  if (typeof inflateFunction === "function") {
    return inflateFunction(data2, format);
  } else {
    throw new Error("GZIP/ZLIB compressed TMX Tile Map not supported!");
  }
}
function decodeCSV(input2) {
  let entries = input2.replace("\n", "").trim().split(",");
  let result = [];
  for (let i = 0; i < entries.length; i++) {
    result.push(+entries[i]);
  }
  return result;
}
function decodeBase64AsArray(input2, bytes = 1) {
  let dec = globalThis.atob(input2.replace(/[^A-Za-z0-9\+\/\=]/g, ""));
  let ar = new Uint32Array(dec.length / bytes);
  for (let i = 0, len = dec.length / bytes; i < len; i++) {
    ar[i] = 0;
    for (let j = bytes - 1; j >= 0; --j) {
      ar[i] += dec.charCodeAt(i * bytes + j) << (j << 3);
    }
  }
  return ar;
}
function setInflateFunction(fn) {
  inflateFunction = fn;
}
function decode(data2, encoding, compression) {
  compression = compression || "none";
  encoding = encoding || "none";
  switch (encoding) {
    case "csv":
      return decodeCSV(data2);
    case "base64":
      if (compression !== "none") {
        data2 = decompress(data2, compression);
      } else {
        data2 = decodeBase64AsArray(data2, 4);
      }
      return data2;
    case "none":
      return data2;
    case "xml":
      throw new Error("XML encoding is deprecated, use base64 instead");
    default:
      throw new Error("Unknown layer encoding: " + encoding);
  }
}
function parse(xml) {
  let obj = {};
  let text = "";
  if (xml.nodeType === 1) {
    parseAttributes(obj, xml);
  }
  if (xml.hasChildNodes()) {
    let children = xml.childNodes;
    for (const node of children) {
      switch (node.nodeType) {
        case 1:
          normalize(obj, node);
          break;
        case 3:
          text += node.nodeValue.trim();
          break;
      }
    }
  }
  if (text) {
    obj.text = text;
  }
  return obj;
}
function applyTMXProperties(obj, data2) {
  let properties = data2.properties;
  let types = data2.propertytypes;
  if (typeof properties !== "undefined") {
    for (let property in properties) {
      if (properties.hasOwnProperty(property)) {
        let type = "string";
        let name = property;
        let value = properties[property];
        if (typeof properties[property].name !== "undefined") {
          name = properties[property].name;
        }
        if (typeof types !== "undefined") {
          type = types[property];
        } else if (typeof properties[property].type !== "undefined") {
          type = properties[property].type;
        }
        if (typeof properties[property].value !== "undefined") {
          value = properties[property].value;
        }
        obj[name] = setTMXValue(name, type, value);
      }
    }
  }
}
var TMXUtils = {
  __proto__: null,
  applyTMXProperties,
  decode,
  parse,
  setInflateFunction
};
var Tile = class extends Bounds {
  /**
   * @param {number} x - x index of the Tile in the map
   * @param {number} y - y index of the Tile in the map
   * @param {number} gid - tile gid
   * @param {TMXTileset} tileset - the corresponding tileset object
   */
  constructor(x, y, gid, tileset) {
    let width, height;
    super();
    if (tileset.isCollection) {
      let image = tileset.getTileImage(gid & TMX_CLEAR_BIT_MASK);
      width = image.width;
      height = image.height;
    } else {
      width = tileset.tilewidth;
      height = tileset.tileheight;
    }
    this.setMinMax(0, 0, width, height);
    this.tileset = tileset;
    this.currentTransform = null;
    this.col = x;
    this.row = y;
    this.tileId = gid;
    this.flippedX = (this.tileId & TMX_FLIP_H) !== 0;
    this.flippedY = (this.tileId & TMX_FLIP_V) !== 0;
    this.flippedAD = (this.tileId & TMX_FLIP_AD) !== 0;
    this.flipped = this.flippedX || this.flippedY || this.flippedAD;
    if (this.flipped === true) {
      if (this.currentTransform === null) {
        this.currentTransform = new Matrix2d();
      }
      this.setTileTransform(this.currentTransform.identity());
    }
    this.tileId &= TMX_CLEAR_BIT_MASK;
  }
  /**
   * set the transformation matrix for this tile
   * @ignore
   */
  setTileTransform(transform) {
    transform.translate(this.width / 2, this.height / 2);
    if (this.flippedAD) {
      transform.rotate(-90 * Math.PI / 180);
      transform.scale(-1, 1);
    }
    if (this.flippedX) {
      transform.scale(
        this.flippedAD ? 1 : -1,
        this.flippedAD ? -1 : 1
      );
    }
    if (this.flippedY) {
      transform.scale(
        this.flippedAD ? -1 : 1,
        this.flippedAD ? 1 : -1
      );
    }
    transform.translate(-this.width / 2, -this.height / 2);
  }
  /**
   * return a renderable object for this Tile object
   * @param {object} [settings] - see {@link Sprite}
   * @returns {Renderable} a me.Sprite object
   */
  getRenderable(settings) {
    let renderable;
    let tileset = this.tileset;
    if (tileset.animations.has(this.tileId)) {
      let frames = [];
      let frameId = [];
      tileset.animations.get(this.tileId).frames.forEach((frame) => {
        frameId.push(frame.tileid);
        frames.push({
          name: "" + frame.tileid,
          delay: frame.duration
        });
      });
      renderable = tileset.texture.createAnimationFromName(frameId, settings);
      renderable.addAnimation(this.tileId - tileset.firstgid, frames);
      renderable.setCurrentAnimation(this.tileId - tileset.firstgid);
    } else {
      if (tileset.isCollection === true) {
        let image = tileset.getTileImage(this.tileId);
        renderable = new Sprite(
          0,
          0,
          Object.assign({
            image
          })
          //, settings)
        );
        renderable.anchorPoint.set(0, 0);
        renderable.scale(settings.width / this.width, settings.height / this.height);
        if (typeof settings.rotation !== "undefined") {
          renderable.anchorPoint.set(0.5, 0.5);
          renderable.currentTransform.rotate(settings.rotation);
          renderable.currentTransform.translate(settings.width / 2, settings.height / 2);
          settings.rotation = void 0;
        }
      } else {
        renderable = tileset.texture.createSpriteFromName(this.tileId - tileset.firstgid, settings);
        renderable.anchorPoint.set(0, 0);
      }
    }
    this.setTileTransform(renderable.currentTransform);
    return renderable;
  }
};
var TMXObject = class {
  constructor(map, settings, z) {
    this.points = void 0;
    this.name = settings.name;
    this.x = +settings.x;
    this.y = +settings.y;
    this.z = +z;
    this.width = +settings.width || 0;
    this.height = +settings.height || 0;
    this.gid = +settings.gid || null;
    this.tintcolor = settings.tintcolor;
    this.type = settings.type;
    this.class = typeof settings.class !== "undefined" ? settings.class : settings.type;
    this.text = void 0;
    this.rotation = degToRad(+settings.rotation || 0);
    this.id = +settings.id || void 0;
    this.orientation = map.orientation;
    this.shapes = void 0;
    this.isEllipse = false;
    this.isPoint = false;
    this.isPolygon = false;
    this.isPolyLine = false;
    if (typeof this.gid === "number") {
      this.setTile(map.tilesets);
    } else {
      if (typeof settings.ellipse !== "undefined") {
        this.isEllipse = true;
      } else if (typeof settings.point !== "undefined") {
        this.isPoint = true;
      } else if (typeof settings.polygon !== "undefined") {
        this.points = settings.polygon;
        this.isPolygon = true;
      } else if (typeof settings.polyline !== "undefined") {
        this.points = settings.polyline;
        this.isPolyLine = true;
      }
    }
    if (typeof settings.text !== "undefined") {
      this.text = settings.text;
      this.text.font = settings.text.fontfamily || "sans-serif";
      this.text.size = settings.text.pixelsize || 16;
      this.text.fillStyle = settings.text.color || "#000000";
      this.text.textAlign = settings.text.halign || "left";
      this.text.textBaseline = settings.text.valign || "top";
      this.text.width = this.width;
      this.text.height = this.height;
      applyTMXProperties(this.text, settings);
    } else {
      applyTMXProperties(this, settings);
      if (!this.shapes) {
        this.shapes = this.parseTMXShapes();
      }
    }
    if (!map.isEditor) {
      map.getRenderer().adjustPosition(this);
    }
  }
  /**
   * set the object image (for Tiled Object)
   * @ignore
   */
  setTile(tilesets) {
    let tileset = tilesets.getTilesetByGid(this.gid);
    if (tileset.isCollection === false) {
      this.width = this.framewidth = tileset.tilewidth;
      this.height = this.frameheight = tileset.tileheight;
    }
    this.tile = new Tile(this.x, this.y, this.gid, tileset);
  }
  /**
   * parses the TMX shape definition and returns a corresponding array of me.Shape object
   * @private
   * @returns {Polygon[]|Line[]|Ellipse[]} an array of shape objects
   */
  parseTMXShapes() {
    let shapes = [];
    if (this.isEllipse === true) {
      shapes.push(pool.pull(
        "Ellipse",
        this.width / 2,
        this.height / 2,
        this.width,
        this.height
      ).rotate(this.rotation));
    } else if (this.isPoint === true) {
      shapes.push(pool.pull("Point", this.x, this.y));
    } else {
      if (this.isPolygon === true) {
        let _polygon = pool.pull("Polygon", 0, 0, this.points);
        let isConvex = _polygon.isConvex();
        if (isConvex === false) {
          throw new Error("collision polygones in Tiled should be defined as Convex");
        } else if (isConvex === null) {
          throw new Error("invalid polygone");
        }
        shapes.push(_polygon.rotate(this.rotation));
      } else if (this.isPolyLine === true) {
        let p = this.points;
        let p1, p2;
        let segments = p.length - 1;
        for (let i = 0; i < segments; i++) {
          p1 = pool.pull("Vector2d", p[i].x, p[i].y);
          p2 = pool.pull("Vector2d", p[i + 1].x, p[i + 1].y);
          if (this.rotation !== 0) {
            p1 = p1.rotate(this.rotation);
            p2 = p2.rotate(this.rotation);
          }
          shapes.push(pool.pull("Line", 0, 0, [p1, p2]));
        }
      } else {
        shapes.push(pool.pull(
          "Polygon",
          0,
          0,
          [
            pool.pull("Vector2d"),
            pool.pull("Vector2d", this.width, 0),
            pool.pull("Vector2d", this.width, this.height),
            pool.pull("Vector2d", 0, this.height)
          ]
        ).rotate(this.rotation));
      }
    }
    if (this.orientation === "isometric") {
      for (let i = 0; i < shapes.length; i++) {
        if (typeof shapes[i].toIso === "function") {
          shapes[i].toIso();
        }
      }
    }
    return shapes;
  }
  /**
   * getObjectPropertyByName
   * @ignore
   */
  getObjectPropertyByName(name) {
    return this[name];
  }
};
function correctRadii(signedRx, signedRy, x1p, y1p) {
  const prx = Math.abs(signedRx);
  const pry = Math.abs(signedRy);
  const A = pow(x1p) / pow(prx) + pow(y1p) / pow(pry);
  const rx = A > 1 ? Math.sqrt(A) * prx : prx;
  const ry = A > 1 ? Math.sqrt(A) * pry : pry;
  return [rx, ry];
}
function mat2DotVec2([m00, m01, m10, m11], [vx, vy]) {
  return [m00 * vx + m01 * vy, m10 * vx + m11 * vy];
}
function vec2Add([ux, uy], [vx, vy]) {
  return [ux + vx, uy + vy];
}
function vec2Scale([a0, a1], scalar) {
  return [a0 * scalar, a1 * scalar];
}
function vec2Dot([ux, uy], [vx, vy]) {
  return ux * vx + uy * vy;
}
function vec2Mag([ux, uy]) {
  return Math.sqrt(ux ** 2 + uy ** 2);
}
function vec2Angle(u, v) {
  const [ux, uy] = u;
  const [vx, vy] = v;
  const sign2 = ux * vy - uy * vx >= 0 ? 1 : -1;
  return sign2 * Math.acos(vec2Dot(u, v) / (vec2Mag(u) * vec2Mag(v)));
}
function endpointToCenterParameterization(x1, y1, x2, y2, largeArcFlag, sweepFlag, srx, sry, xAxisRotationDeg) {
  const xAxisRotation = degToRad(xAxisRotationDeg);
  const cosphi = Math.cos(xAxisRotation);
  const sinphi = Math.sin(xAxisRotation);
  const [x1p, y1p] = mat2DotVec2(
    [cosphi, sinphi, -sinphi, cosphi],
    [(x1 - x2) / 2, (y1 - y2) / 2]
  );
  const [rx, ry] = correctRadii(srx, sry, x1p, y1p);
  const sign2 = largeArcFlag !== sweepFlag ? 1 : -1;
  const n = pow(rx) * pow(ry) - pow(rx) * pow(y1p) - pow(ry) * pow(x1p);
  const d = pow(rx) * pow(y1p) + pow(ry) * pow(x1p);
  const [cxp, cyp] = vec2Scale(
    [rx * y1p / ry, -ry * x1p / rx],
    sign2 * Math.sqrt(Math.abs(n / d))
  );
  const [cx, cy] = vec2Add(
    mat2DotVec2([cosphi, -sinphi, sinphi, cosphi], [cxp, cyp]),
    [(x1 + x2) / 2, (y1 + y2) / 2]
  );
  const a = [(x1p - cxp) / rx, (y1p - cyp) / ry];
  const b = [(-x1p - cxp) / rx, (-y1p - cyp) / ry];
  const startAngle = vec2Angle([1, 0], a);
  const deltaAngle0 = vec2Angle(a, b) % (2 * Math.PI);
  const deltaAngle = !sweepFlag && deltaAngle0 > 0 ? deltaAngle0 - 2 * Math.PI : sweepFlag && deltaAngle0 < 0 ? deltaAngle0 + 2 * Math.PI : deltaAngle0;
  const endAngle = startAngle + deltaAngle;
  return {
    cx,
    cy,
    rx,
    ry,
    startAngle,
    endAngle,
    xAxisRotation,
    anticlockwise: deltaAngle < 0
  };
}
var Path2D = class {
  constructor(svgPath) {
    this.points = [];
    this.arcResolution = 5;
    this.vertices = [];
    this.startPoint = pool.pull("Point");
    this.isDirty = false;
    if (typeof svgPath === "string") {
      this.parseSVGPath(svgPath);
    }
  }
  /**
   * Parses an SVG path string and adds the points to the current path.
   * @param {string} svgPath - The SVG path string to parse.
   */
  parseSVGPath(svgPath) {
    const pathCommands = svgPath.match(/([a-df-z])[^a-df-z]*/gi);
    const points = this.points;
    const startPoint = this.startPoint;
    let lastPoint = startPoint;
    this.beginPath();
    for (let i = 0; i < pathCommands.length; i++) {
      const pathCommand = pathCommands[i];
      const command = pathCommand[0].toUpperCase();
      const coordinates = pathCommand.slice(1).trim().split(/[\s,]+/).map(parseFloat);
      switch (command) {
        case "A":
          {
            const p = endpointToCenterParameterization(...coordinates);
            this.arc(p.x, p.y, p.radiusX, p.radiusY, p.rotation, p.startAngle, p.endAngle, p.applyanticlockwise);
          }
          break;
        case "H":
          lastPoint = points.length === 0 ? startPoint : points[points.length - 1];
          this.lineTo(lastPoint.x + coordinates[0], lastPoint.y);
          break;
        case "V":
          lastPoint = points.length === 0 ? startPoint : points[points.length - 1];
          this.lineTo(lastPoint.x, lastPoint.y + coordinates[0]);
          break;
        case "M":
          this.moveTo(...coordinates);
          break;
        case "L":
          this.lineTo(...coordinates);
          break;
        case "Q":
          this.quadraticCurveTo(...coordinates);
          break;
        case "C":
          this.bezierCurveTo(...coordinates);
          break;
        case "Z":
          this.closePath();
          break;
        default:
          console.warn("Unsupported command:", command);
          break;
      }
    }
  }
  /**
   * begin a new path
   */
  beginPath() {
    this.points.forEach((point) => {
      pool.push(point);
    });
    this.isDirty = true;
    this.points.length = 0;
    this.startPoint.set(0, 0);
  }
  /**
   * causes the point of the pen to move back to the start of the current path.
   * It tries to draw a straight line from the current point to the start.
   * If the shape has already been closed or has only one point, this function does nothing.
   */
  closePath() {
    let points = this.points;
    if (points.length > 0) {
      let firstPoint = points[0];
      if (!firstPoint.equals(points[points.length - 1])) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
      this.isDirty = true;
    }
  }
  /**
   * triangulate the shape defined by this path into an array of triangles
   * @returns {Point[]} an array of vertices representing the triangulated path or shape
   */
  triangulatePath() {
    let vertices = this.vertices;
    if (this.isDirty) {
      let points = this.points;
      let indices = earcut$1(points.flatMap((p) => [p.x, p.y]));
      let indicesLength = indices.length;
      while (vertices.length < indicesLength) {
        vertices.push(pool.pull("Point"));
      }
      for (let i = 0; i < indicesLength; i++) {
        let point = points[indices[i]];
        vertices[i].set(point.x, point.y);
      }
      while (vertices.length > indicesLength) {
        pool.push(vertices[vertices.length - 1]);
        vertices.length -= 1;
      }
      this.isDirty = false;
    }
    return vertices;
  }
  /**
   * moves the starting point of the current path to the (x, y) coordinates.
   * @param {number} x - the x-axis (horizontal) coordinate of the point.
   * @param {number} y - the y-axis (vertical) coordinate of the point.
   */
  moveTo(x, y) {
    this.startPoint.set(x, y);
    this.isDirty = true;
  }
  /**
   * connects the last point in the current path to the (x, y) coordinates with a straight line.
   * @param {number} x - the x-axis coordinate of the line's end point.
   * @param {number} y - the y-axis coordinate of the line's end point.
   */
  lineTo(x, y) {
    let points = this.points;
    let startPoint = this.startPoint;
    let lastPoint = points.length === 0 ? startPoint : points[points.length - 1];
    if (!startPoint.equals(lastPoint)) {
      points.push(pool.pull("Point", startPoint.x, startPoint.y));
    } else {
      points.push(pool.pull("Point", lastPoint.x, lastPoint.y));
    }
    points.push(pool.pull("Point", x, y));
    startPoint.x = x;
    startPoint.y = y;
    this.isDirty = true;
  }
  /**
   * adds an arc to the current path which is centered at (x, y) position with the given radius,
   * starting at startAngle and ending at endAngle going in the given direction by counterclockwise (defaulting to clockwise).
   * @param {number} x - the horizontal coordinate of the arc's center.
   * @param {number} y - the vertical coordinate of the arc's center.
   * @param {number} radius - the arc's radius. Must be positive.
   * @param {number} startAngle - the angle at which the arc starts in radians, measured from the positive x-axis.
   * @param {number} endAngle - the angle at which the arc ends in radians, measured from the positive x-axis.
   * @param {boolean} [anticlockwise=false] - an optional boolean value. If true, draws the arc counter-clockwise between the start and end angles.
   */
  arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) return;
    const fullCircle = anticlockwise ? Math.abs(startAngle - endAngle) >= TAU : Math.abs(endAngle - startAngle) >= TAU;
    startAngle = startAngle % TAU;
    endAngle = endAngle % TAU;
    if (startAngle < 0) startAngle += TAU;
    if (endAngle < 0) endAngle += TAU;
    if (startAngle >= endAngle) {
      endAngle += TAU;
    }
    let diff2 = endAngle - startAngle;
    let direction = 1;
    if (anticlockwise) {
      direction = -1;
      diff2 = TAU - diff2;
    }
    if (fullCircle) diff2 = TAU;
    const length = diff2 * radius;
    const nr_of_interpolation_points = length / this.arcResolution;
    const dangle = diff2 / nr_of_interpolation_points;
    const angleStep = dangle * direction;
    this.moveTo(x + radius * Math.cos(startAngle), y + radius * Math.sin(startAngle));
    let angle = startAngle;
    for (let j = 0; j < nr_of_interpolation_points; j++) {
      this.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
      angle += angleStep;
    }
    this.lineTo(x + radius * Math.cos(endAngle), y + radius * Math.sin(endAngle));
    this.isDirty = true;
  }
  /**
   * adds a circular arc to the path with the given control points and radius, connected to the previous point by a straight line.
   * @param {number} x1 - the x-axis coordinate of the first control point.
   * @param {number} y1 - the y-axis coordinate of the first control point.
   * @param {number} x2 - the x-axis coordinate of the second control point.
   * @param {number} y2 - the y-axis coordinate of the second control point.
   * @param {number} radius - the arc's radius. Must be positive.
   */
  arcTo(x1, y1, x2, y2, radius) {
    let points = this.points;
    let startPoint = this.startPoint;
    let lastPoint = points.length === 0 ? startPoint : points[points.length - 1];
    let x0 = lastPoint.x, y0 = lastPoint.y;
    let a0 = x0 - x1, a1 = y0 - y1;
    let b0 = x2 - x1, b1 = y2 - y1;
    let l_a = Math.sqrt(Math.pow(a0, 2) + Math.pow(a1, 2));
    let l_b = Math.sqrt(Math.pow(b0, 2) + Math.pow(b1, 2));
    a0 /= l_a;
    a1 /= l_a;
    b0 /= l_b;
    b1 /= l_b;
    let angle = Math.atan2(a1, a0) - Math.atan2(b1, b0);
    let tan_angle_div2 = Math.tan(angle / 2);
    let adj_l = radius / tan_angle_div2;
    let tangent1_pointx = x1 + a0 * adj_l, tangent1_pointy = y1 + a1 * adj_l;
    let tangent2_pointx = x1 + b0 * adj_l, tangent2_pointy = y1 + b1 * adj_l;
    this.moveTo(tangent1_pointx, tangent1_pointy);
    let bisec0 = (a0 + b0) / 2, bisec1 = (a1 + b1) / 2;
    let bisec_l = Math.sqrt(Math.pow(bisec0, 2) + Math.pow(bisec1, 2));
    bisec0 /= bisec_l;
    bisec1 /= bisec_l;
    let hyp_l = Math.sqrt(Math.pow(radius, 2) + Math.pow(adj_l, 2));
    let centerx = x1 + hyp_l * bisec0, centery = y1 + hyp_l * bisec1;
    let startAngle = Math.atan2(tangent1_pointy - centery, tangent1_pointx - centerx);
    let endAngle = Math.atan2(tangent2_pointy - centery, tangent2_pointx - centerx);
    this.arc(centerx, centery, radius, startAngle, endAngle);
  }
  /**
   * adds an elliptical arc to the path which is centered at (x, y) position with the radii radiusX and radiusY
   * starting at startAngle and ending at endAngle going in the given direction by counterclockwise.
   * @param {number} x - the x-axis (horizontal) coordinate of the ellipse's center.
   * @param {number} y - the  y-axis (vertical) coordinate of the ellipse's center.
   * @param {number} radiusX - the ellipse's major-axis radius. Must be non-negative.
   * @param {number} radiusY - the ellipse's minor-axis radius. Must be non-negative.
   * @param {number} rotation - the rotation of the ellipse, expressed in radians.
   * @param {number} startAngle - the angle at which the ellipse starts, measured clockwise from the positive x-axis and expressed in radians.
   * @param {number} endAngle - the angle at which the ellipse ends, measured clockwise from the positive x-axis and expressed in radians.
   * @param {boolean} [anticlockwise=false] - an optional boolean value which, if true, draws the ellipse counterclockwise (anticlockwise).
   */
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) return;
    let fullCircle = anticlockwise ? Math.abs(startAngle - endAngle) >= TAU : Math.abs(endAngle - startAngle) >= TAU;
    startAngle = startAngle % TAU;
    endAngle = endAngle % TAU;
    if (startAngle < 0) startAngle += TAU;
    if (endAngle < 0) endAngle += TAU;
    if (startAngle >= endAngle) {
      endAngle += TAU;
    }
    let diff2 = endAngle - startAngle;
    let direction = 1;
    if (anticlockwise) {
      direction = -1;
      diff2 = TAU - diff2;
    }
    if (fullCircle) diff2 = TAU;
    const length = (diff2 * radiusX + diff2 * radiusY) / 2;
    const nr_of_interpolation_points = length / this.arcResolution;
    const dangle = diff2 / nr_of_interpolation_points;
    const angleStep = dangle * direction;
    let angle = startAngle;
    const cos_rotation = Math.cos(rotation);
    const sin_rotation = Math.sin(rotation);
    this.moveTo(x + radiusX * Math.cos(startAngle), y + radiusY * Math.sin(startAngle));
    for (let j = 0; j < nr_of_interpolation_points; j++) {
      const _x1 = radiusX * Math.cos(angle);
      const _y1 = radiusY * Math.sin(angle);
      const _x2 = x + _x1 * cos_rotation - _y1 * sin_rotation;
      const _y2 = y + _x1 * sin_rotation + _y1 * cos_rotation;
      this.lineTo(_x2, _y2);
      angle += angleStep;
    }
    this.lineTo(x + radiusX * Math.cos(startAngle), y + radiusY * Math.sin(startAngle));
    this.isDirty = true;
  }
  /**
   * Adds a quadratic BÃ©zier curve to the path.
   * @param {number} cpX - The x-coordinate of the control point.
   * @param {number} cpY - The y-coordinate of the control point.
   * @param {number} x - The x-coordinate of the end point of the curve.
   * @param {number} y - The y-coordinate of the end point of the curve.
   */
  quadraticCurveTo(cpX, cpY, x, y) {
    const points = this.points;
    const startPoint = this.startPoint;
    const lastPoint = points.length === 0 ? startPoint : points[points.length - 1];
    const endPoint = pool.pull("Point").set(x, y);
    const controlPoint = pool.pull("Point").set(cpX, cpY);
    const resolution = this.arcResolution;
    const t2 = 1 / resolution;
    for (let i = 1; i <= resolution; i++) {
      this.lineTo(
        lastPoint.x * Math.pow(1 - t2 * i, 2) + controlPoint.x * 2 * (1 - t2 * i) * t2 * i + endPoint.x * Math.pow(t2 * i, 2),
        lastPoint.y * Math.pow(1 - t2 * i, 2) + controlPoint.y * 2 * (1 - t2 * i) * t2 * i + endPoint.y * Math.pow(t2 * i, 2)
      );
    }
    pool.push(endPoint, controlPoint);
    this.isDirty = true;
  }
  /**
   * Adds a cubic BÃ©zier curve to the path.
   * @param {number} cp1X - The x-coordinate of the first control point.
   * @param {number} cp1Y - The y-coordinate of the first control point.
   * @param {number} cp2X - The x-coordinate of the second control point.
   * @param {number} cp2Y - The y-coordinate of the second control point.
   * @param {number} x - The x-coordinate of the end point of the curve.
   * @param {number} y - The y-coordinate of the end point of the curve.
   */
  bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, x, y) {
    const points = this.points;
    const startPoint = this.startPoint;
    const lastPoint = points.length === 0 ? startPoint : points[points.length - 1];
    const endPoint = pool.pull("Point").set(x, y);
    const controlPoint1 = pool.pull("Point").set(cp1X, cp1Y);
    const controlPoint2 = pool.pull("Point").set(cp2X, cp2Y);
    const resolution = this.arcResolution;
    const t2 = 1 / resolution;
    for (let i = 1; i <= resolution; i++) {
      this.lineTo(
        lastPoint.x * Math.pow(1 - t2 * i, 3) + controlPoint1.x * 3 * Math.pow(1 - t2 * i, 2) * t2 * i + controlPoint2.x * 3 * (1 - t2 * i) * Math.pow(t2 * i, 2) + endPoint.x * Math.pow(t2 * i, 3),
        lastPoint.y * Math.pow(1 - t2 * i, 3) + controlPoint1.y * 3 * Math.pow(1 - t2 * i, 2) * t2 * i + controlPoint2.y * 3 * (1 - t2 * i) * Math.pow(t2 * i, 2) + endPoint.y * Math.pow(t2 * i, 3)
      );
    }
    pool.push(endPoint, controlPoint1, controlPoint2);
    this.isDirty = true;
  }
  /**
   * creates a path for a rectangle at position (x, y) with a size that is determined by width and height.
   * @param {number} x - the x-axis coordinate of the rectangle's starting point.
   * @param {number} y - the y-axis coordinate of the rectangle's starting point.
   * @param {number} width - the rectangle's width. Positive values are to the right, and negative to the left.
   * @param {number} height - the rectangle's height. Positive values are down, and negative are up.
   */
  rect(x, y, width, height) {
    this.moveTo(x, y);
    this.lineTo(x + width, y);
    this.moveTo(x + width, y);
    this.lineTo(x + width, y + height);
    this.moveTo(x + width, y + height);
    this.lineTo(x, y + height);
    this.moveTo(x, y + height);
    this.lineTo(x, y);
    this.isDirty = true;
  }
  /**
   * adds an rounded rectangle to the current path.
   * @param {number} x - the x-axis coordinate of the rectangle's starting point.
   * @param {number} y - the y-axis coordinate of the rectangle's starting point.
   * @param {number} width - the rectangle's width. Positive values are to the right, and negative to the left.
   * @param {number} height - the rectangle's height. Positive values are down, and negative are up.
   * @param {number} radius - the arc's radius to draw the borders. Must be positive.
   */
  roundRect(x, y, width, height, radius) {
    this.moveTo(x + radius, y);
    this.lineTo(x + width - radius, y);
    this.arcTo(x + width, y, x + width, y + radius, radius);
    this.moveTo(x + width, y + radius);
    this.lineTo(x + width, y + height - radius);
    this.arcTo(x + width, y + height, x + width - radius, y + height, radius);
    this.moveTo(x + width - radius, y + height);
    this.lineTo(x + radius, y + height);
    this.arcTo(x, y + height, x, y + height - radius, radius);
    this.moveTo(x, y + height - radius);
    this.lineTo(x, y + radius);
    this.arcTo(x, y, x + radius, y, radius);
    this.isDirty = true;
  }
};
var defaultAttributes = {
  offscreenCanvas: false,
  willReadFrequently: false,
  antiAlias: false,
  context: "2d",
  transparent: false,
  premultipliedAlpha: true,
  stencil: true,
  blendMode: "normal",
  failIfMajorPerformanceCaveat: true,
  preferWebGL1: false,
  powerPreference: "default"
};
var WebGLVersion;
function createContext(canvas, attributes) {
  let context;
  if (attributes.context === "2d") {
    context = canvas.getContext(attributes.context, { willReadFrequently: attributes.willReadFrequently });
  } else if (attributes.context === "webgl") {
    let attr = {
      alpha: attributes.transparent,
      antialias: attributes.antiAlias,
      depth: attributes.depth,
      stencil: true,
      preserveDrawingBuffer: false,
      premultipliedAlpha: attributes.transparent ? attributes.premultipliedAlpha : false,
      powerPreference: attributes.powerPreference,
      failIfMajorPerformanceCaveat: attributes.failIfMajorPerformanceCaveat
    };
    if (attributes.preferWebGL1 !== true) {
      context = canvas.getContext("webgl2", attr);
      if (context) {
        WebGLVersion = 2;
      }
    }
    if (!context) {
      WebGLVersion = 1;
      context = canvas.getContext("webgl", attr) || canvas.getContext("experimental-webgl", attr);
    }
    if (!context) {
      throw new Error(
        "A WebGL context could not be created."
      );
    }
  } else {
    throw new Error(
      "Invalid context type. Must be one of '2d' or 'webgl'"
    );
  }
  return context;
}
var CanvasRenderTarget = class {
  /**
   * @param {number} width - the desired width of the canvas
   * @param {number} height - the desired height of the canvas
   * @param {object} attributes - The attributes to create both the canvas and context
   * @param {string} [attributes.context="2d"] - the context type to be created ("2d", "webgl")
   * @param {boolean} [attributes.preferWebGL1=false] - set to true for force using WebGL1 instead of WebGL2 (if supported)
   * @param {boolean} [attributes.transparent=false] - specify if the canvas contains an alpha channel
   * @param {boolean} [attributes.offscreenCanvas=false] - will create an offscreenCanvas if true instead of a standard canvas
   * @param {boolean} [attributes.willReadFrequently=false] - Indicates whether or not a lot of read-back operations are planned
   * @param {boolean} [attributes.antiAlias=false] - Whether to enable anti-aliasing, use false (default) for a pixelated effect.
   */
  constructor(width, height, attributes = defaultAttributes) {
    this.canvas;
    this.context;
    this.attributes = Object.assign({}, defaultAttributes, attributes);
    if (typeof attributes.context === "undefined") {
      attributes.context = "2d";
    }
    if (typeof attributes.canvas !== "undefined") {
      this.canvas = attributes.canvas;
    } else {
      this.canvas = createCanvas(width, height, this.attributes.offscreenCanvas);
    }
    this.context = createContext(this.canvas, this.attributes);
    this.WebGLVersion = WebGLVersion;
    this.setAntiAlias(this.attributes.antiAlias);
  }
  /**
   * @ignore
   */
  onResetEvent(width, height) {
    this.clear();
    this.resize(width, height);
  }
  /**
   * Clears the content of the canvas texture
   */
  clear() {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  /**
   * enable/disable image smoothing (scaling interpolation)
   * @param {boolean} [enable=false] - whether to enable or not image smoothing (scaling interpolation)
   */
  setAntiAlias(enable2 = false) {
    let canvas = this.canvas;
    setPrefixed("imageSmoothingEnabled", enable2, this.context);
    if (typeof canvas.style !== "undefined") {
      if (enable2 !== true) {
        canvas.style["image-rendering"] = "optimizeSpeed";
        canvas.style["image-rendering"] = "-moz-crisp-edges";
        canvas.style["image-rendering"] = "-o-crisp-edges";
        canvas.style["image-rendering"] = "-webkit-optimize-contrast";
        canvas.style["image-rendering"] = "optimize-contrast";
        canvas.style["image-rendering"] = "crisp-edges";
        canvas.style["image-rendering"] = "pixelated";
        canvas.style.msInterpolationMode = "nearest-neighbor";
      } else {
        canvas.style["image-rendering"] = "auto";
      }
    }
  }
  /**
   * Resizes the canvas texture to the given width and height.
   * @param {number} width - the desired width
   * @param {number} height - the desired height
   */
  resize(width, height) {
    this.canvas.width = Math.round(width);
    this.canvas.height = Math.round(height);
  }
  /**
   * Returns an ImageData object representing the underlying pixel data for a specified portion of this canvas texture.
   * (Note: when using getImageData(), it is highly recommended to use the `willReadFrequently` attribute when creatimg the corresponding canvas texture)
   * @param {number} x - The x-axis coordinate of the top-left corner of the rectangle from which the ImageData will be extracted
   * @param {number} y - The y-axis coordinate of the top-left corner of the rectangle from which the ImageData will be extracted
   * @param {number} width - The width of the rectangle from which the ImageData will be extracted. Positive values are to the right, and negative to the left
   * @param {number} height - The height of the rectangle from which the ImageData will be extracted. Positive values are down, and negative are up
   * @returns {ImageData} The ImageData extracted from this CanvasRenderTarget.
   */
  getImageData(x, y, width, height) {
    x = clamp(Math.floor(x), 0, this.canvas.width - 1);
    y = clamp(Math.floor(y), 0, this.canvas.height - 1);
    width = clamp(width, 1, this.canvas.width - x);
    height = clamp(height, 1, this.canvas.height - y);
    return this.context.getImageData(x, y, width, height);
  }
  /**
   * creates a Blob object representing the image contained in this canvas texture
   * @param {string} [type="image/png"] - A string indicating the image format
   * @param {number} [quality] - A Number between 0 and 1 indicating the image quality to be used when creating images using file formats that support lossy compression (such as image/jpeg or image/webp). A user agent will use its default quality value if this option is not specified, or if the number is outside the allowed range.
   * @returns {Promise} A Promise returning a Blob object representing the image contained in this canvas texture
   * @example
   * renderTarget.convertToBlob().then((blob) => console.log(blob));
   */
  toBlob(type = "image/png", quality) {
    if (typeof this.canvas.convertToBlob === "function") {
      return this.canvas.convertToBlob(type, quality);
    } else {
      return new Promise(function(resolve) {
        this.canvas.toBlob((blob) => {
          resolve(blob);
        }, type, quality);
      });
    }
  }
  /**
   * creates an ImageBitmap object from the most recently rendered image of this canvas texture
   * @param {string} [type="image/png"] - A string indicating the image format
   * @param {number} [quality] - A Number between 0 and 1 indicating the image quality to be used when creating images using file formats that support lossy compression (such as image/jpeg or image/webp). A user agent will use its default quality value if this option is not specified, or if the number is outside the allowed range.
   * @returns {Promise} A Promise returning an ImageBitmap.
   * @example
   * renderTarget.transferToImageBitmap().then((bitmap) => console.log(bitmap));
   */
  toImageBitmap(type = "image/png", quality) {
    return new Promise((resolve) => {
      if (typeof this.canvas.transferToImageBitmap === "function") {
        resolve(this.canvas.transferToImageBitmap());
      } else {
        let image = new Image();
        image.src = this.canvas.toDataURL(type, quality);
        image.onload = () => {
          globalThis.createImageBitmap(image).then((bitmap) => resolve(bitmap));
        };
      }
    });
  }
  /**
   * returns a data URL containing a representation of the most recently rendered image of this canvas texture
   * (not supported by OffscreenCanvas)
   * @param {string} [type="image/png"] - A string indicating the image format
   * @param {number} [quality] - A Number between 0 and 1 indicating the image quality to be used when creating images using file formats that support lossy compression (such as image/jpeg or image/webp). A user agent will use its default quality value if this option is not specified, or if the number is outside the allowed range.
   * @returns {Promise} A Promise returning a string containing the requested data URL.
   * @example
   * renderer.toDataURL().then((dataURL) => console.log(dataURL));
   */
  toDataURL(type = "image/png", quality) {
    return new Promise((resolve) => {
      resolve(this.canvas.toDataURL(type, quality));
    });
  }
  /**
   * invalidate the current CanvasRenderTarget, and force a reupload of the corresponding texture
   * (call this if you modify the canvas content between two draw calls)
   * @param {CanvasRenderer|WebGLRenderer} renderer - the renderer to which this canvas texture is attached
   */
  invalidate(renderer2) {
    if (typeof renderer2.gl !== "undefined") {
      renderer2.setCompositor("quad");
      this.glTextureUnit = renderer2.cache.getUnit(renderer2.cache.get(this.canvas));
      renderer2.currentCompositor.unbindTexture2D(null, this.glTextureUnit);
    }
  }
  /**
   * @ignore
   */
  destroy() {
    this.context = void 0;
    this.canvas = void 0;
  }
  /**
   * The width of this canvas texture in pixels
   * @public
   * @type {number}
   */
  get width() {
    return this.canvas.width;
  }
  set width(val) {
    this.canvas.width = Math.round(val);
  }
  /**
   * The height of this canvas texture in pixels
   * @public
   * @type {number}
   */
  get height() {
    return this.canvas.height;
  }
  set height(val) {
    this.canvas.height = Math.round(val);
  }
};
var Renderer = class {
  /**
   * @param {ApplicationSettings} [options] - optional parameters for the renderer
   */
  constructor(options) {
    this.renderTarget = new CanvasRenderTarget(
      options.width,
      options.height,
      // support case when a global canvas is available, e.g. webapp adapter for wechat
      typeof globalThis.canvas !== "undefined" ? Object.assign(options, { canvas: globalThis.canvas }) : options
    );
    this.settings = options;
    this.designRatio = this.settings.width / this.settings.height;
    this.scaleRatio = new Vector2d(this.settings.scale, this.settings.scale);
    this.isContextValid = true;
    this.depthTest = "sorting";
    this.path2D = new Path2D();
    this.type = "Generic";
    this.currentScissor = new Int32Array([0, 0, this.settings.width, this.settings.height]);
    this.maskLevel = 0;
    this.currentBlendMode = "none";
    this.currentColor = new Color(0, 0, 0, 1);
    this.currentTint = new Color(255, 255, 255, 1);
    this.projectionMatrix = new Matrix3d();
    this.uvOffset = 0;
  }
  /**
   * return the height of the canvas which this renderer draws to
   * @returns {number} height of the system Canvas
   */
  get height() {
    return this.getCanvas().height;
  }
  set height(value) {
    this.resize(this.width, value);
  }
  /**
   * return the width of the canvas which this renderer draws to
   * @returns {number} width of the system Canvas
   */
  get width() {
    return this.getCanvas().width;
  }
  set width(value) {
    this.resize(value, this.height);
  }
  /**
   * prepare the framebuffer for drawing a new frame
   */
  clear() {
  }
  /**
   * render the main framebuffer on screen
   */
  flush() {
  }
  /**
   * Reset context state
   */
  reset() {
    this.resetTransform();
    this.setBlendMode(this.settings.blendMode);
    this.setColor("#000000");
    this.clearTint();
    this.cache.clear();
    this.currentScissor[0] = 0;
    this.currentScissor[1] = 0;
    this.currentScissor[2] = this.width;
    this.currentScissor[3] = this.height;
    this.clearMask();
  }
  /**
   * return a reference to the current render target corresponding canvas which this renderer draws to
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.renderTarget.canvas;
  }
  /**
   * return a reference to the current render target corresponding Context
   * @returns {CanvasRenderingContext2D|WebGLRenderingContext}
   */
  getContext() {
    return this.renderTarget.context;
  }
  /**
   * returns the current blend mode for this renderer
   * @returns {string} blend mode
   */
  getBlendMode() {
    return this.currentBlendMode;
  }
  /**
   * get the current fill & stroke style color.
   * @returns {Color} current global color
   */
  getColor() {
    return this.currentColor;
  }
  /**
   * return the current global alpha
   * @returns {number}
   */
  globalAlpha() {
    return this.currentColor.glArray[3];
  }
  /**
   * check if the given rect or bounds overlaps with the renderer screen coordinates
   * @param {Rect|Bounds} bounds
   * @returns {boolean} true if overlaps
   */
  overlaps(bounds) {
    return bounds.left <= this.width && bounds.right >= 0 && bounds.top <= this.height && bounds.bottom >= 0;
  }
  /**
   * resizes the system canvas
   * @param {number} width - new width of the canvas
   * @param {number} height - new height of the canvas
   */
  resize(width, height) {
    let canvas = this.getCanvas();
    if (width !== canvas.width || height !== canvas.height) {
      canvas.width = width;
      canvas.height = height;
      this.currentScissor[0] = 0;
      this.currentScissor[1] = 0;
      this.currentScissor[2] = width;
      this.currentScissor[3] = height;
      emit(CANVAS_ONRESIZE, width, height);
    }
  }
  /**
   * enable/disable image smoothing (scaling interpolation) for the current render target
   * @param {boolean} [enable=false]
   */
  setAntiAlias(enable2 = false) {
    this.renderTarget.setAntiAlias(enable2);
  }
  /**
   * set/change the current projection matrix (WebGL only)
   * @param {Matrix3d} matrix
   */
  setProjection(matrix) {
    this.projectionMatrix.copy(matrix);
  }
  /**
   * stroke the given shape
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} shape - a shape object to stroke
   * @param {boolean} [fill=false] - fill the shape with the current color if true
   */
  stroke(shape, fill) {
    switch (shape.type) {
      case "RoundRect":
        this.strokeRoundRect(shape.left, shape.top, shape.width, shape.height, shape.radius, fill);
        break;
      case "Rectangle":
      case "Bounds":
        this.strokeRect(shape.left, shape.top, shape.width, shape.height, fill);
        break;
      case "Polygon":
      case "Line":
        this.strokePolygon(shape, fill);
        break;
      case "Ellipse":
        this.strokeEllipse(shape.pos.x, shape.pos.y, shape.radiusV.x, shape.radiusV.y, fill);
        break;
      case "Point":
        this.strokePoint(shape.x, shape.y);
        break;
      default:
        throw new Error("Invalid geometry for fill/stroke");
    }
  }
  /**
   * fill the given shape
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} shape - a shape object to fill
   */
  fill(shape) {
    this.stroke(shape, true);
  }
  /**
   * tint the given image or canvas using the given color
   * @param {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas} src - the source image to be tinted
   * @param {Color|string} color - the color that will be used to tint the image
   * @param {string} [mode="multiply"] - the composition mode used to tint the image
   * @returns {HTMLCanvasElement|OffscreenCanvas} a new canvas or offscreencanvas (if supported) element representing the tinted image
   */
  tint(src, color, mode = "multiply") {
    const attributes = { context: "2d", offscreenCanvas: true, transparent: true, antiAlias: this.settings.antiAlias };
    let canvasTexture = new CanvasRenderTarget(src.width, src.height, attributes);
    let context = canvasTexture.context;
    context.fillStyle = color instanceof Color ? color.toRGB() : color;
    context.fillRect(0, 0, src.width, src.height);
    context.globalCompositeOperation = mode;
    context.drawImage(src, 0, 0);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(src, 0, 0);
    return canvasTexture.canvas;
  }
  /**
   * A mask limits rendering elements to the shape and position of the given mask object.
   * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
   * Mask are not preserved through renderer context save and restore.
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [mask] - the shape defining the mask to be applied
   * @param {boolean} [invert=false] - either the given shape should define what is visible (default) or the opposite
   */
  // eslint-disable-next-line no-unused-vars
  setMask(mask, invert = false) {
  }
  /**
   * disable (remove) the rendering mask set through setMask.
   * @see Renderer#setMask
   */
  clearMask() {
  }
  /**
   * set a coloring tint for sprite based renderables
   * @param {Color} tint - the tint color
   * @param {number} [alpha] - an alpha value to be applied to the tint
   */
  setTint(tint, alpha2 = tint.alpha) {
    this.currentTint.copy(tint);
    this.currentTint.alpha *= alpha2;
  }
  /**
   * clear the rendering tint set through setTint.
   * @see Renderer#setTint
   */
  clearTint() {
    this.currentTint.setFloat(1, 1, 1, 1);
  }
  /**
   * creates a Blob object representing the last rendered frame
   * @param {string} [type="image/png"] - A string indicating the image format
   * @param {number} [quality] - A Number between 0 and 1 indicating the image quality to be used when creating images using file formats that support lossy compression (such as image/jpeg or image/webp). A user agent will use its default quality value if this option is not specified, or if the number is outside the allowed range.
   * @returns {Promise} A Promise returning a Blob object representing the last rendered frame
   * @example
   * renderer.convertToBlob().then((blob) => console.log(blob));
   */
  toBlob(type = "image/png", quality) {
    return this.renderTarget.toBlob(type, quality);
  }
  /**
   * creates an ImageBitmap object of the last frame rendered
   * (not supported by standard Canvas)
   * @param {string} [type="image/png"] - A string indicating the image format
   * @param {number} [quality] - A Number between 0 and 1 indicating the image quality to be used when creating images using file formats that support lossy compression (such as image/jpeg or image/webp). A user agent will use its default quality value if this option is not specified, or if the number is outside the allowed range.
   * @returns {Promise} A Promise returning an ImageBitmap.
   * @example
   * renderer.transferToImageBitmap().then((image) => console.log(image));
   */
  toImageBitmap(type = "image/png", quality) {
    return this.renderTarget.toImageBitmap(type, quality);
  }
  /**
   * returns a data URL containing a representation of the last frame rendered
   * @param {string} [type="image/png"] - A string indicating the image format
   * @param {number} [quality] - A Number between 0 and 1 indicating the image quality to be used when creating images using file formats that support lossy compression (such as image/jpeg or image/webp). A user agent will use its default quality value if this option is not specified, or if the number is outside the allowed range.
   * @returns {Promise} A Promise returning a string containing the requested data URL.
   * @example
   * renderer.toDataURL().then((dataURL) => console.log(dataURL));
   */
  toDataURL(type = "image/png", quality) {
    return this.renderTarget.toDataURL(type, quality);
  }
};
function parseTexturePacker(data2, textureAtlas) {
  let atlas = {};
  data2.frames.forEach((frame) => {
    if (frame.hasOwnProperty("filename")) {
      let s = frame.frame;
      let trimmed = !!frame.trimmed;
      let trim;
      if (trimmed) {
        trim = {
          x: frame.spriteSourceSize.x,
          y: frame.spriteSourceSize.y,
          w: frame.spriteSourceSize.w,
          h: frame.spriteSourceSize.h
        };
      }
      let originX, originY;
      let hasTextureAnchorPoint = frame.sourceSize && frame.pivot;
      if (hasTextureAnchorPoint) {
        originX = frame.sourceSize.w * frame.pivot.x - (trimmed ? trim.x : 0);
        originY = frame.sourceSize.h * frame.pivot.y - (trimmed ? trim.y : 0);
      }
      atlas[frame.filename] = {
        name: frame.filename,
        // frame name
        texture: data2.meta.image || "default",
        // the source texture
        offset: new Vector2d(s.x, s.y),
        anchorPoint: hasTextureAnchorPoint ? new Vector2d(originX / s.w, originY / s.h) : null,
        trimmed,
        trim,
        width: s.w,
        height: s.h,
        angle: frame.rotated === true ? -ETA : 0
      };
      textureAtlas.addUVs(atlas, frame.filename, data2.meta.size.w, data2.meta.size.h);
    }
  });
  return atlas;
}
function parseSpriteSheet(data2, textureAtlas) {
  let atlas = {};
  let image = data2.image;
  let spacing = data2.spacing || 0;
  let margin = data2.margin || 0;
  let width = image.width;
  let height = image.height;
  let spritecount = pool.pull(
    "Vector2d",
    ~~((width - margin + spacing) / (data2.framewidth + spacing)),
    ~~((height - margin + spacing) / (data2.frameheight + spacing))
  );
  if (width % (data2.framewidth + spacing) !== 0 || height % (data2.frameheight + spacing) !== 0) {
    let computed_width = spritecount.x * (data2.framewidth + spacing);
    let computed_height = spritecount.y * (data2.frameheight + spacing);
    if (computed_width - width !== spacing && computed_height - height !== spacing) {
      width = computed_width;
      height = computed_height;
      console.warn(
        "Spritesheet Texture for image: " + image.src + " is not divisible by " + (data2.framewidth + spacing) + "x" + (data2.frameheight + spacing) + ", truncating effective size to " + width + "x" + height
      );
    }
  }
  for (let frame = 0, count = spritecount.x * spritecount.y; frame < count; frame++) {
    let name = "" + frame;
    atlas[name] = {
      name,
      texture: "default",
      // the source texture
      offset: new Vector2d(
        margin + (spacing + data2.framewidth) * (frame % spritecount.x),
        margin + (spacing + data2.frameheight) * ~~(frame / spritecount.x)
      ),
      anchorPoint: data2.anchorPoint || null,
      trimmed: false,
      trim: void 0,
      width: data2.framewidth,
      height: data2.frameheight,
      angle: 0
    };
    textureAtlas.addUVs(atlas, name, width, height);
  }
  pool.push(spritecount);
  return atlas;
}
function parseAseprite(data2, textureAtlas) {
  let atlas = {};
  const frames = data2.frames;
  for (const name in frames) {
    let frame = frames[name].frame;
    let trimmed = !!frame.trimmed;
    let trim;
    if (trimmed) {
      trim = {
        x: frame.spriteSourceSize.x,
        y: frame.spriteSourceSize.y,
        w: frame.spriteSourceSize.w,
        h: frame.spriteSourceSize.h
      };
    }
    let originX, originY;
    let hasTextureAnchorPoint = frame.sourceSize && frame.pivot;
    if (hasTextureAnchorPoint) {
      originX = frame.sourceSize.w * frame.pivot.x - (trimmed ? trim.x : 0);
      originY = frame.sourceSize.h * frame.pivot.y - (trimmed ? trim.y : 0);
    }
    atlas[name] = {
      name,
      // frame name
      texture: data2.meta.image || "default",
      // the source texture
      offset: new Vector2d(frame.x, frame.y),
      anchorPoint: hasTextureAnchorPoint ? new Vector2d(originX / frame.w, originY / frame.h) : null,
      trimmed,
      trim,
      width: frame.w,
      height: frame.h,
      angle: frame.rotated === true ? -ETA : 0
    };
    textureAtlas.addUVs(atlas, name, data2.meta.size.w, data2.meta.size.h);
  }
  const anims = {};
  for (const name in data2.meta.frameTags) {
    const anim = data2.meta.frameTags[name];
    const indexArray = Array.from({ length: anim.to - anim.from + 1 }, (_, i) => anim.from + i);
    anims[name] = {
      name: anim.name,
      index: indexArray,
      // aseprite provide animation speed between frame, melonJS expect total duration for a given animation
      speed: 10 * (indexArray.length - 1),
      // only "forward" is supported for now
      direction: anim.direction
    };
  }
  atlas.anims = anims;
  return atlas;
}
function createAtlas(width, height, name = "default", repeat = "no-repeat") {
  return {
    "meta": {
      "app": "melonJS",
      "size": { "w": width, "h": height },
      "repeat": repeat,
      "image": "default"
    },
    "frames": [{
      "filename": name,
      "frame": { "x": 0, "y": 0, "w": width, "h": height }
    }]
  };
}
function identifyFormat(app) {
  if (app.includes("texturepacker") || app.includes("free-tex-packer")) {
    return "texturepacker";
  } else if (app.includes("shoebox")) {
    return "shoebox";
  } else if (app.includes("aseprite")) {
    return "aseprite";
  } else if (app.includes("melonJS")) {
    return "melonJS";
  } else {
    throw new Error("Unknown texture atlas format: " + app);
  }
}
var TextureAtlas = class {
  /**
   * @param {object|object[]} atlases - atlas information. See {@link loader.getJSON}
   * @param {HTMLImageElement|HTMLCanvasElement|string|HTMLImageElement[]|HTMLCanvasElement[]|string[]} [src=atlas.meta.image] - Image source
   * @param {boolean} [cache=false] - Use true to skip caching this Texture
   * @example
   * // create a texture atlas from a JSON Object
   * game.texture = new me.TextureAtlas(
   *     me.loader.getJSON("texture")
   * );
   *
   * // create a texture atlas from a multipack JSON Object
   * game.texture = new me.TextureAtlas([
   *     me.loader.getJSON("texture-0"),
   *     me.loader.getJSON("texture-1"),
   *     me.loader.getJSON("texture-2")
   * ]);
   *
   * // create a texture atlas for a spritesheet with an anchorPoint in the center of each frame
   * game.texture = new me.TextureAtlas(
   *     {
   *         framewidth : 32,
   *         frameheight : 32,
   *         anchorPoint : new me.Vector2d(0.5, 0.5)
   *     },
   *     me.loader.getImage("spritesheet")
   */
  constructor(atlases, src, cache2) {
    this.format = null;
    this.sources = /* @__PURE__ */ new Map();
    this.atlases = /* @__PURE__ */ new Map();
    this.activeAtlas = void 0;
    if (typeof atlases !== "undefined") {
      atlases = Array.isArray(atlases) ? atlases : [atlases];
      for (let i in atlases) {
        let atlas = atlases[i];
        if (typeof atlas.meta !== "undefined") {
          this.format = identifyFormat(atlas.meta.app);
          this.repeat = atlas.meta.repeat || "no-repeat";
          switch (this.format) {
            case "texturepacker":
            case "aseprite":
              if (typeof src === "undefined") {
                let image = getImage(atlas.meta.image);
                if (!image) {
                  throw new Error(
                    "Atlas texture '" + image + "' not found"
                  );
                }
                this.sources.set(atlas.meta.image, image);
              } else {
                this.sources.set(atlas.meta.image || "default", typeof src === "string" ? getImage(src) : src);
              }
              if (this.format === "texturepacker") {
                this.atlases.set(atlas.meta.image || "default", parseTexturePacker(atlas, this));
              } else {
                this.atlases.set(atlas.meta.image || "default", parseAseprite(atlas, this));
              }
              break;
            case "shoebox":
              if (!atlas.meta.exporter || !atlas.meta.exporter.includes("melonJS")) {
                throw new Error(
                  "ShoeBox requires the JSON exporter : https://github.com/melonjs/melonJS/tree/master/media/shoebox_JSON_export.sbx"
                );
              }
              this.sources.set("default", typeof src === "string" ? getImage(src) : src);
              this.atlases.set(atlas.meta.image || "default", parseTexturePacker(atlas, this));
              break;
            case "melonJS":
              this.sources.set("default", typeof src === "string" ? getImage(src) : src);
              this.atlases.set(atlas.meta.image || "default", parseTexturePacker(atlas, this));
              break;
            default:
              throw new Error("Unknown texture atlas format: " + atlas.meta.app);
          }
        } else {
          if (typeof atlas.framewidth !== "undefined" && typeof atlas.frameheight !== "undefined") {
            this.format = "Spritesheet (fixed cell size)";
            this.repeat = "no-repeat";
            if (typeof src !== "undefined") {
              atlas.image = typeof src === "string" ? getImage(src) : src;
            }
            this.atlases.set("default", parseSpriteSheet(atlas, this));
            this.sources.set("default", atlas.image);
          }
        }
      }
      this.activeAtlas = this.atlases.keys().next().value;
    }
    if (this.atlases.length === 0) {
      throw new Error("texture atlas format not supported");
    }
    if (cache2 !== false) {
      this.sources.forEach((source) => {
        renderer.cache.set(source, this);
      });
    }
  }
  /**
   * return the default or specified atlas dictionnary
   * @param {string} [name] - atlas name in case of multipack textures
   * @returns {object}
   */
  getAtlas(name) {
    if (typeof name === "string") {
      return this.atlases.get(name);
    } else {
      return this.atlases.get(this.activeAtlas);
    }
  }
  /**
   * return the format of the atlas dictionnary
   * @returns {string} will return "texturepacker", or "ShoeBox", or "melonJS", or "Spritesheet (fixed cell size)"
   */
  getFormat() {
    return this.format;
  }
  /**
   * return the source texture for the given region (or default one if none specified)
   * @param {object} [region] - region name in case of multipack textures
   * @returns {HTMLImageElement|HTMLCanvasElement}
   */
  getTexture(region) {
    if (typeof region === "object" && typeof region.texture === "string") {
      return this.sources.get(region.texture);
    } else {
      return this.sources.get(this.activeAtlas);
    }
  }
  /**
   * add a region to the atlas
   * @param {string} name - region mame
   * @param {number} x - x origin of the region
   * @param {number} y - y origin of the region
   * @param {number} w - width of the region
   * @param {number} h - height of the region
   * @returns {object} the created region
   */
  addRegion(name, x, y, w, h) {
    if (renderer.settings.verbose === true) {
      console.warn("Adding texture region", name, "for texture", this);
    }
    let source = this.getTexture();
    let atlas = this.getAtlas();
    let dw = source.width;
    let dh = source.height;
    atlas[name] = {
      name,
      offset: new Vector2d(x, y),
      width: w,
      height: h,
      angle: 0
    };
    this.addUVs(atlas, name, dw, dh);
    return atlas[name];
  }
  /**
   * return a normalized region (or frame) information for the specified sprite name
   * @param {string} name - name of the sprite
   * @param {string} [atlas] - name of a specific atlas where to search for the region
   * @returns {object}
   */
  getRegion(name, atlas) {
    let region;
    if (typeof atlas === "string") {
      region = this.getAtlas(atlas)[name];
    } else {
      for (let atlas2 of this.atlases.values()) {
        if (typeof atlas2[name] !== "undefined") {
          region = atlas2[name];
          break;
        }
      }
    }
    return region;
  }
  /**
   * return the uvs mapping for the given region
   * @param {object} name - region (or frame) name
   * @returns {Float32Array} region Uvs
   */
  getUVs(name) {
    let region = this.getRegion(name);
    if (typeof region === "undefined") {
      let keys2 = name.split(","), sx = +keys2[0], sy = +keys2[1], sw = +keys2[2], sh = +keys2[3];
      region = this.addRegion(name, sx, sy, sw, sh);
    }
    return region.uvs;
  }
  /**
   * add uvs mapping for the given region
   * @param {object} atlas - the atlas dictionnary where the region is define
   * @param {object} name - region (or frame) name
   * @param {number} w - the width of the region
   * @param {number} h - the height of the region
   * @returns {Float32Array} the created region UVs
   */
  addUVs(atlas, name, w, h) {
    if (typeof renderer.gl !== "undefined") {
      let s = atlas[name].offset;
      let sw = atlas[name].width;
      let sh = atlas[name].height;
      atlas[name].uvs = new Float32Array([
        s.x / w,
        // u0 (left)
        s.y / h,
        // v0 (top)
        (s.x + sw) / w,
        // u1 (right)
        (s.y + sh) / h
        // v1 (bottom)
      ]);
      let key = s.x + "," + s.y + "," + w + "," + h;
      atlas[key] = atlas[name];
    }
    return atlas[name].uvs;
  }
  /**
   * Create a sprite object using the first region found using the specified name
   * @param {string} name - name of the sprite
   * @param {object} [settings] - Additional settings passed to the {@link Sprite} contructor
   * @param {boolean} [nineSlice=false] - if true returns a 9-slice sprite
   * @returns {Sprite|NineSliceSprite}
   * @example
   * // create a new texture object under the `game` namespace
   * game.texture = new me.TextureAtlas(
   *    me.loader.getJSON("texture"),
   *    me.loader.getImage("texture")
   * );
   * ...
   * ...
   * // create a new "coin" sprite
   * let sprite = game.texture.createSpriteFromName("coin.png");
   * // set the renderable position to bottom center
   * sprite.anchorPoint.set(0.5, 1.0);
   * ...
   * ...
   * // create a 9-slice sprite
   * let dialogPanel = game.texture.createSpriteFromName(
   *    "rpg_dialo.png",
   *    // width & height are mandatory for 9-slice sprites
   *    { width: this.width, height: this.height },
   *    true
   * );
   */
  createSpriteFromName(name, settings, nineSlice = false) {
    return pool.pull(
      nineSlice === true ? "me.NineSliceSprite" : "me.Sprite",
      0,
      0,
      Object.assign({
        image: this,
        region: name
      }, settings || {})
    );
  }
  /**
   * Create an animation object using the first region found using all specified names
   * @param {string[]|number[]} [names] - list of names for each sprite (if not specified all defined names/entries in the atlas will be added)
   * (when manually creating a Texture out of a spritesheet, only numeric values are authorized)
   * @param {object} [settings] - Additional settings passed to the {@link Sprite} contructor
   * @returns {Sprite}
   * @example
   * // create a new texture object under the `game` namespace
   * game.texture = new me.TextureAtlas(
   *     me.loader.getJSON("texture"),
   *     me.loader.getImage("texture")
   * );
   *
   * // create a new Animated Sprite
   * let sprite = game.texture.createAnimationFromName([
   *     "walk0001.png", "walk0002.png", "walk0003.png",
   *     "walk0004.png", "walk0005.png", "walk0006.png",
   *     "walk0007.png", "walk0008.png", "walk0009.png",
   *     "walk0010.png", "walk0011.png"
   * ]);
   *
   * // define an additional basic walking animation
   * sprite.addAnimation ("simple_walk", [0,2,1]);
   * // you can also use frame name to define your animation
   * sprite.addAnimation ("speed_walk", ["walk0007.png", "walk0008.png", "walk0009.png", "walk0010.png"]);
   * // set the default animation
   * sprite.setCurrentAnimation("simple_walk");
   * // set the renderable position to bottom center
   * sprite.anchorPoint.set(0.5, 1.0);
   */
  createAnimationFromName(names, settings) {
    let tpAtlas = [], indices = {};
    let width = 0, height = 0;
    const textureAtlas = this.getAtlas();
    if (typeof names === "undefined") {
      names = textureAtlas;
    }
    for (const i in names) {
      const name = Array.isArray(names) ? names[i] : i;
      const region = this.getRegion(name);
      if (region == null) {
        throw new Error("Texture - region for " + name + " not found");
      }
      tpAtlas.push(region);
      indices[name] = tpAtlas.length - 1;
      width = Math.max(region.width, width);
      height = Math.max(region.height, height);
    }
    return new Sprite(0, 0, Object.assign({
      image: this,
      framewidth: width,
      frameheight: height,
      margin: 0,
      spacing: 0,
      atlas: tpAtlas,
      anims: textureAtlas.anims,
      atlasIndices: indices
    }, settings || {}));
  }
};
var Multimap = class _Multimap {
  constructor(operator, iterable) {
    this.size_ = 0;
    this.map = /* @__PURE__ */ new Map();
    this.operator = operator;
    if (iterable) {
      for (const [key, value] of iterable) {
        this.put(key, value);
      }
    }
    return this;
  }
  get size() {
    return this.size_;
  }
  get(key) {
    const values = this.map.get(key);
    if (values) {
      return this.operator.clone(values);
    } else {
      return this.operator.create();
    }
  }
  put(key, value) {
    let values = this.map.get(key);
    if (!values) {
      values = this.operator.create();
    }
    if (!this.operator.add(value, values)) {
      return false;
    }
    this.map.set(key, values);
    this.size_++;
    return true;
  }
  putAll(arg1, arg2) {
    let pushed = 0;
    if (arg2) {
      const key = arg1;
      const values = arg2;
      for (const value of values) {
        this.put(key, value);
        pushed++;
      }
    } else if (arg1 instanceof _Multimap) {
      for (const [key, value] of arg1.entries()) {
        this.put(key, value);
        pushed++;
      }
    } else {
      throw new TypeError("unexpected arguments");
    }
    return pushed > 0;
  }
  has(key) {
    return this.map.has(key);
  }
  hasEntry(key, value) {
    return this.operator.has(value, this.get(key));
  }
  delete(key) {
    this.size_ -= this.operator.size(this.get(key));
    return this.map.delete(key);
  }
  deleteEntry(key, value) {
    const current = this.get(key);
    if (!this.operator.delete(value, current)) {
      return false;
    }
    this.map.set(key, current);
    this.size_--;
    return true;
  }
  clear() {
    this.map.clear();
    this.size_ = 0;
  }
  keys() {
    return this.map.keys();
  }
  entries() {
    const self2 = this;
    function* gen() {
      for (const [key, values] of self2.map.entries()) {
        for (const value of values) {
          yield [key, value];
        }
      }
    }
    return gen();
  }
  values() {
    const self2 = this;
    function* gen() {
      for (const [, value] of self2.entries()) {
        yield value;
      }
    }
    return gen();
  }
  forEach(callback, thisArg) {
    for (const [key, value] of this.entries()) {
      callback.call(thisArg === void 0 ? this : thisArg, value, key, this);
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  asMap() {
    const ret = /* @__PURE__ */ new Map();
    for (const key of this.keys()) {
      ret.set(key, this.operator.clone(this.get(key)));
    }
    return ret;
  }
};
var ArrayMultimap = class extends Multimap {
  constructor(iterable) {
    super(new ArrayOperator(), iterable);
  }
  get [Symbol.toStringTag]() {
    return "ArrayMultimap";
  }
};
var ArrayOperator = class {
  create() {
    return [];
  }
  clone(collection) {
    return collection.slice();
  }
  add(value, collection) {
    collection.push(value);
    return true;
  }
  size(collection) {
    return collection.length;
  }
  delete(value, collection) {
    const index2 = collection.indexOf(value);
    if (index2 > -1) {
      collection.splice(index2, 1);
      return true;
    }
    return false;
  }
  has(value, collection) {
    return collection.includes(value);
  }
};
var TextureCache = class {
  /**
   * @ignore
   */
  constructor(max_size = Infinity) {
    this.cache = new ArrayMultimap();
    this.tinted = /* @__PURE__ */ new Map();
    this.units = /* @__PURE__ */ new Map();
    this.usedUnits = /* @__PURE__ */ new Set();
    this.max_size = max_size;
    this.clear();
  }
  /**
   * @ignore
   */
  clear() {
    this.cache.clear();
    this.tinted.clear();
    this.units.clear();
    this.usedUnits.clear();
  }
  /**
   * @ignore
   */
  allocateTextureUnit() {
    for (let unit = 0; unit < this.max_size; unit++) {
      if (!this.usedUnits.has(unit)) {
        this.usedUnits.add(unit);
        return unit;
      }
    }
    throw new Error(
      "Texture cache overflow: " + this.max_size + " texture units available for this GPU."
    );
  }
  /**
   * @ignore
   */
  freeTextureUnit(texture) {
    let source = texture.sources.get(texture.activeAtlas);
    let unit = this.units.get(source);
    if (typeof unit !== "undefined") {
      this.usedUnits.delete(source);
      this.units.delete(source);
    }
  }
  /**
   * @ignore
   */
  getUnit(texture) {
    let source = texture.sources.get(texture.activeAtlas);
    if (!this.units.has(source)) {
      this.units.set(source, this.allocateTextureUnit());
    }
    return this.units.get(source);
  }
  /**
   * @ignore
   * cache the textureAltas for the given image
   */
  set(image, textureAtlas) {
    let width = image.width || image.videoWidth;
    let height = image.height || image.videoHeight;
    if (renderer.WebGLVersion === 1 && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      let src = typeof image.src !== "undefined" ? image.src : image;
      console.warn(
        "[Texture] " + src + " is not a POT texture (" + width + "x" + height + ")"
      );
    }
    return this.cache.put(image, textureAtlas);
  }
  /**
   * @ignore
   * return the textureAltas for the given image
   */
  get(image, atlas) {
    let entry = this.cache.get(image)[0];
    if (typeof entry !== "undefined" && typeof atlas !== "undefined") {
      this.cache.forEach((value, key) => {
        let _atlas = value.getAtlas();
        if (key === image && _atlas.width === atlas.framewidth && _atlas.height === atlas.frameheight) {
          entry = value;
        }
      });
    }
    if (typeof entry === "undefined") {
      console.log("cache miss");
      if (!atlas) {
        atlas = createAtlas(image.width || image.videoWidth, image.height || image.videoHeight, image.src ? getBasename(image.src) : void 0);
      }
      entry = new TextureAtlas(atlas, image, false);
      this.set(image, entry);
    }
    if (typeof entry.sources !== "undefined" && entry.sources.size > 1) {
      console.log(entry);
      for (const [key, value] of entry.sources.entries()) {
        if (value === image) {
          console.log("cache hit");
          console.log(key);
          entry.activeAtlas = key;
        }
      }
    }
    return entry;
  }
  /**
   * @ignore
   */
  delete(image) {
    if (this.cache.has(image)) {
      let texture = this.cache.get(image)[0];
      if (typeof texture !== "undefined") {
        this.freeTextureUnit(texture);
      }
      this.cache.delete(image);
    }
  }
  /**
   * @ignore
   */
  tint(src, color) {
    let image_cache = this.tinted.get(src);
    if (image_cache === void 0) {
      image_cache = this.tinted.set(src, /* @__PURE__ */ new Map());
    }
    if (!image_cache.has(color)) {
      image_cache.set(color, renderer.tint(src, color, "multiply"));
    }
    return image_cache.get(color);
  }
};
var CanvasRenderer = class extends Renderer {
  /**
   * @param {ApplicationSettings} [options] - optional parameters for the renderer
   */
  constructor(options) {
    super(options);
    this.setBlendMode(this.settings.blendMode);
    this.setColor(this.currentColor);
    this.cache = new TextureCache();
    if (this.settings.textureSeamFix !== false && !this.settings.antiAlias) {
      this.uvOffset = 1;
    }
    this.type = "CANVAS";
    this.getCanvas().addEventListener("contextlost", (e) => {
      e.preventDefault();
      this.isContextValid = false;
      emit(ONCONTEXT_LOST, this);
    }, false);
    this.getCanvas().addEventListener("contextrestored", () => {
      this.isContextValid = true;
      emit(ONCONTEXT_RESTORED, this);
    }, false);
    on(GAME_RESET, () => {
      this.reset();
    });
  }
  /**
   * Reset context state
   */
  reset() {
    super.reset();
    this.clearColor(this.currentColor, this.settings.transparent !== true);
  }
  /**
   * Reset the canvas transform to identity
   */
  resetTransform() {
    this.getContext().setTransform(1, 0, 0, 1, 0, 0);
  }
  /**
   * set a blend mode for the given context. <br>
   * Supported blend mode between Canvas and WebGL remderer : <br>
   * - "normal" : this is the default mode and draws new content on top of the existing content <br>
   * <img src="images/normal-blendmode.png" width="510"/> <br>
   * - "multiply" : the pixels of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result. <br>
   * <img src="images/multiply-blendmode.png" width="510"/> <br>
   * - "additive or lighter" : where both content overlap the color is determined by adding color values. <br>
   * <img src="images/lighter-blendmode.png" width="510"/> <br>
   * - "screen" : The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply) <br>
   * <img src="images/screen-blendmode.png" width="510"/> <br>
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @param {string} [mode="normal"] - blend mode : "normal", "multiply", "lighter, "additive", "screen"
   * @param {CanvasRenderingContext2D} [context]
   */
  setBlendMode(mode = "normal", context) {
    context = context || this.getContext();
    this.currentBlendMode = mode;
    switch (mode) {
      case "screen":
        context.globalCompositeOperation = "screen";
        break;
      case "lighter":
      case "additive":
        context.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        context.globalCompositeOperation = "multiply";
        break;
      default:
        context.globalCompositeOperation = "source-over";
        this.currentBlendMode = "normal";
        break;
    }
  }
  /**
   * prepare the framebuffer for drawing a new frame
   */
  clear() {
    if (this.settings.transparent === false) {
      let canvas = this.getCanvas();
      let context = this.getContext();
      context.clearRect(0, 0, canvas.width, canvas.height);
    }
  }
  /**
   * Clears the main framebuffer with the given color
   * @param {Color|string} [color="#000000"] - CSS color.
   * @param {boolean} [opaque=false] - Allow transparency [default] or clear the surface completely [true]
   */
  clearColor(color = "#000000", opaque = false) {
    let canvas = this.getCanvas();
    let context = this.getContext();
    this.save();
    this.resetTransform();
    context.globalAlpha = 1;
    context.globalCompositeOperation = opaque === true ? "copy" : "source-over";
    context.fillStyle = color instanceof Color ? color.toRGBA() : color;
    this.fillRect(0, 0, canvas.width, canvas.height);
    this.restore();
  }
  /**
   * Erase the pixels in the given rectangular area by setting them to transparent black (rgba(0,0,0,0)).
   * @param {number} x - x axis of the coordinate for the rectangle starting point.
   * @param {number} y - y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   */
  clearRect(x, y, width, height) {
    this.getContext().clearRect(x, y, width, height);
  }
  /**
   * Create a pattern with the specified repetition
   * @param {HTMLImageElement|SVGImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap|OffscreenCanvas|VideoFrame} image - Source image to be used as the pattern's image
   * @param {string} repeat - Define how the pattern should be repeated
   * @returns {CanvasPattern}
   * @see ImageLayer#repeat
   * @example
   * let tileable   = renderer.createPattern(image, "repeat");
   * let horizontal = renderer.createPattern(image, "repeat-x");
   * let vertical   = renderer.createPattern(image, "repeat-y");
   * let basic      = renderer.createPattern(image, "no-repeat");
   */
  createPattern(image, repeat) {
    return this.getContext().createPattern(image, repeat);
  }
  /**
   * Draw an image onto the main using the canvas api
   * @param {HTMLImageElement|SVGImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap|OffscreenCanvas|VideoFrame} image - An element to draw into the context.
   * @param {number} sx - The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
   * @param {number} sy - The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
   * @param {number} sw - The width of the sub-rectangle of the source image to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by sx and sy to the bottom-right corner of the image is used.
   * @param {number} sh - The height of the sub-rectangle of the source image to draw into the destination context.
   * @param {number} dx - The X coordinate in the destination canvas at which to place the top-left corner of the source image.
   * @param {number} dy - The Y coordinate in the destination canvas at which to place the top-left corner of the source image.
   * @param {number} dw - The width to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn.
   * @param {number} dh - The height to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn.
   * @example
   * // Position the image on the canvas:
   * renderer.drawImage(image, dx, dy);
   * // Position the image on the canvas, and specify width and height of the image:
   * renderer.drawImage(image, dx, dy, dWidth, dHeight);
   * // Clip the image and position the clipped part on the canvas:
   * renderer.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
   */
  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    if (typeof sw === "undefined") {
      sw = dw = image.width;
      sh = dh = image.height;
      dx = sx;
      dy = sy;
      sx = 0;
      sy = 0;
    } else if (typeof dx === "undefined") {
      dx = sx;
      dy = sy;
      dw = sw;
      dh = sh;
      sw = image.width;
      sh = image.height;
      sx = 0;
      sy = 0;
    }
    if (this.settings.subPixel === false) {
      dx = ~~dx;
      dy = ~~dy;
    }
    let source = image;
    let tint = this.currentTint.toArray();
    if (tint[0] !== 1 || tint[1] !== 1 || tint[2] !== 1) {
      source = this.cache.tint(image, this.currentTint.toRGB());
    }
    context.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);
  }
  /**
   * Draw a pattern within the given rectangle.
   * @param {CanvasPattern} pattern - Pattern object
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @see CanvasRenderer#createPattern
   */
  drawPattern(pattern, x, y, width, height) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    let fillStyle = context.fillStyle;
    context.fillStyle = pattern;
    context.fillRect(x, y, width, height);
    context.fillStyle = fillStyle;
  }
  /**
   * starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path
   * @example
   * // First path
   * renderer.beginPath();
   * renderer.setColor("blue");
   * renderer.moveTo(20, 20);
   * renderer.lineTo(200, 20);
   * renderer.stroke();
   * // Second path
   * renderer.beginPath();
   * renderer.setColor("green");
   * renderer.moveTo(20, 20);
   * renderer.lineTo(120, 120);
   * renderer.stroke();
   */
  beginPath() {
    this.getContext().beginPath();
  }
  /**
   * begins a new sub-path at the point specified by the given (x, y) coordinates.
   * @param {number} x - The x axis of the point.
   * @param {number} y - The y axis of the point.
   */
  moveTo(x, y) {
    this.getContext().moveTo(x, y);
  }
  /**
   * adds a straight line to the current sub-path by connecting the sub-path's last point to the specified (x, y) coordinates.
   */
  lineTo(x, y) {
    this.getContext().lineTo(x, y);
  }
  /**
   * creates a rectangular path whose starting point is at (x, y) and whose size is specified by width and height.
   * @param {number} x - The x axis of the coordinate for the rectangle starting point.
   * @param {number} y - The y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   */
  rect(x, y, width, height) {
    this.getContext().rect(x, y, width, height);
  }
  /**
   * adds a rounded rectangle to the current path.
   * @param {number} x - The x axis of the coordinate for the rectangle starting point.
   * @param {number} y - The y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   * @param {number} radius - The corner radius.
   */
  roundRect(x, y, width, height, radii) {
    this.getContext().roundRect(x, y, width, height, radii);
  }
  /**
   * stroke the given shape or the current defined path
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [shape] - a shape object to stroke
   * @param {boolean} [fill=false] - fill the shape with the current color if true
   */
  stroke(shape, fill) {
    if (typeof shape === "undefined") {
      if (fill === true) {
        this.getContext().fill();
      } else {
        this.getContext().stroke();
      }
    } else {
      super.stroke(shape, fill);
    }
  }
  /**
   * fill the given shape or the current defined path
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [shape] - a shape object to fill
   */
  fill(shape) {
    this.stroke(shape, true);
  }
  /**
   * add a straight line from the current point to the start of the current sub-path. If the shape has already been closed or has only one point, this function does nothing
  */
  closePath() {
    this.getContext().closePath();
  }
  /**
   * Stroke an arc at the specified coordinates with given radius, start and end points
   * @param {number} x - arc center point x-axis
   * @param {number} y - arc center point y-axis
   * @param {number} radius
   * @param {number} start - start angle in radians
   * @param {number} end - end angle in radians
   * @param {boolean} [antiClockwise=false] - draw arc anti-clockwise
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeArc(x, y, radius, start, end, antiClockwise, fill = false) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    context.translate(x, y);
    context.beginPath();
    context.arc(0, 0, radius, start, end, antiClockwise || false);
    context[fill === true ? "fill" : "stroke"]();
    context.translate(-x, -y);
  }
  /**
   * Fill an arc at the specified coordinates with given radius, start and end points
   * @param {number} x - arc center point x-axis
   * @param {number} y - arc center point y-axis
   * @param {number} radius
   * @param {number} start - start angle in radians
   * @param {number} end - end angle in radians
   * @param {boolean} [antiClockwise=false] - draw arc anti-clockwise
   */
  fillArc(x, y, radius, start, end, antiClockwise) {
    this.strokeArc(x, y, radius, start, end, antiClockwise || false, true);
  }
  /**
   * Stroke an ellipse at the specified coordinates with given radius
   * @param {number} x - ellipse center point x-axis
   * @param {number} y - ellipse center point y-axis
   * @param {number} w - horizontal radius of the ellipse
   * @param {number} h - vertical radius of the ellipse
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeEllipse(x, y, w, h, fill = false) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    let hw = w, hh = h, lx = x - hw, rx = x + hw, ty = y - hh, by = y + hh;
    let xmagic = hw * 0.551784, ymagic = hh * 0.551784, xmin = x - xmagic, xmax = x + xmagic, ymin = y - ymagic, ymax = y + ymagic;
    context.beginPath();
    context.moveTo(x, ty);
    context.bezierCurveTo(xmax, ty, rx, ymin, rx, y);
    context.bezierCurveTo(rx, ymax, xmax, by, x, by);
    context.bezierCurveTo(xmin, by, lx, ymax, lx, y);
    context.bezierCurveTo(lx, ymin, xmin, ty, x, ty);
    context[fill === true ? "fill" : "stroke"]();
    context.closePath();
  }
  /**
   * Fill an ellipse at the specified coordinates with given radius
   * @param {number} x - ellipse center point x-axis
   * @param {number} y - ellipse center point y-axis
   * @param {number} w - horizontal radius of the ellipse
   * @param {number} h - vertical radius of the ellipse
   */
  fillEllipse(x, y, w, h) {
    this.strokeEllipse(x, y, w, h, true);
  }
  /**
   * Stroke a line of the given two points
   * @param {number} startX - the start x coordinate
   * @param {number} startY - the start y coordinate
   * @param {number} endX - the end x coordinate
   * @param {number} endY - the end y coordinate
   */
  strokeLine(startX, startY, endX, endY) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    context.beginPath();
    context.moveTo(startX, startY);
    context.lineTo(endX, endY);
    context.stroke();
  }
  /**
   * Fill a line of the given two points
   * @param {number} startX - the start x coordinate
   * @param {number} startY - the start y coordinate
   * @param {number} endX - the end x coordinate
   * @param {number} endY - the end y coordinate
   */
  fillLine(startX, startY, endX, endY) {
    this.strokeLine(startX, startY, endX, endY);
  }
  /**
   * Stroke the given me.Polygon on the screen
   * @param {Polygon} poly - the shape to draw
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokePolygon(poly, fill = false) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    let points = poly.points;
    let pointsLength = points.length;
    let firstPoint = points[0];
    this.translate(poly.pos.x, poly.pos.y);
    context.beginPath();
    context.moveTo(firstPoint.x, firstPoint.y);
    for (let i = 1; i < pointsLength; i++) {
      const point = points[i];
      context.lineTo(point.x, point.y);
    }
    context.lineTo(firstPoint.x, firstPoint.y);
    context[fill === true ? "fill" : "stroke"]();
    context.closePath();
    this.translate(-poly.pos.x, -poly.pos.y);
  }
  /**
   * Fill the given me.Polygon on the screen
   * @param {Polygon} poly - the shape to draw
   */
  fillPolygon(poly) {
    this.strokePolygon(poly, true);
  }
  /**
   * Stroke a rectangle at the specified coordinates
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeRect(x, y, width, height, fill = false) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    context[fill === true ? "fillRect" : "strokeRect"](x, y, width, height);
  }
  /**
   * Draw a filled rectangle at the specified coordinates
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  fillRect(x, y, width, height) {
    this.strokeRect(x, y, width, height, true);
  }
  /**
   * Stroke a rounded rectangle at the specified coordinates
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} radius
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeRoundRect(x, y, width, height, radius, fill = false) {
    if (this.getGlobalAlpha() < 1 / 255) {
      return;
    }
    let context = this.getContext();
    context.beginPath();
    context.roundRect(x, y, width, height, radius);
    context[fill === true ? "fill" : "stroke"]();
  }
  /**
   * Draw a rounded filled rectangle at the specified coordinates
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} radius
   */
  fillRoundRect(x, y, width, height, radius) {
    this.strokeRoundRect(x, y, width, height, radius, true);
  }
  /**
   * Stroke a Point at the specified coordinates
   * @param {number} x
   * @param {number} y
   */
  strokePoint(x, y) {
    this.strokeLine(x, y, x + 1, y + 1);
  }
  /**
   * Draw a a point at the specified coordinates
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  fillPoint(x, y) {
    this.strokePoint(x, y);
  }
  /**
   * restores the most recently saved renderer state by popping the top entry in the drawing state stack
   * @example
   * // Save the current state
   * renderer.save();
   *
   * // apply a transform and draw a rect
   * renderer.tranform(matrix);
   * renderer.fillRect(10, 10, 100, 100);
   *
   * // Restore to the state saved by the most recent call to save()
   * renderer.restore();
   */
  restore() {
    const canvas = this.getCanvas();
    this.getContext().restore();
    this.currentColor.glArray[3] = this.getGlobalAlpha();
    this.currentScissor[0] = 0;
    this.currentScissor[1] = 0;
    this.currentScissor[2] = canvas.width;
    this.currentScissor[3] = canvas.height;
  }
  /**
   * saves the entire state of the renderer by pushing the current state onto a stack.
   * @example
   * // Save the current state
   * renderer.save();
   *
   * // apply a transform and draw a rect
   * renderer.tranform(matrix);
   * renderer.fillRect(10, 10, 100, 100);
   *
   * // Restore to the state saved by the most recent call to save()
   * renderer.restore();
   */
  save() {
    this.getContext().save();
  }
  /**
   * adds a rotation to the transformation matrix.
   * @param {number} angle - the rotation angle, clockwise in radians
   * @example
   * // Rotated rectangle
   * renderer.rotate((45 * Math.PI) / 180);
   * renderer.setColor("red");
   * renderer.fillRect(10, 10, 100, 100);
   *
   * // Reset transformation matrix to the identity matrix
   * renderer.setTransform(1, 0, 0, 1, 0, 0);
   */
  rotate(angle) {
    this.getContext().rotate(angle);
  }
  /**
   * adds a scaling transformation to the renderer units horizontally and/or vertically
   * @param {number} x - Scaling factor in the horizontal direction. A negative value flips pixels across the vertical axis. A value of 1 results in no horizontal scaling.
   * @param {number} y - Scaling factor in the vertical direction. A negative value flips pixels across the horizontal axis. A value of 1 results in no vertical scaling
   */
  scale(x, y) {
    this.getContext().scale(x, y);
  }
  /**
   * Set the current fill & stroke style color.
   * By default, or upon reset, the value is set to #000000.
   * @param {Color|string} color - css color value
   */
  setColor(color) {
    let currentColor = this.currentColor;
    let context = this.getContext();
    currentColor.copy(color);
    context.strokeStyle = context.fillStyle = currentColor.toRGBA();
  }
  /**
   * Set the global alpha
   * @param {number} alpha - 0.0 to 1.0 values accepted.
   */
  setGlobalAlpha(alpha2) {
    this.getContext().globalAlpha = alpha2;
  }
  /**
   * Return the global alpha
   * @returns {number} global alpha value
   */
  getGlobalAlpha() {
    return this.getContext().globalAlpha;
  }
  /**
   * sets or returns the thickness of lines for shape drawing
   * @type {number}
   * @default 1
   */
  get lineWidth() {
    return this.getContext().lineWidth;
  }
  /**
   * @ignore
   */
  set lineWidth(value) {
    this.getContext().lineWidth = value;
    return value;
  }
  /**
   * sets or returns the shape used to join two line segments where they meet.
   * There are three possible values for this property: "round", "bevel", and "miter"
   * @type {string}
   * @default "miter"
   */
  get lineJoin() {
    return this.getContext().lineJoin;
  }
  /**
   * @ignore
   */
  set lineJoin(value) {
    let context = this.getContext();
    context.lineJoin = value;
    return context.lineJoin;
  }
  /**
   * Reset (overrides) the renderer transformation matrix to the
   * identity one, and then apply the given transformation matrix.
   * @param {Matrix2d|number} a - a matrix2d to transform by, or a the a component to multiply the current matrix by
   * @param {number} b - the b component to multiply the current matrix by
   * @param {number} c - the c component to multiply the current matrix by
   * @param {number} d - the d component to multiply the current matrix by
   * @param {number} e - the e component to multiply the current matrix by
   * @param {number} f - the f component to multiply the current matrix by
   */
  setTransform(a, b, c, d, e, f2) {
    this.resetTransform();
    this.transform(a, b, c, d, e, f2);
  }
  /**
   * Multiply given matrix into the renderer tranformation matrix
   * @see {@link CanvasRenderer.setTransform} which will reset the current transform matrix prior to performing the new transformation
   * @param {Matrix2d|number} a - a matrix2d to transform by, or a the a component to multiply the current matrix by
   * @param {number} b - the b component to multiply the current matrix by
   * @param {number} c - the c component to multiply the current matrix by
   * @param {number} d - the d component to multiply the current matrix by
   * @param {number} e - the e component to multiply the current matrix by
   * @param {number} f - the f component to multiply the current matrix by
   */
  transform(a, b, c, d, e, f2) {
    if (typeof a === "object") {
      let m = a.toArray();
      a = m[0];
      b = m[1];
      c = m[3];
      d = m[4];
      e = m[6];
      f2 = m[7];
    }
    if (this.settings.subPixel === false) {
      e |= 0;
      f2 |= 0;
    }
    this.getContext().transform(a, b, c, d, e, f2);
  }
  /**
   * adds a translation transformation to the current matrix.
   * @param {number} x - Distance to move in the horizontal direction. Positive values are to the right, and negative to the left.
   * @param {number} y - Distance to move in the vertical direction. Positive values are down, and negative are up.
   */
  translate(x, y) {
    if (this.settings.subPixel === false) {
      this.getContext().translate(~~x, ~~y);
    } else {
      this.getContext().translate(x, y);
    }
  }
  /**
   * clip the given region from the original canvas. Once a region is clipped,
   * all future drawing will be limited to the clipped region.
   * You can however save the current region using the save(),
   * and restore it (with the restore() method) any time in the future.
   * (<u>this is an experimental feature !</u>)
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  clipRect(x, y, width, height) {
    let canvas = this.getCanvas();
    if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
      let currentScissor = this.currentScissor;
      if (currentScissor[0] !== x || currentScissor[1] !== y || currentScissor[2] !== width || currentScissor[3] !== height) {
        let context = this.getContext();
        context.beginPath();
        context.rect(x, y, width, height);
        context.clip();
        currentScissor[0] = x;
        currentScissor[1] = y;
        currentScissor[2] = width;
        currentScissor[3] = height;
      }
    }
  }
  /**
   * A mask limits rendering elements to the shape and position of the given mask object.
   * If the drawing or rendering area is larger than the mask, only the intersecting part of the renderable will be visible.
   * (Note Mask are not preserved through renderer context save and restore and need so be manually cleared)
   * @see CanvasRenderer#clearMask
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [mask] - the shape defining the mask to be applied
   * @param {boolean} [invert=false] - either the given shape should define what is visible (default) or the opposite
   */
  setMask(mask, invert = false) {
    let context = this.getContext();
    if (this.maskLevel === 0) {
      context.save();
      if (typeof mask !== "undefined") {
        context.beginPath();
      }
    }
    if (typeof mask !== "undefined") {
      switch (mask.type) {
        case "RoundRect":
          context.roundRect(mask.top, mask.left, mask.width, mask.height, mask.radius);
          break;
        case "Rectangle":
        case "Bounds":
          context.rect(mask.top, mask.left, mask.width, mask.height);
          break;
        case "Polygon":
          {
            const _x = mask.pos.x, _y = mask.pos.y;
            context.moveTo(_x + mask.points[0].x, _y + mask.points[0].y);
            for (let i = 1; i < mask.points.length; i++) {
              const point = mask.points[i];
              context.lineTo(_x + point.x, _y + point.y);
            }
          }
          break;
        case "Ellipse":
          {
            const _x = mask.pos.x, _y = mask.pos.y, hw = mask.radiusV.x, hh = mask.radiusV.y, lx = _x - hw, rx = _x + hw, ty = _y - hh, by = _y + hh;
            let xmagic = hw * 0.551784, ymagic = hh * 0.551784, xmin = _x - xmagic, xmax = _x + xmagic, ymin = _y - ymagic, ymax = _y + ymagic;
            context.moveTo(_x, ty);
            context.bezierCurveTo(xmax, ty, rx, ymin, rx, _y);
            context.bezierCurveTo(rx, ymax, xmax, by, _x, by);
            context.bezierCurveTo(xmin, by, lx, ymax, lx, _y);
            context.bezierCurveTo(lx, ymin, xmin, ty, _x, ty);
          }
          break;
        default:
          throw new Error("Invalid geometry for setMask");
      }
    }
    this.maskLevel++;
    if (invert === true) {
      context.closePath();
      context.globalCompositeOperation = "destination-atop";
      context.fill();
    } else {
      context.clip();
    }
  }
  /**
   * disable (remove) the rendering mask set through setMask.
   * @see CanvasRenderer#setMask
   */
  clearMask() {
    if (this.maskLevel > 0) {
      this.maskLevel = 0;
      this.getContext().restore();
    }
  }
};
function initArray(rows, cols) {
  let array = new Array(cols);
  for (let col = 0; col < cols; col++) {
    array[col] = new Array(rows);
    for (let row = 0; row < rows; row++) {
      array[col][row] = null;
    }
  }
  return array;
}
function setLayerData(layer, bounds, data2) {
  let idx = 0;
  let width, height;
  if (typeof bounds.rows === "undefined") {
    width = bounds.width;
    height = bounds.height;
  } else {
    width = bounds.cols;
    height = bounds.rows;
  }
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const gid = data2[idx++];
      if (gid !== 0) {
        layer.layerData[x + bounds.x][y + bounds.y] = layer.getTileById(gid, x + bounds.x, y + bounds.y);
      }
    }
  }
}
var TMXLayer = class extends Renderable {
  /**
   * @param {object} map - layer data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#layer})
   * @param {object} data - layer data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#layer})
   * @param {number} tilewidth - width of each tile in pixels
   * @param {number} tileheight - height of each tile in pixels
   * @param {string} orientation - "isometric" or "orthogonal"
   * @param {TMXTilesetGroup} tilesets - tileset as defined in Tiled
   * @param {number} z - z-index position
   */
  constructor(map, data2, tilewidth, tileheight, orientation2, tilesets, z) {
    super(0, 0, 0, 0);
    this.tilewidth = data2.tilewidth || tilewidth;
    this.tileheight = data2.tileheight || tileheight;
    this.orientation = orientation2;
    this.x = 0;
    this.y = 0;
    this.tilesets = tilesets;
    this.tileset = this.tilesets ? this.tilesets.getTilesetByIndex(0) : null;
    this.maxTileSize = {
      "width": 0,
      "height": 0
    };
    for (let i = 0; i < this.tilesets.length; i++) {
      const tileset = this.tilesets.getTilesetByIndex(i);
      this.maxTileSize.width = Math.max(this.maxTileSize.width, tileset.tilewidth);
      this.maxTileSize.height = Math.max(this.maxTileSize.height, tileset.tileheight);
    }
    this.animatedTilesets = [];
    this.isAnimated = false;
    this.renderorder = data2.renderorder || "right-down";
    this.class = data2.class;
    this.pos.z = z;
    this.anchorPoint.set(0, 0);
    this.name = data2.name;
    this.cols = +data2.width;
    this.rows = +data2.height;
    let visible = typeof data2.visible !== "undefined" ? +data2.visible : 1;
    this.setOpacity(visible ? +data2.opacity : 0);
    if (typeof data2.tintcolor === "string") {
      this.tint.parseHex(data2.tintcolor, true);
    }
    if (this.orientation === "isometric") {
      this.width = (this.cols + this.rows) * (this.tilewidth / 2);
      this.height = (this.cols + this.rows) * (this.tileheight / 2);
    } else {
      this.width = this.cols * this.tilewidth;
      this.height = this.rows * this.tileheight;
    }
    applyTMXProperties(this, data2);
    this.setRenderer(map.getRenderer());
    this.layerData = initArray(this.rows, this.cols);
    if (map.infinite === 0) {
      setLayerData(
        this,
        this,
        decode(
          data2.data,
          data2.encoding,
          data2.compression
        )
      );
    } else if (map.infinite === 1) {
      data2.chunks.forEach((chunk) => {
        setLayerData(
          this,
          chunk,
          decode(
            chunk.data,
            data2.encoding,
            data2.compression
          )
        );
      });
    }
  }
  // called when the layer is added to the game world or a container
  onActivateEvent() {
    if (this.animatedTilesets === void 0) {
      this.animatedTilesets = [];
    }
    if (this.tilesets) {
      let tileset = this.tilesets.tilesets;
      for (let i = 0; i < tileset.length; i++) {
        if (tileset[i].isAnimated) {
          this.animatedTilesets.push(tileset[i]);
        }
      }
    }
    this.isAnimated = this.animatedTilesets.length > 0;
    if (typeof this.preRender === "undefined" && this.isAnimated === false) {
      this.preRender = this.ancestor.getRootAncestor().preRender;
    } else {
      this.preRender = false;
    }
    if (this.preRender === true && !this.canvasRenderer) {
      this.canvasRenderer = new CanvasRenderer({
        canvas: createCanvas(this.width, this.height),
        width: this.width,
        heigth: this.height,
        transparent: true
      });
      this.getRenderer().drawTileLayer(this.canvasRenderer, this, this);
    }
    this.isDirty = true;
  }
  // called when the layer is removed from the game world or a container
  onDeactivateEvent() {
    this.animatedTilesets = void 0;
  }
  /**
   * Set the TMX renderer for this layer object
   * @param {TMXRenderer} renderer
   * @example
   * // use the parent map default renderer
   * let layer = new me.TMXLayer(...);
   * layer.setRenderer(map.getRenderer());
   */
  setRenderer(renderer2) {
    this.renderer = renderer2;
    this.isDirty = true;
  }
  /**
   * Return the layer current renderer object
   * @returns {TMXRenderer} renderer
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * Return the TileId of the Tile at the specified position
   * @param {number} x - X coordinate (in world/pixels coordinates)
   * @param {number} y - Y coordinate (in world/pixels coordinates)
   * @returns {number} TileId or null if there is no Tile at the given position
   */
  getTileId(x, y) {
    let tile = this.getTile(x, y);
    return tile ? tile.tileId : null;
  }
  /**
   * Return the Tile object at the specified position
   * @param {number} x - X coordinate (in world/pixels coordinates)
   * @param {number} y - Y coordinate (in world/pixels coordinates)
   * @returns {Tile} corresponding tile or null if there is no defined tile at the coordinate or if outside of the layer bounds
   * @example
   * // get the TMX Map Layer called "Front layer"
   * let layer = me.game.world.getChildByName("Front Layer")[0];
   * // get the tile object corresponding to the latest pointer position
   * let tile = layer.getTile(me.input.pointer.x, me.input.pointer.y);
   */
  getTile(x, y) {
    let tile = null;
    if (this.contains(x, y)) {
      let coord = this.getRenderer().pixelToTileCoords(x, y, pool.pull("Vector2d"));
      tile = this.cellAt(coord.x, coord.y);
      pool.push(coord);
    }
    return tile;
  }
  /**
   * assign the given Tile object to the specified position
   * @param {Tile} tile - the tile object to be assigned
   * @param {number} x - x coordinate (in world/pixels coordinates)
   * @param {number} y - y coordinate (in world/pixels coordinates)
   * @returns {Tile} the tile object
   */
  setTile(tile, x, y) {
    this.layerData[x][y] = tile;
    this.isDirty = true;
    return tile;
  }
  /**
   * return a new the Tile object corresponding to the given tile id
   * @param {number} tileId - tileId
   * @param {number} x - X coordinate (in world/pixels coordinates)
   * @param {number} y - Y coordinate (in world/pixels coordinates)
   * @returns {Tile} the tile object
   */
  getTileById(tileId, x, y) {
    if (!this.tileset.contains(tileId)) {
      this.tileset = this.tilesets.getTilesetByGid(tileId);
    }
    return new Tile(x, y, tileId, this.tileset);
  }
  /**
   * Return the Tile object at the specified tile coordinates
   * @param {number} x - x position of the tile (in Tile unit)
   * @param {number} y - x position of the tile (in Tile unit)
   * @param {number} [boundsCheck=true] - check first if within the layer bounds
   * @returns {Tile} corresponding tile or null if there is no defined tile at the position or if outside of the layer bounds
   * @example
   * // return the first tile at offset 0, 0
   * let tile = layer.cellAt(0, 0);
   */
  cellAt(x, y, boundsCheck) {
    let _x = ~~x;
    let _y = ~~y;
    let renderer2 = this.getRenderer();
    if (boundsCheck === false || _x >= 0 && _x < renderer2.cols && _y >= 0 && _y < renderer2.rows) {
      return this.layerData[_x][_y];
    } else {
      return null;
    }
  }
  /**
   * clear the tile at the specified position
   * @param {number} x - X coordinate (in map coordinates: row/column)
   * @param {number} y - Y coordinate (in map coordinates: row/column)
   * @example
   * me.game.world.getChildByType(me.TMXLayer).forEach(function(layer) {
   *     // clear all tiles at the given x,y coordinates
   *     layer.clearTile(x, y);
   * });
   */
  clearTile(x, y) {
    this.layerData[x][y] = null;
    if (this.preRender) {
      this.canvasRenderer.clearRect(x * this.tilewidth, y * this.tileheight, this.tilewidth, this.tileheight);
    }
    this.isDirty = true;
  }
  /**
   * update animations in a tileset layer
   * @ignore
   */
  update(dt) {
    let result = this.isDirty;
    if (this.isAnimated) {
      for (let i = 0; i < this.animatedTilesets.length; i++) {
        result = this.animatedTilesets[i].update(dt) || result;
      }
    }
    return result;
  }
  /**
   * draw a tileset layer
   * @ignore
   */
  draw(renderer2, rect) {
    if (this.preRender) {
      const width = Math.min(rect.width, this.width);
      const height = Math.min(rect.height, this.height);
      renderer2.drawImage(
        this.canvasRenderer.getCanvas(),
        rect.pos.x,
        rect.pos.y,
        // sx,sy
        width,
        height,
        // sw,sh
        rect.pos.x,
        rect.pos.y,
        // dx,dy
        width,
        height
        // dw,dh
      );
    } else {
      this.getRenderer().drawTileLayer(renderer2, this, rect);
    }
  }
};
var TMXGroup = class {
  constructor(map, data2, z) {
    this.name = data2.name;
    this.width = data2.width || 0;
    this.height = data2.height || 0;
    this.tintcolor = data2.tintcolor;
    this.class = data2.class;
    this.z = z;
    this.objects = [];
    let visible = typeof data2.visible !== "undefined" ? data2.visible : true;
    this.opacity = visible === true ? clamp(+data2.opacity || 1, 0, 1) : 0;
    applyTMXProperties(this, data2);
    if (data2.objects) {
      data2.objects.forEach((object) => {
        object.tintcolor = this.tintcolor;
        this.objects.push(new TMXObject(map, object, z));
      });
    }
    if (data2.layers) {
      data2.layers.forEach((data3) => {
        let layer = new TMXLayer(map, data3, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z++);
        layer.setRenderer(map.getRenderer());
        this.width = Math.max(this.width, layer.width);
        this.height = Math.max(this.height, layer.height);
        this.objects.push(layer);
      });
    }
  }
  /**
   * reset function
   * @ignore
   */
  destroy() {
    this.objects = null;
  }
  /**
   * return the object count
   * @ignore
   */
  getObjectCount() {
    return this.objects.length;
  }
  /**
   * returns the object at the specified index
   * @ignore
   */
  getObjectByIndex(idx) {
    return this.objects[idx];
  }
};
function deferredRemove(child, keepalive) {
  this.removeChildNow(child, keepalive);
}
var globalFloatingCounter = 0;
var Container = class _Container extends Renderable {
  /**
   * @param {number} [x=0] - position of the container (accessible via the inherited pos.x property)
   * @param {number} [y=0] - position of the container (accessible via the inherited pos.y property)
   * @param {number} [width=game.viewport.width] - width of the container
   * @param {number} [height=game.viewport.height] - height of the container
   */
  constructor(x = 0, y = 0, width, height, root = false) {
    super(
      x,
      y,
      typeof width === "undefined" ? typeof game.viewport !== "undefined" ? game.viewport.width : Infinity : width,
      typeof height === "undefined" ? typeof game.viewport !== "undefined" ? game.viewport.height : Infinity : height
    );
    this.pendingSort = null;
    this.root = root;
    this.children = void 0;
    this.sortOn = "z";
    this.autoSort = true;
    this.autoDepth = true;
    this.clipping = false;
    this.onChildChange = function(index2) {
    };
    this.enableChildBoundsUpdate = false;
    this.backgroundColor = pool.pull("Color", 0, 0, 0, 0);
    this.drawCount = 0;
    this.autoTransform = true;
    this.isKinematic = false;
    this.anchorPoint.set(0, 0);
    if (this.root === true) {
      on(CANVAS_ONRESIZE, () => {
        this.enableChildBoundsUpdate === true;
        this.updateBounds();
        this.enableChildBoundsUpdate === false;
      });
    }
  }
  /**
   * reset the container, removing all childrens, and reseting transforms.
   */
  reset() {
    if (this.pendingSort) {
      clearTimeout(this.pendingSort);
      this.pendingSort = null;
    }
    let children = this.getChildren();
    for (let i = children.length, child; i >= 0; child = children[--i]) {
      if (child && child.isPersistent !== true) {
        this.removeChildNow(child);
      }
    }
    if (typeof this.currentTransform !== "undefined") {
      this.currentTransform.identity();
    }
    this.backgroundColor.setColor(0, 0, 0, 0);
  }
  /**
   * Add a child to the container <br>
   * if auto-sort is disable, the object will be appended at the bottom of the list.
   * Adding a child to the container will automatically remove it from its other container.
   * Meaning a child can only have one parent. This is important if you add a renderable
   * to a container then add it to the World container it will move it out of the
   * orginal container. Then when the World container reset() method is called the renderable
   * will not be in any container. <br>
   * if the given child implements a onActivateEvent method, that method will be called
   * once the child is added to this container.
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be added
   * @param {number} [z] - forces the z index of the child to the specified value
   * @returns {Renderable} the added child
   */
  addChild(child, z) {
    if (child.ancestor instanceof _Container) {
      child.ancestor.removeChildNow(child);
    } else {
      if (child.isRenderable) {
        child.GUID = createGUID(child.id);
      }
    }
    child.ancestor = this;
    this.getChildren().push(child);
    if (typeof child.updateBounds === "function") {
      if (this.isFloating === true) {
        child.floating = false;
      }
      child.updateBounds();
    }
    if (typeof child.pos !== "undefined") {
      if (typeof z === "number") {
        child.pos.z = z;
      } else if (this.autoDepth === true) {
        child.pos.z = this.getChildren().length;
      }
    }
    if (this.autoSort === true) {
      this.sort();
    }
    if (typeof child.onActivateEvent === "function" && this.isAttachedToRoot()) {
      child.onActivateEvent();
    }
    if (this.enableChildBoundsUpdate === true) {
      this.updateBounds();
    }
    if (this.isAttachedToRoot()) {
      let worldContainer = this.getRootAncestor();
      if (child.body instanceof Body) {
        worldContainer.addBody(child.body);
      }
      if (child instanceof _Container) {
        child.forEach((cchild) => {
          if (cchild.body instanceof Body) {
            worldContainer.addBody(cchild.body);
          }
        });
      }
    }
    this.isDirty = true;
    this.onChildChange.call(this, this.getChildren().length - 1);
    return child;
  }
  /**
   * Add a child to the container at the specified index<br>
   * (the list won't be sorted after insertion)
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be added
   * @param {number} index - The index at which to insert the child
   * @returns {Renderable} the added child
   */
  addChildAt(child, index2) {
    if (index2 >= 0 && index2 < this.getChildren().length) {
      if (child.ancestor instanceof _Container) {
        child.ancestor.removeChildNow(child);
      } else {
        if (child.isRenderable) {
          child.GUID = createGUID();
        }
      }
      child.ancestor = this;
      this.getChildren().splice(index2, 0, child);
      if (typeof child.updateBounds === "function") {
        if (this.isFloating === true) {
          child.floating = false;
        }
        child.updateBounds();
      }
      if (typeof child.onActivateEvent === "function" && this.isAttachedToRoot()) {
        child.onActivateEvent();
      }
      if (this.enableChildBoundsUpdate === true) {
        this.updateBounds();
      }
      if (this.isAttachedToRoot()) {
        let worldContainer = this.getRootAncestor();
        if (child.body instanceof Body) {
          worldContainer.addBody(child.body);
        }
        if (child instanceof _Container) {
          child.forEach((cchild) => {
            if (cchild.body instanceof Body) {
              worldContainer.addBody(cchild.body);
            }
          });
        }
      }
      this.isDirty = true;
      this.onChildChange.call(this, index2);
      return child;
    } else {
      throw new Error("Index (" + index2 + ") Out Of Bounds for addChildAt()");
    }
  }
  /**
   * The forEach() method executes a provided function once per child element. <br>
   * the callback function is invoked with three arguments: <br>
   *    - The current element being processed in the array <br>
   *    - The index of element in the array. <br>
   *    - The array forEach() was called upon. <br>
   * @param {Function} callback - fnction to execute on each element
   * @param {object} [thisArg] - value to use as this(i.e reference Object) when executing callback.
   * @example
   * // iterate through all children of this container
   * container.forEach((child) => {
   *    // do something with the child
   *    child.doSomething();
   * });
   * container.forEach((child, index) => { ... });
   * container.forEach((child, index, array) => { ... });
   * container.forEach((child, index, array) => { ... }, thisArg);
   */
  forEach(callback, thisArg) {
    let context = this, i = 0;
    let children = this.getChildren();
    let len = children.length;
    if (typeof callback !== "function") {
      throw new Error(callback + " is not a function");
    }
    if (arguments.length > 1) {
      context = thisArg;
    }
    while (i < len) {
      callback.call(context, children[i], i, children);
      i++;
    }
  }
  /**
   * Swaps the position (z-index) of 2 children
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be added
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child2 - Child to be added
   */
  swapChildren(child, child2) {
    let index2 = this.getChildIndex(child);
    let index22 = this.getChildIndex(child2);
    if (index2 !== -1 && index22 !== -1) {
      let _z = child.pos.z;
      child.pos.z = child2.pos.z;
      child2.pos.z = _z;
      this.getChildren()[index2] = child2;
      this.getChildren()[index22] = child;
      this.isDirty = true;
    } else {
      throw new Error(child + " Both the supplied childs must be a child of the caller " + this);
    }
  }
  /**
   * Returns the Child at the specified index
   * @param {number} index - The index of the child
   * @returns {Renderable} the child at the specified index
   */
  getChildAt(index2) {
    if (index2 >= 0 && index2 < this.getChildren().length) {
      return this.getChildren()[index2];
    } else {
      throw new Error("Index (" + index2 + ") Out Of Bounds for getChildAt()");
    }
  }
  /**
   * Returns the index of the given Child
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - The child object
   * @returns {number} index
   */
  getChildIndex(child) {
    return this.getChildren().indexOf(child);
  }
  /**
   * Returns the next child within the container or undefined if none
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - The child object
   * @returns {Renderable} child
   */
  getNextChild(child) {
    let index2 = this.getChildren().indexOf(child) - 1;
    if (index2 >= 0 && index2 < this.getChildren().length) {
      return this.getChildAt(index2);
    }
    return void 0;
  }
  /**
   * Returns true if contains the specified Child
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - The child object
   * @returns {boolean}
   */
  hasChild(child) {
    return this === child.ancestor;
  }
  /**
   * return the child corresponding to the given property and value.<br>
   * note : avoid calling this function every frame since
   * it parses the whole object tree each time
   * @param {string} prop - Property name
   * @param {string|RegExp|number|boolean} value - Value of the property
   * @returns {Renderable[]} Array of childs
   * @example
   * // get the first child object called "mainPlayer" in a specific container :
   * let ent = myContainer.getChildByProp("name", "mainPlayer");
   *
   * // or query the whole world :
   * let ent = container.getChildByProp("name", "mainPlayer");
   *
   * // partial property matches are also allowed by using a RegExp.
   * // the following matches "redCOIN", "bluecoin", "bagOfCoins", etc :
   * let allCoins = container.getChildByProp("name", /coin/i);
   *
   * // searching for numbers or other data types :
   * let zIndex10 = container.getChildByProp("z", 10);
   * let inViewport = container.getChildByProp("inViewport", true);
   */
  getChildByProp(prop, value) {
    let objList = [];
    function compare2(obj, prop2) {
      let v = obj[prop2];
      if (value instanceof RegExp && typeof v === "string") {
        if (value.test(v)) {
          objList.push(obj);
        }
      } else if (v === value) {
        objList.push(obj);
      }
    }
    this.forEach((child) => {
      compare2(child, prop);
      if (child instanceof _Container) {
        objList = objList.concat(child.getChildByProp(prop, value));
      }
    });
    return objList;
  }
  /**
   * returns the list of childs with the specified class type
   * @param {object} classType - Class type
   * @returns {Renderable[]} Array of children
   */
  getChildByType(classType) {
    let objList = [];
    this.forEach((child) => {
      if (child instanceof classType) {
        objList.push(child);
      }
      if (child instanceof _Container) {
        objList = objList.concat(child.getChildByType(classType));
      }
    });
    return objList;
  }
  /**
   * returns the list of childs with the specified name<br>
   * as defined in Tiled (Name field of the Object Properties)<br>
   * note : avoid calling this function every frame since
   * it parses the whole object list each time
   * @param {string|RegExp|number|boolean} name - child name
   * @returns {Renderable[]} Array of children
   */
  getChildByName(name) {
    return this.getChildByProp("name", name);
  }
  /**
   * return the child corresponding to the specified GUID<br>
   * note : avoid calling this function every frame since
   * it parses the whole object list each time
   * @param {string|RegExp|number|boolean} guid - child GUID
   * @returns {Renderable} corresponding child or null
   */
  getChildByGUID(guid) {
    let obj = this.getChildByProp("GUID", guid);
    return obj.length > 0 ? obj[0] : null;
  }
  /**
   * return all child in this container
   * @returns {Renderable[]} an array of renderable object
   */
  getChildren() {
    if (typeof this.children === "undefined") {
      this.children = [];
    }
    return this.children;
  }
  /**
   * update the bounding box for this container.
   * @param {boolean} [absolute=true] - update the bounds size and position in (world) absolute coordinates
   * @returns {Bounds} this container bounding box Rectangle object
   */
  updateBounds(absolute = true) {
    let bounds = this.getBounds();
    super.updateBounds(absolute);
    if (this.enableChildBoundsUpdate === true) {
      this.forEach((child) => {
        if (child.isRenderable) {
          let childBounds = child.updateBounds(true);
          if (childBounds.isFinite()) {
            bounds.addBounds(childBounds);
          }
        }
      });
    }
    return bounds;
  }
  /**
   * Checks if this container is root or if it's attached to the root container.
   * @returns {boolean} true if this container is root or if it's attached to the root container
   */
  isAttachedToRoot() {
    if (this.root === true) {
      return true;
    } else {
      let ancestor = this.ancestor;
      while (ancestor) {
        if (ancestor.root === true) {
          return true;
        }
        ancestor = ancestor.ancestor;
      }
      return false;
    }
  }
  /**
   * Returns the instance of the root container (i.e. the current application World container).
   * @returns {Container} root container
   */
  getRootAncestor() {
    if (this.root === true) {
      return this;
    } else {
      let ancestor = this.ancestor;
      while (ancestor) {
        if (ancestor.root === true) {
          break;
        }
        ancestor = ancestor.ancestor;
      }
      return ancestor;
    }
  }
  /**
   * update the cointainer's bounding rect (private)
   * @ignore
   */
  updateBoundsPos(newX = this.pos.x, newY = this.pos.y) {
    super.updateBoundsPos(newX, newY);
    this.forEach((child) => {
      if (child.isRenderable) {
        child.updateBoundsPos(
          child.pos.x + newX - this.pos.x,
          child.pos.y + newY - this.pos.y
        );
      }
    });
  }
  /**
   * @ignore
   */
  onActivateEvent() {
    this.forEach((child) => {
      if (typeof child.onActivateEvent === "function") {
        child.onActivateEvent();
      }
    });
  }
  /**
   * Invokes the removeChildNow in a defer, to ensure the child is removed safely after the update & draw stack has completed. <br>
   * if the given child implements a onDeactivateEvent() method, that method will be called once the child is removed from this container.
   * @param {Renderable|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be removed
   * @param {boolean} [keepalive=false] - true to prevent calling child.destroy()
   */
  removeChild(child, keepalive) {
    if (this.hasChild(child)) {
      defer(deferredRemove, this, child, keepalive);
    } else {
      throw new Error("Child is not mine.");
    }
  }
  /**
   * Removes (and optionally destroys) a child from the container.<br>
   * (removal is immediate and unconditional)<br>
   * Never use keepalive=true with objects from {@link pool}. Doing so will create a memory leak.
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be removed
   * @param {boolean} [keepalive=False] - True to prevent calling child.destroy()
   */
  removeChildNow(child, keepalive) {
    if (this.hasChild(child) && this.getChildIndex(child) >= 0) {
      if (typeof child.onDeactivateEvent === "function") {
        child.onDeactivateEvent();
      }
      if (child.body instanceof Body) {
        this.getRootAncestor().removeBody(child.body);
      }
      if (!keepalive) {
        if (pool.push(child, false) === false) {
          if (typeof child.destroy === "function") {
            child.destroy();
          }
        }
      }
      let childIndex = this.getChildIndex(child);
      if (childIndex >= 0) {
        this.getChildren().splice(childIndex, 1);
        child.ancestor = void 0;
      }
      if (this.enableChildBoundsUpdate === true) {
        this.updateBounds();
      }
      this.isDirty = true;
      this.onChildChange.call(this, childIndex);
    }
  }
  /**
   * Automatically set the specified property of all childs to the given value
   * @param {string} prop - property name
   * @param {object} value - property value
   * @param {boolean} [recursive=false] - recursively apply the value to child containers if true
   */
  setChildsProperty(prop, value, recursive) {
    this.forEach((child) => {
      if (recursive === true && child instanceof _Container) {
        child.setChildsProperty(prop, value, recursive);
      }
      child[prop] = value;
    });
  }
  /**
   * Move the child in the group one step forward (z depth).
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child -  Child to be moved
   */
  moveUp(child) {
    let childIndex = this.getChildIndex(child);
    if (childIndex - 1 >= 0) {
      this.swapChildren(child, this.getChildAt(childIndex - 1));
      this.isDirty = true;
    }
  }
  /**
   * Move the child in the group one step backward (z depth).
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be moved
   */
  moveDown(child) {
    let childIndex = this.getChildIndex(child);
    if (childIndex >= 0 && childIndex + 1 < this.getChildren().length) {
      this.swapChildren(child, this.getChildAt(childIndex + 1));
      this.isDirty = true;
    }
  }
  /**
   * Move the specified child to the top(z depth).
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be moved
   */
  moveToTop(child) {
    let childIndex = this.getChildIndex(child);
    if (childIndex > 0) {
      let children = this.getChildren();
      children.splice(0, 0, children.splice(childIndex, 1)[0]);
      child.pos.z = children[1].pos.z + 1;
      this.isDirty = true;
    }
  }
  /**
   * Move the specified child the bottom (z depth).
   * @param {Renderable|Entity|Sprite|Collectable|Trigger|Draggable|DropTarget|NineSliceSprite|ImageLayer|ColorLayer|Light2d|UIBaseElement|UISpriteElement|UITextButton|Text|BitmapText} child - Child to be moved
   */
  moveToBottom(child) {
    let childIndex = this.getChildIndex(child);
    let children = this.getChildren();
    if (childIndex >= 0 && childIndex < children.length - 1) {
      children.splice(children.length - 1, 0, children.splice(childIndex, 1)[0]);
      child.pos.z = children[children.length - 2].pos.z - 1;
      this.isDirty = true;
    }
  }
  /**
   * Manually trigger the sort of all the childs in the container
   * @param {boolean} [recursive=false] - recursively sort all containers if true
   */
  sort(recursive) {
    if (!this.pendingSort) {
      if (recursive === true) {
        this.forEach((child) => {
          if (child instanceof _Container) {
            child.sort(recursive);
          }
        });
      }
      this.pendingSort = defer(function() {
        this.getChildren().sort(this["_sort" + this.sortOn.toUpperCase()]);
        this.pendingSort = null;
        this.isDirty = true;
      }, this);
    }
  }
  /**
   * @ignore
   */
  onDeactivateEvent() {
    this.forEach((child) => {
      if (typeof child.onDeactivateEvent === "function") {
        child.onDeactivateEvent();
      }
    });
  }
  /**
   * Z Sorting function
   * @ignore
   */
  _sortZ(a, b) {
    return b.pos && a.pos ? b.pos.z - a.pos.z : a.pos ? -Infinity : Infinity;
  }
  /**
   * Reverse Z Sorting function
   * @ignore
   */
  _sortReverseZ(a, b) {
    return a.pos && b.pos ? a.pos.z - b.pos.z : a.pos ? Infinity : -Infinity;
  }
  /**
   * X Sorting function
   * @ignore
   */
  _sortX(a, b) {
    if (!b.pos || !a.pos) {
      return a.pos ? -Infinity : Infinity;
    }
    let result = b.pos.z - a.pos.z;
    return result ? result : b.pos.x - a.pos.x;
  }
  /**
   * Y Sorting function
   * @ignore
   */
  _sortY(a, b) {
    if (!b.pos || !a.pos) {
      return a.pos ? -Infinity : Infinity;
    }
    let result = b.pos.z - a.pos.z;
    return result ? result : b.pos.y - a.pos.y;
  }
  /**
   * Destroy function<br>
   * @ignore
   */
  destroy() {
    this.reset();
    super.destroy(arguments);
  }
  /**
   * container update function. <br>
   * automatically called by the application update loop {@link Application}
   * @protected
   * @param {number} dt - time since the last update in milliseconds.
   * @returns {boolean} true if the Container is dirty
   */
  update(dt) {
    let isFloating = false;
    let isPaused = state.isPaused();
    let children = this.getChildren();
    const childrenLength = children.length;
    for (let i = childrenLength, obj; i--, obj = children[i]; ) {
      if (isPaused && !obj.updateWhenPaused) {
        continue;
      }
      if (obj.isRenderable) {
        isFloating = globalFloatingCounter > 0 || obj.floating;
        if (isFloating) {
          globalFloatingCounter++;
        }
        obj.inViewport = false;
        state.current().cameras.forEach((camera) => {
          if (camera.isVisible(obj, isFloating)) {
            obj.inViewport = true;
          }
        });
        this.isDirty |= (obj.inViewport || obj.alwaysUpdate) && obj.update(dt);
        if (globalFloatingCounter > 0) {
          globalFloatingCounter--;
        }
      } else {
        this.isDirty |= obj.update(dt);
      }
    }
    return super.update(dt);
  }
  /**
   * draw this renderable (automatically called by melonJS)
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
    let isFloating = false;
    let bounds = this.getBounds();
    this.drawCount = 0;
    if (this.root === false && this.clipping === true && bounds.isFinite() === true) {
      renderer2.clipRect(
        bounds.left,
        bounds.top,
        bounds.width,
        bounds.height
      );
    }
    renderer2.translate(this.pos.x, this.pos.y);
    if (this.backgroundColor.alpha > 1 / 255) {
      renderer2.clearColor(this.backgroundColor);
    }
    let children = this.getChildren();
    for (let i = children.length, obj; i--, obj = children[i]; ) {
      if (obj.isRenderable) {
        isFloating = obj.floating === true;
        if (obj.inViewport || isFloating) {
          if (isFloating) {
            renderer2.save();
            renderer2.resetTransform();
          }
          obj.preDraw(renderer2);
          obj.draw(renderer2, viewport);
          obj.postDraw(renderer2);
          if (isFloating) {
            renderer2.restore();
          }
          this.drawCount++;
        }
      }
    }
  }
};
var TMXRenderer = class {
  /**
   * @param {number} cols - width of the tilemap in tiles
   * @param {number} rows - height of the tilemap in tiles
   * @param {number} tilewidth - width of each tile in pixels
   * @param {number} tileheight - height of each tile in pixels
   */
  constructor(cols, rows, tilewidth, tileheight) {
    this.cols = cols;
    this.rows = rows;
    this.tilewidth = tilewidth;
    this.tileheight = tileheight;
    this.bounds = new Bounds();
  }
  /**
   * return true if the renderer can render the specified map or layer
   * @param {TMXTileMap|TMXLayer} component - TMX Map or Layer
   * @returns {boolean}
   */
  canRender(component) {
    return (
      /*
      // layers can have different size within
      // the same maps, so commenting these two lines
      (this.cols === component.cols) &&
      (this.rows === component.rows) &&
      */
      this.tilewidth === component.tilewidth && this.tileheight === component.tileheight
    );
  }
  /**
   * return the bounding rect for this map renderer
   * @param {TMXLayer} [layer] - calculate the bounding rect for a specific layer (will return a new bounds object)
   * @returns {Bounds}
   */
  getBounds(layer) {
    let bounds = layer instanceof TMXLayer ? pool.pull("Bounds") : this.bounds;
    bounds.setMinMax(
      0,
      0,
      this.cols * this.tilewidth,
      this.rows * this.tileheight
    );
    return bounds;
  }
  /**
   * return the tile position corresponding to the specified pixel
   * @param {number} x - X coordinate
   * @param {number} y - Y coordinate
   * @param {Vector2d} [v] - an optional vector object where to put the return values
   * @returns {Vector2d}
   */
  pixelToTileCoords(x, y, v) {
    return v;
  }
  /**
   * return the pixel position corresponding of the specified tile
   * @param {number} col - tile horizontal position
   * @param {number} row - tile vertical position
   * @param {Vector2d} [v] - an optional vector object where to put the return values
   * @returns {Vector2d}
   */
  tileToPixelCoords(col, row, v) {
    return v;
  }
  /**
   * draw the given tile at the specified layer
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer object
   * @param {number} x - X coordinate where to draw the tile
   * @param {number} y - Y coordinate where to draw the tile
   * @param {Tile} tile - the tile object to draw
   */
  drawTile(renderer2, x, y, tile) {
  }
  /**
   * draw the given TMX Layer for the given area
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer object
   * @param {TMXLayer} layer - a TMX Layer object
   * @param {Rect} rect - the area of the layer to draw
   */
  drawTileLayer(renderer2, layer, rect) {
  }
};
var TMXOrthogonalRenderer = class extends TMXRenderer {
  /**
   * @param {TMXTileMap} map - the TMX map
   */
  constructor(map) {
    super(
      map.cols,
      map.rows,
      map.tilewidth,
      map.tileheight
    );
  }
  /**
   * return true if the renderer can render the specified layer
   * @ignore
   */
  canRender(layer) {
    return layer.orientation === "orthogonal" && super.canRender(layer);
  }
  /**
   * return the tile position corresponding to the specified pixel
   * @ignore
   */
  pixelToTileCoords(x, y, v) {
    let ret = v || new Vector2d();
    return ret.set(
      x / this.tilewidth,
      y / this.tileheight
    );
  }
  /**
   * return the pixel position corresponding of the specified tile
   * @ignore
   */
  tileToPixelCoords(x, y, v) {
    let ret = v || new Vector2d();
    return ret.set(
      x * this.tilewidth,
      y * this.tileheight
    );
  }
  /**
   * fix the position of Objects to match
   * the way Tiled places them
   * @ignore
   */
  adjustPosition(obj) {
    if (typeof obj.gid === "number") {
      obj.y -= obj.height;
    }
  }
  /**
   * draw the tile map
   * @ignore
   */
  drawTile(renderer2, x, y, tmxTile) {
    let tileset = tmxTile.tileset;
    tileset.drawTile(
      renderer2,
      tileset.tileoffset.x + x * this.tilewidth,
      tileset.tileoffset.y + (y + 1) * this.tileheight - tileset.tileheight,
      tmxTile
    );
  }
  /**
   * draw the tile map
   * @ignore
   */
  drawTileLayer(renderer2, layer, rect) {
    let incX = 1, incY = 1;
    let start = this.pixelToTileCoords(
      Math.max(rect.pos.x - (layer.maxTileSize.width - layer.tilewidth), 0),
      Math.max(rect.pos.y - (layer.maxTileSize.height - layer.tileheight), 0),
      pool.pull("Vector2d")
    ).floorSelf();
    let end = this.pixelToTileCoords(
      rect.pos.x + rect.width + this.tilewidth,
      rect.pos.y + rect.height + this.tileheight,
      pool.pull("Vector2d")
    ).ceilSelf();
    end.x = end.x > this.cols ? this.cols : end.x;
    end.y = end.y > this.rows ? this.rows : end.y;
    switch (layer.renderorder) {
      case "right-up":
        end.y = start.y + (start.y = end.y) - end.y;
        incY = -1;
        break;
      case "left-down":
        end.x = start.x + (start.x = end.x) - end.x;
        incX = -1;
        break;
      case "left-up":
        end.x = start.x + (start.x = end.x) - end.x;
        end.y = start.y + (start.y = end.y) - end.y;
        incX = -1;
        incY = -1;
        break;
      default:
        break;
    }
    for (let y = start.y; y !== end.y; y += incY) {
      for (let x = start.x; x !== end.x; x += incX) {
        let tmxTile = layer.cellAt(x, y, false);
        if (tmxTile) {
          this.drawTile(renderer2, x, y, tmxTile);
        }
      }
    }
    pool.push(start);
    pool.push(end);
  }
};
var TMXIsometricRenderer = class extends TMXRenderer {
  /**
   * @param {TMXTileMap} map - the TMX map
   */
  constructor(map) {
    super(
      map.cols,
      map.rows,
      map.tilewidth,
      map.tileheight
    );
    this.hTilewidth = this.tilewidth / 2;
    this.hTileheight = this.tileheight / 2;
    this.originX = this.rows * this.hTilewidth;
  }
  /**
   * return true if the renderer can render the specified layer
   * @ignore
   */
  canRender(layer) {
    return layer.orientation === "isometric" && super.canRender(layer);
  }
  /**
   * return the bounding rect for this map renderer
   * @ignore
   */
  getBounds(layer) {
    let bounds = layer instanceof TMXLayer ? pool.pull("Bounds") : this.bounds;
    bounds.setMinMax(
      0,
      0,
      (this.cols + this.rows) * (this.tilewidth / 2),
      (this.cols + this.rows) * (this.tileheight / 2)
    );
    return bounds;
  }
  /**
   * return the tile position corresponding to the specified pixel
   * @ignore
   */
  pixelToTileCoords(x, y, v) {
    let ret = v || new Vector2d();
    return ret.set(
      y / this.tileheight + (x - this.originX) / this.tilewidth,
      y / this.tileheight - (x - this.originX) / this.tilewidth
    );
  }
  /**
   * return the pixel position corresponding of the specified tile
   * @ignore
   */
  tileToPixelCoords(x, y, v) {
    let ret = v || new Vector2d();
    return ret.set(
      (x - y) * this.hTilewidth + this.originX,
      (x + y) * this.hTileheight
    );
  }
  /**
   * fix the position of Objects to match
   * the way Tiled places them
   * @ignore
   */
  adjustPosition(obj) {
    let tileX = obj.x / this.hTilewidth;
    let tileY = obj.y / this.tileheight;
    let isoPos = pool.pull("Vector2d");
    this.tileToPixelCoords(tileX, tileY, isoPos);
    obj.x = isoPos.x;
    obj.y = isoPos.y;
    pool.push(isoPos);
  }
  /**
   * draw the tile map
   * @ignore
   */
  drawTile(renderer2, x, y, tmxTile) {
    let tileset = tmxTile.tileset;
    tileset.drawTile(
      renderer2,
      (this.cols - 1) * tileset.tilewidth + (x - y) * tileset.tilewidth >> 1,
      -tileset.tilewidth + (x + y) * tileset.tileheight >> 2,
      tmxTile
    );
  }
  /**
   * draw the tile map
   * @ignore
   */
  drawTileLayer(renderer2, layer, rect) {
    let tileset = layer.tileset;
    let rowItr = this.pixelToTileCoords(
      rect.pos.x - tileset.tilewidth,
      rect.pos.y - tileset.tileheight,
      pool.pull("Vector2d")
    ).floorSelf();
    let tileEnd = this.pixelToTileCoords(
      rect.pos.x + rect.width + tileset.tilewidth,
      rect.pos.y + rect.height + tileset.tileheight,
      pool.pull("Vector2d")
    ).ceilSelf();
    let rectEnd = this.tileToPixelCoords(tileEnd.x, tileEnd.y, pool.pull("Vector2d"));
    let startPos = this.tileToPixelCoords(rowItr.x, rowItr.y, pool.pull("Vector2d"));
    startPos.x -= this.hTilewidth;
    startPos.y += this.tileheight;
    let inUpperHalf = startPos.y - rect.pos.y > this.hTileheight;
    let inLeftHalf = rect.pos.x - startPos.x < this.hTilewidth;
    if (inUpperHalf) {
      if (inLeftHalf) {
        rowItr.x--;
        startPos.x -= this.hTilewidth;
      } else {
        rowItr.y--;
        startPos.x += this.hTilewidth;
      }
      startPos.y -= this.hTileheight;
    }
    let shifted = inUpperHalf ^ inLeftHalf;
    let columnItr = rowItr.clone();
    for (let y = startPos.y * 2; y - this.tileheight * 2 < rectEnd.y * 2; y += this.tileheight) {
      columnItr.setV(rowItr);
      for (let x = startPos.x; x < rectEnd.x; x += this.tilewidth) {
        let tmxTile = layer.cellAt(columnItr.x, columnItr.y);
        if (tmxTile) {
          tileset = tmxTile.tileset;
          let offset = tileset.tileoffset;
          tileset.drawTile(
            renderer2,
            offset.x + x,
            offset.y + y / 2 - tileset.tileheight,
            tmxTile
          );
        }
        columnItr.x++;
        columnItr.y--;
      }
      if (!shifted) {
        rowItr.x++;
        startPos.x += this.hTilewidth;
        shifted = true;
      } else {
        rowItr.y++;
        startPos.x -= this.hTilewidth;
        shifted = false;
      }
    }
    pool.push(columnItr);
    pool.push(rowItr);
    pool.push(tileEnd);
    pool.push(rectEnd);
    pool.push(startPos);
  }
};
var offsetsStaggerX = [
  { x: 0, y: 0 },
  { x: 1, y: -1 },
  { x: 1, y: 0 },
  { x: 2, y: 0 }
];
var offsetsStaggerY = [
  { x: 0, y: 0 },
  { x: -1, y: 1 },
  { x: 0, y: 1 },
  { x: 0, y: 2 }
];
var TMXHexagonalRenderer = class extends TMXRenderer {
  /**
   * @param {TMXTileMap} map - the TMX map
   */
  constructor(map) {
    super(
      map.cols,
      map.rows,
      map.tilewidth & ~1,
      map.tileheight & ~1
    );
    this.hexsidelength = map.hexsidelength || 0;
    this.staggerX = map.staggeraxis === "x";
    this.staggerEven = map.staggerindex === "even";
    this.sidelengthx = 0;
    this.sidelengthy = 0;
    if (map.orientation === "hexagonal") {
      if (this.staggerX) {
        this.sidelengthx = this.hexsidelength;
      } else {
        this.sidelengthy = this.hexsidelength;
      }
    }
    this.sideoffsetx = (this.tilewidth - this.sidelengthx) / 2;
    this.sideoffsety = (this.tileheight - this.sidelengthy) / 2;
    this.columnwidth = this.sideoffsetx + this.sidelengthx;
    this.rowheight = this.sideoffsety + this.sidelengthy;
    this.centers = [
      new Vector2d(),
      new Vector2d(),
      new Vector2d(),
      new Vector2d()
    ];
  }
  /**
   * return true if the renderer can render the specified layer
   * @ignore
   */
  canRender(layer) {
    return layer.orientation === "hexagonal" && super.canRender(layer);
  }
  /**
   * return the bounding rect for this map renderer
   * @ignore
   */
  getBounds(layer) {
    let bounds = layer instanceof TMXLayer ? pool.pull("Bounds") : this.bounds;
    if (this.staggerX) {
      bounds.setMinMax(
        0,
        0,
        this.cols * this.columnwidth + this.sideoffsetx,
        this.rows * (this.tileheight + this.sidelengthy)
      );
      if (bounds.width > 1) {
        bounds.height += this.rowheight;
      }
    } else {
      bounds.setMinMax(
        0,
        0,
        this.cols * (this.tilewidth + this.sidelengthx),
        this.rows * this.rowheight + this.sideoffsety
      );
      if (bounds.height > 1) {
        bounds.width += this.columnwidth;
      }
    }
    return bounds;
  }
  /**
   * @ignore
   */
  doStaggerX(x) {
    return this.staggerX && x & 1 ^ this.staggerEven;
  }
  /**
   * @ignore
   */
  doStaggerY(y) {
    return !this.staggerX && y & 1 ^ this.staggerEven;
  }
  /**
   * @ignore
   */
  topLeft(x, y, v) {
    let ret = v || new Vector2d();
    if (!this.staggerX) {
      if (y & 1 ^ this.staggerEven) {
        ret.set(x, y - 1);
      } else {
        ret.set(x - 1, y - 1);
      }
    } else {
      if (x & 1 ^ this.staggerEven) {
        ret.set(x - 1, y);
      } else {
        ret.set(x - 1, y - 1);
      }
    }
    return ret;
  }
  /**
   * @ignore
   */
  topRight(x, y, v) {
    let ret = v || new Vector2d();
    if (!this.staggerX) {
      if (y & 1 ^ this.staggerEven) {
        ret.set(x + 1, y - 1);
      } else {
        ret.set(x, y - 1);
      }
    } else {
      if (x & 1 ^ this.staggerEven) {
        ret.set(x + 1, y);
      } else {
        ret.set(x + 1, y - 1);
      }
    }
    return ret;
  }
  /**
   * @ignore
   */
  bottomLeft(x, y, v) {
    let ret = v || new Vector2d();
    if (!this.staggerX) {
      if (y & 1 ^ this.staggerEven) {
        ret.set(x, y + 1);
      } else {
        ret.set(x - 1, y + 1);
      }
    } else {
      if (x & 1 ^ this.staggerEven) {
        ret.set(x - 1, y + 1);
      } else {
        ret.set(x - 1, y);
      }
    }
    return ret;
  }
  /**
   * @ignore
   */
  bottomRight(x, y, v) {
    let ret = v || new Vector2d();
    if (!this.staggerX) {
      if (y & 1 ^ this.staggerEven) {
        ret.set(x + 1, y + 1);
      } else {
        ret.set(x, y + 1);
      }
    } else {
      if (x & 1 ^ this.staggerEven) {
        ret.set(x + 1, y + 1);
      } else {
        ret.set(x + 1, y);
      }
    }
    return ret;
  }
  /**
   * return the tile position corresponding to the specified pixel
   * @ignore
   */
  pixelToTileCoords(x, y, v) {
    let ret = v || new Vector2d();
    if (this.staggerX) {
      x -= this.staggerEven ? this.tilewidth : this.sideoffsetx;
    } else {
      y -= this.staggerEven ? this.tileheight : this.sideoffsety;
    }
    let referencePoint = pool.pull(
      "Vector2d",
      Math.floor(x / (this.columnwidth * 2)),
      Math.floor(y / (this.rowheight * 2))
    );
    let rel = pool.pull(
      "Vector2d",
      x - referencePoint.x * (this.columnwidth * 2),
      y - referencePoint.y * (this.rowheight * 2)
    );
    if (this.staggerX) {
      referencePoint.x = referencePoint.x * 2;
      if (this.staggerEven) {
        ++referencePoint.x;
      }
    } else {
      referencePoint.y = referencePoint.y * 2;
      if (this.staggerEven) {
        ++referencePoint.y;
      }
    }
    let left, top, centerX, centerY;
    if (this.staggerX) {
      left = this.sidelengthx / 2;
      centerX = left + this.columnwidth;
      centerY = this.tileheight / 2;
      this.centers[0].set(left, centerY);
      this.centers[1].set(centerX, centerY - this.rowheight);
      this.centers[2].set(centerX, centerY + this.rowheight);
      this.centers[3].set(centerX + this.columnwidth, centerY);
    } else {
      top = this.sidelengthy / 2;
      centerX = this.tilewidth / 2;
      centerY = top + this.rowheight;
      this.centers[0].set(centerX, top);
      this.centers[1].set(centerX - this.columnwidth, centerY);
      this.centers[2].set(centerX + this.columnwidth, centerY);
      this.centers[3].set(centerX, centerY + this.rowheight);
    }
    let nearest = 0;
    let minDist = Number.MAX_VALUE;
    for (let i = 0; i < 4; ++i) {
      const dc = this.centers[i].sub(rel).length2();
      if (dc < minDist) {
        minDist = dc;
        nearest = i;
      }
    }
    let offsets = this.staggerX ? offsetsStaggerX : offsetsStaggerY;
    ret.set(
      referencePoint.x + offsets[nearest].x,
      referencePoint.y + offsets[nearest].y
    );
    pool.push(referencePoint);
    pool.push(rel);
    return ret;
  }
  /**
   * return the pixel position corresponding of the specified tile
   * @ignore
   */
  tileToPixelCoords(x, y, v) {
    let tileX = Math.floor(x), tileY = Math.floor(y);
    let ret = v || new Vector2d();
    if (this.staggerX) {
      ret.y = tileY * (this.tileheight + this.sidelengthy);
      if (this.doStaggerX(tileX)) {
        ret.y += this.rowheight;
      }
      ret.x = tileX * this.columnwidth;
    } else {
      ret.x = tileX * (this.tilewidth + this.sidelengthx);
      if (this.doStaggerY(tileY)) {
        ret.x += this.columnwidth;
      }
      ret.y = tileY * this.rowheight;
    }
    return ret;
  }
  /**
   * fix the position of Objects to match
   * the way Tiled places them
   * @ignore
   */
  adjustPosition(obj) {
    if (typeof obj.gid === "number") {
      obj.y -= obj.height;
    }
  }
  /**
   * draw the tile map
   * @ignore
   */
  drawTile(renderer2, x, y, tmxTile) {
    let tileset = tmxTile.tileset;
    let point = this.tileToPixelCoords(x, y, pool.pull("Vector2d"));
    tileset.drawTile(
      renderer2,
      tileset.tileoffset.x + point.x,
      tileset.tileoffset.y + point.y + (this.tileheight - tileset.tileheight),
      tmxTile
    );
    pool.push(point);
  }
  /**
   * draw the tile map
   * @ignore
   */
  drawTileLayer(renderer2, layer, rect) {
    let tile;
    let startTile = this.pixelToTileCoords(
      rect.pos.x,
      rect.pos.y,
      pool.pull("Vector2d")
    );
    startTile.sub(layer.pos);
    let startPos = this.tileToPixelCoords(
      startTile.x + layer.pos.x,
      startTile.y + layer.pos.y,
      pool.pull("Vector2d")
    );
    let rowTile = startTile.clone();
    let rowPos = startPos.clone();
    let inUpperHalf = rect.pos.y - startPos.y < this.sideoffsety;
    let inLeftHalf = rect.pos.x - startPos.x < this.sideoffsetx;
    if (inUpperHalf) {
      startTile.y--;
    }
    if (inLeftHalf) {
      startTile.x--;
    }
    let endX = layer.cols;
    let endY = layer.rows;
    if (this.staggerX) {
      startTile.x = Math.max(0, startTile.x);
      startTile.y = Math.max(0, startTile.y);
      startPos = this.tileToPixelCoords(
        startTile.x + layer.pos.x,
        startTile.y + layer.pos.y,
        startPos
      );
      let staggeredRow = this.doStaggerX(startTile.x + layer.pos.x);
      for (; startPos.y < rect.bottom && startTile.y < endY; ) {
        rowTile.setV(startTile);
        rowPos.setV(startPos);
        for (; rowPos.x < rect.right && rowTile.x < endX; rowTile.x += 2) {
          tile = layer.cellAt(rowTile.x, rowTile.y, false);
          if (tile) {
            tile.tileset.drawTile(renderer2, rowPos.x, rowPos.y, tile);
          }
          rowPos.x += this.tilewidth + this.sidelengthx;
        }
        if (staggeredRow) {
          startTile.x -= 1;
          startTile.y += 1;
          startPos.x -= this.columnwidth;
          staggeredRow = false;
        } else {
          startTile.x += 1;
          startPos.x += this.columnwidth;
          staggeredRow = true;
        }
        startPos.y += this.rowheight;
      }
      pool.push(rowTile);
      pool.push(rowPos);
    } else {
      startTile.x = Math.max(0, startTile.x);
      startTile.y = Math.max(0, startTile.y);
      startPos = this.tileToPixelCoords(
        startTile.x + layer.pos.x,
        startTile.y + layer.pos.y,
        startPos
      );
      if (this.doStaggerY(startTile.y)) {
        startPos.x -= this.columnwidth;
      }
      for (; startPos.y < rect.bottom && startTile.y < endY; startTile.y++) {
        rowTile.setV(startTile);
        rowPos.setV(startPos);
        if (this.doStaggerY(startTile.y)) {
          rowPos.x += this.columnwidth;
        }
        for (; rowPos.x < rect.right && rowTile.x < endX; rowTile.x++) {
          tile = layer.cellAt(rowTile.x, rowTile.y, false);
          if (tile) {
            tile.tileset.drawTile(renderer2, rowPos.x, rowPos.y, tile);
          }
          rowPos.x += this.tilewidth + this.sidelengthx;
        }
        startPos.y += this.rowheight;
      }
      pool.push(rowTile);
      pool.push(rowPos);
    }
    pool.push(startTile);
    pool.push(startPos);
  }
};
var TMXStaggeredRenderer = class extends TMXHexagonalRenderer {
  /**
   * return true if the renderer can render the specified layer
   * @ignore
   */
  canRender(layer) {
    return layer.orientation === "staggered" && super.canRender(layer);
  }
  /**
   * return the tile position corresponding to the specified pixel
   * @ignore
   */
  pixelToTileCoords(x, y, v) {
    let ret = v || new Vector2d();
    let alignedX = x, alignedY = y;
    if (this.staggerX) {
      alignedX -= this.staggerEven ? this.sideoffsetx : 0;
    } else {
      alignedY -= this.staggerEven ? this.sideoffsety : 0;
    }
    let referencePoint = pool.pull(
      "Vector2d",
      Math.floor(alignedX / this.tilewidth),
      Math.floor(alignedY / this.tileheight)
    );
    if (this.staggerX) {
      referencePoint.x = referencePoint.x * 2;
      if (this.staggerEven) {
        ++referencePoint.x;
      }
    } else {
      referencePoint.y = referencePoint.y * 2;
      if (this.staggerEven) {
        ++referencePoint.y;
      }
    }
    let rel = pool.pull(
      "Vector2d",
      alignedX - referencePoint.x * this.tilewidth,
      alignedY - referencePoint.y * this.tileheight
    );
    let y_pos = rel.x * (this.tileheight / this.tilewidth);
    if (this.sideoffsety - y_pos > rel.y) {
      referencePoint = this.topLeft(referencePoint.x, referencePoint.y, referencePoint);
    }
    if (-this.sideoffsety + y_pos > rel.y) {
      referencePoint = this.topRight(referencePoint.x, referencePoint.y, referencePoint);
    }
    if (this.sideoffsety + y_pos < rel.y) {
      referencePoint = this.bottomLeft(referencePoint.x, referencePoint.y, referencePoint);
    }
    if (this.sideoffsety * 3 - y_pos < rel.y) {
      referencePoint = this.bottomRight(referencePoint.x, referencePoint.y, referencePoint);
    }
    ret = this.tileToPixelCoords(referencePoint.x, referencePoint.y, ret);
    ret.set(x - ret.x, y - ret.y);
    ret.set(
      ret.x - this.tilewidth / 2,
      ret.y * (this.tilewidth / this.tileheight)
    );
    ret.div(this.tilewidth / Math.sqrt(2)).rotate(degToRad(-45)).add(referencePoint);
    pool.push(referencePoint);
    pool.push(rel);
    return ret;
  }
};
function getNewTMXRenderer(map) {
  switch (map.orientation) {
    case "orthogonal":
      return new TMXOrthogonalRenderer(map);
    case "isometric":
      return new TMXIsometricRenderer(map);
    case "hexagonal":
      return new TMXHexagonalRenderer(map);
    case "staggered":
      return new TMXStaggeredRenderer(map);
    default:
      throw new Error(map.orientation + " type TMX Tile Map not supported!");
  }
}
function warning(deprecated, replacement2, version2) {
  const msg = "melonJS: %s is deprecated since version %s, please use %s";
  let stack = new Error().stack;
  if (console.groupCollapsed) {
    console.groupCollapsed(
      "%c" + msg,
      "font-weight:normal;color:yellow;",
      deprecated,
      version2,
      replacement2
    );
  } else {
    console.warn(
      msg,
      deprecated,
      version2,
      replacement2
    );
  }
  if (typeof stack !== "undefined") {
    console.warn(stack);
  }
  if (console.groupCollapsed) {
    console.groupEnd();
  }
}
function readLayer(map, data2, z) {
  return new TMXLayer(map, data2, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z);
}
function readImageLayer(map, data2, z) {
  applyTMXProperties(data2.properties, data2);
  let imageLayer = pool.pull(
    "ImageLayer",
    // x/y is deprecated since 0.15 and replace by offsetx/y
    +data2.offsetx || +data2.x || 0,
    +data2.offsety || +data2.y || 0,
    Object.assign({
      name: data2.name,
      image: data2.image,
      ratio: pool.pull("Vector2d", +data2.parallaxx || 1, +data2.parallaxy || 1),
      // convert to melonJS color format (note: this should be done earlier when parsing data)
      tint: typeof data2.tintcolor !== "undefined" ? pool.pull("Color").parseHex(data2.tintcolor, true) : void 0,
      z
    }, data2.properties)
  );
  let visible = typeof data2.visible !== "undefined" ? data2.visible : true;
  imageLayer.setOpacity(visible ? +data2.opacity : 0);
  return imageLayer;
}
function readTileset(data2) {
  return new TMXTileset(data2);
}
function readObjectGroup(map, data2, z) {
  return new TMXGroup(map, data2, z);
}
var TMXTileMap = class {
  /**
   * @param {string} levelId - name of TMX map
   * @param {object} data - TMX map in JSON format
   * @example
   * // create a new level object based on the TMX JSON object
   * let level = new me.TMXTileMap(levelId, me.loader.getTMX(levelId));
   * // add the level to the game world container
   * level.addTo(me.game.world, true);
   */
  constructor(levelId, data2) {
    this.data = data2;
    this.name = levelId;
    this.cols = +data2.width;
    this.rows = +data2.height;
    this.tilewidth = +data2.tilewidth;
    this.tileheight = +data2.tileheight;
    this.infinite = +data2.infinite || 0;
    this.orientation = data2.orientation;
    this.renderorder = data2.renderorder || "right-down";
    this.version = "" + data2.version;
    this.tiledversion = "" + data2.tiledversion;
    this.class = data2.class;
    this.tilesets = null;
    if (typeof this.layers === "undefined") {
      this.layers = [];
    }
    if (typeof this.objectGroups === "undefined") {
      this.objectGroups = [];
    }
    this.isEditor = data2.editor === "melon-editor";
    this.nextobjectid = +data2.nextobjectid || void 0;
    this.hexsidelength = +data2.hexsidelength;
    this.staggeraxis = data2.staggeraxis;
    this.staggerindex = data2.staggerindex;
    this.bounds = this.getRenderer().getBounds().clone();
    this.width = this.bounds.width;
    this.height = this.bounds.height;
    this.backgroundcolor = data2.backgroundcolor;
    if (this.version !== "undefined" && this.version !== "") {
      if (checkVersion(this.version, "1.5") < 0) {
        warning("(" + this.name + ") Tiled Map format version 1.4 and below", "format 1.5 or higher", "10.4.4");
      }
    }
    applyTMXProperties(this, data2);
    this.initialized = false;
  }
  /**
   * Return the map default renderer
   * @returns {TMXRenderer} a TMX renderer
   */
  getRenderer() {
    if (typeof this.renderer === "undefined" || !this.renderer.canRender(this)) {
      this.renderer = getNewTMXRenderer(this);
    }
    return this.renderer;
  }
  /**
   * return the map bounding rect
   * @returns {Bounds}
   */
  getBounds() {
    return this.bounds;
  }
  /**
   * parse the map
   * @ignore
   */
  readMapObjects(data2) {
    if (this.initialized === true) {
      return;
    }
    let zOrder2 = 0;
    if (!this.tilesets) {
      this.tilesets = new TMXTilesetGroup();
    }
    if (typeof data2.tilesets !== "undefined") {
      let tilesets = data2.tilesets;
      tilesets.forEach((tileset) => {
        this.tilesets.add(readTileset(tileset));
      });
    }
    if (this.background_image) {
      this.layers.push(
        pool.pull(
          "ImageLayer",
          0,
          0,
          {
            name: "background_image",
            image: this.background_image,
            z: zOrder2++
          }
        )
      );
    }
    data2.layers.forEach((layer) => {
      switch (layer.type) {
        case "imagelayer":
          this.layers.push(readImageLayer(this, layer, zOrder2++));
          break;
        case "tilelayer":
          this.layers.push(readLayer(this, layer, zOrder2++));
          break;
        case "objectgroup":
          this.objectGroups.push(readObjectGroup(this, layer, zOrder2++));
          break;
        case "group":
          this.objectGroups.push(readObjectGroup(this, layer, zOrder2++));
          break;
        default:
          break;
      }
    });
    this.initialized = true;
  }
  /**
   * add all the map layers and objects to the given container.
   * note : this will not automatically update the camera viewport
   * @param {Container} container - target container
   * @param {boolean} [flatten=true] - if true, flatten all objects into the given container, else a `me.Container` object will be created for each corresponding groups
   * @param {boolean} [setViewportBounds=false] - if true, set the viewport bounds to the map size, this should be set to true especially if adding a level to the game world container.
   * @example
   * // create a new level object based on the TMX JSON object
   * let level = new me.TMXTileMap(levelId, me.loader.getTMX(levelId));
   * // add the level to the game world container
   * level.addTo(me.game.world, true, true);
   */
  addTo(container, flatten, setViewportBounds) {
    let _sort = container.autoSort;
    let _depth = container.autoDepth;
    let levelBounds = this.getBounds();
    container.autoSort = false;
    container.autoDepth = false;
    if (this.backgroundcolor) {
      container.backgroundColor.parseCSS(this.backgroundcolor);
    }
    this.getLayers().forEach((layer) => {
      container.addChild(layer);
    });
    this.getObjects(flatten).forEach((object) => {
      container.addChild(object);
    });
    container.resize(this.bounds.width, this.bounds.height);
    container.sort(true);
    function _setBounds(width, height) {
      game.viewport.setBounds(
        0,
        0,
        Math.max(levelBounds.width, width),
        Math.max(levelBounds.height, height)
      );
      container.pos.set(
        Math.max(0, ~~((width - levelBounds.width) / 2)),
        Math.max(0, ~~((height - levelBounds.height) / 2)),
        // don't change the container z position if defined
        container.pos.z
      );
    }
    if (setViewportBounds === true) {
      off(VIEWPORT_ONRESIZE, _setBounds);
      _setBounds(game.viewport.width, game.viewport.height);
      on(VIEWPORT_ONRESIZE, _setBounds, this);
    }
    container.autoSort = _sort;
    container.autoDepth = _depth;
  }
  /**
   * return an Array of instantiated objects, based on the map object definition
   * @param {boolean} [flatten=true] - if true, flatten all objects into the returned array.
   * when false, a `me.Container` object will be created for each corresponding groups
   * @returns {Renderable[]} Array of Objects
   */
  getObjects(flatten) {
    let objects = [];
    let isCollisionGroup = false;
    let targetContainer;
    this.readMapObjects(this.data);
    for (let g2 = 0; g2 < this.objectGroups.length; g2++) {
      let group = this.objectGroups[g2];
      isCollisionGroup = group.name.toLowerCase().includes(COLLISION_GROUP);
      if (flatten === false) {
        targetContainer = new Container(0, 0, this.width, this.height);
        targetContainer.anchorPoint.set(0, 0);
        targetContainer.name = group.name;
        targetContainer.pos.z = group.z;
        targetContainer.setOpacity(group.opacity);
        targetContainer.autoSort = false;
        targetContainer.autoDepth = false;
      }
      for (let o = 0; o < group.objects.length; o++) {
        let settings = group.objects[o];
        let obj;
        let shape;
        if (typeof settings.anchorPoint === "undefined") {
          settings.anchorPoint = { x: 0, y: 0 };
        }
        if (typeof settings.tintcolor !== "undefined") {
          settings.tint = pool.pull("Color");
          settings.tint.parseHex(settings.tintcolor, true);
        }
        if (settings instanceof TMXLayer) {
          obj = settings;
        } else if (typeof settings.text === "object") {
          if (typeof settings.text.anchorPoint === "undefined") {
            settings.text.anchorPoint = settings.anchorPoint;
          }
          if (settings.text.bitmap === true) {
            obj = pool.pull("BitmapText", settings.x, settings.y, settings.text);
          } else {
            obj = pool.pull("Text", settings.x, settings.y, settings.text);
          }
          obj.pos.z = settings.z;
        } else if (typeof settings.tile === "object") {
          shape = settings.shapes;
          if (typeof shape === "undefined") {
            shape = pool.pull("Polygon", 0, 0, [
              pool.pull("Vector2d", 0, 0),
              pool.pull("Vector2d", this.width, 0),
              pool.pull("Vector2d", this.width, this.height)
            ]);
          }
          obj = settings.tile.getRenderable(settings);
          obj.body = new Body(obj, shape);
          obj.body.setStatic(true);
          obj.pos.setMuted(settings.x, settings.y, settings.z);
        } else {
          if (typeof settings.name !== "undefined" && settings.name !== "") {
            obj = pool.pull(
              settings.name,
              settings.x,
              settings.y,
              settings
            );
          } else {
            obj = pool.pull(
              "Renderable",
              settings.x,
              settings.y,
              settings.width,
              settings.height
            );
            shape = settings.shapes;
            if (typeof shape === "undefined") {
              shape = pool.pull("Polygon", 0, 0, [
                pool.pull("Vector2d", 0, 0),
                pool.pull("Vector2d", this.width, 0),
                pool.pull("Vector2d", this.width, this.height)
              ]);
            }
            obj.anchorPoint.set(0, 0);
            obj.name = settings.name;
            obj.type = settings.type;
            obj.class = settings.class || settings.type;
            obj.id = settings.id;
            obj.body = new Body(obj, shape);
            obj.body.setStatic(true);
            obj.resize(obj.body.getBounds().width, obj.body.getBounds().height);
          }
          obj.pos.z = settings.z;
        }
        if (isCollisionGroup && !settings.name && obj.body) {
          obj.body.collisionType = collision.types.WORLD_SHAPE;
          obj.body.isStatic = true;
        }
        if (flatten !== false) {
          if (obj.isRenderable === true) {
            obj.setOpacity(obj.getOpacity() * group.opacity);
            if (typeof obj.renderable !== "undefined" && obj.renderable.isRenderable === true) {
              obj.renderable.setOpacity(obj.renderable.getOpacity() * group.opacity);
            }
          }
          objects.push(obj);
        } else {
          targetContainer.addChild(obj);
        }
      }
      if (flatten === false && targetContainer.children.length > 0) {
        targetContainer.autoSort = true;
        targetContainer.autoDepth = true;
        objects.push(targetContainer);
      }
    }
    return objects;
  }
  /**
   * return all the existing layers
   * @returns {TMXLayer[]} Array of Layers
   */
  getLayers() {
    this.readMapObjects(this.data);
    return this.layers;
  }
  /**
   * destroy function, clean all allocated objects
   */
  destroy() {
    this.tilesets = void 0;
    this.layers.length = 0;
    this.objectGroups.length = 0;
    this.initialized = false;
  }
};
var levels = {};
var levelIdx = [];
var currentLevelIdx = 0;
function safeLoadLevel(levelId, options, restart) {
  options.container.reset();
  game.reset();
  if (levels[level.getCurrentLevelId()]) {
    levels[level.getCurrentLevelId()].destroy();
  }
  currentLevelIdx = levelIdx.indexOf(levelId);
  loadTMXLevel(levelId, options.container, options.flatten, options.setViewportBounds);
  emit(LEVEL_LOADED, levelId);
  options.onLoaded(levelId);
  if (restart) {
    state.restart();
  }
}
function loadTMXLevel(levelId, container, flatten, setViewportBounds) {
  let level2 = levels[levelId];
  resetGUID(levelId, level2.nextobjectid);
  container.anchorPoint.set(0, 0);
  level2.addTo(container, flatten, setViewportBounds);
}
var level = {
  /**
   * add a level into the game manager (usually called by the preloader)
   * @name add
   * @memberof level
   * @public
   * @param {string} format - level format (only "tmx" supported)
   * @param {string} levelId - the level id (or name)
   * @param {Function} [callback] - a function to be called once the level is loaded
   * @returns {boolean} true if the level was loaded
   */
  add(format, levelId, callback) {
    switch (format) {
      case "tmx":
        if (levels[levelId] == null) {
          levels[levelId] = new TMXTileMap(levelId, getTMX(levelId));
          levelIdx.push(levelId);
        } else {
          return false;
        }
        if (callback) {
          callback();
        }
        return true;
      default:
        throw new Error("no level loader defined for format " + format);
    }
  },
  /**
   * load a level into the game manager<br>
   * (will also create all level defined entities, etc..)
   * @name load
   * @memberof level
   * @public
   * @param {string} levelId - level id
   * @param {object} [options] - additional optional parameters
   * @param {Container} [options.container=game.world] - container in which to load the specified level
   * @param {Function} [options.onLoaded=game.onLevelLoaded] - callback for when the level is fully loaded
   * @param {boolean} [options.flatten=game.mergeGroup] - if true, flatten all objects into the given container
   * @param {boolean} [options.setViewportBounds=true] - if true, set the viewport bounds to the map size
   * @returns {boolean} true if the level was successfully loaded
   * @example
   * // the game assets to be be preloaded
   * // TMX maps
   * let resources = [
   *     {name: "a4_level1",   type: "tmx",   src: "data/level/a4_level1.tmx"},
   *     {name: "a4_level2",   type: "tmx",   src: "data/level/a4_level2.tmx"},
   *     {name: "a4_level3",   type: "tmx",   src: "data/level/a4_level3.tmx"},
   *     // ...
   * ];
   *
   * // ...
   *
   * // load a level into the game world
   * me.level.load("a4_level1");
   * ...
   * ...
   * // load a level into a specific container
   * let levelContainer = new me.Container();
   * me.level.load("a4_level2", {container:levelContainer});
   * // add a simple transformation
   * levelContainer.currentTransform.translate(levelContainer.width / 2, levelContainer.height / 2 );
   * levelContainer.currentTransform.rotate(0.05);
   * levelContainer.currentTransform.translate(-levelContainer.width / 2, -levelContainer.height / 2 );
   * // add it to the game world
   * me.game.world.addChild(levelContainer);
   */
  load(levelId, options) {
    options = Object.assign({
      "container": game.world,
      "onLoaded": game.onLevelLoaded,
      "flatten": game.mergeGroup,
      "setViewportBounds": true
    }, options || {});
    if (typeof levels[levelId] === "undefined") {
      throw new Error("level " + levelId + " not found");
    }
    if (levels[levelId] instanceof TMXTileMap) {
      let wasRunning = state.isRunning();
      if (wasRunning) {
        state.stop();
        defer(safeLoadLevel, this, levelId, options, true);
      } else {
        safeLoadLevel(levelId, options);
      }
    } else {
      throw new Error("no level loader defined");
    }
    return true;
  },
  /**
   * return the current level id<br>
   * @name getCurrentLevelId
   * @memberof level
   * @public
   * @returns {string}
   */
  getCurrentLevelId() {
    return levelIdx[currentLevelIdx];
  },
  /**
   * return the current level definition.
   * for a reference to the live instantiated level,
   * rather use the container in which it was loaded (e.g. me.game.world)
   * @name getCurrentLevel
   * @memberof level
   * @public
   * @returns {TMXTileMap}
   */
  getCurrentLevel() {
    return levels[this.getCurrentLevelId()];
  },
  /**
   * reload the current level
   * @name reload
   * @memberof level
   * @public
   * @param {object} [options] - additional optional parameters
   * @param {Container} [options.container=game.world] - container in which to load the specified level
   * @param {Function} [options.onLoaded=game.onLevelLoaded] - callback for when the level is fully loaded
   * @param {boolean} [options.flatten=game.mergeGroup] - if true, flatten all objects into the given container
   * @returns {object} the current level
   */
  reload(options) {
    return this.load(this.getCurrentLevelId(), options);
  },
  /**
   * load the next level
   * @name next
   * @memberof level
   * @public
   * @param {object} [options] - additional optional parameters
   * @param {Container} [options.container=game.world] - container in which to load the specified level
   * @param {Function} [options.onLoaded=game.onLevelLoaded] - callback for when the level is fully loaded
   * @param {boolean} [options.flatten=game.mergeGroup] - if true, flatten all objects into the given container
   * @returns {boolean} true if the next level was successfully loaded
   */
  next(options) {
    if (currentLevelIdx + 1 < levelIdx.length) {
      return this.load(levelIdx[currentLevelIdx + 1], options);
    } else {
      return false;
    }
  },
  /**
   * load the previous level<br>
   * @name previous
   * @memberof level
   * @public
   * @param {object} [options] - additional optional parameters
   * @param {Container} [options.container=game.world] - container in which to load the specified level
   * @param {Function} [options.onLoaded=game.onLevelLoaded] - callback for when the level is fully loaded
   * @param {boolean} [options.flatten=game.mergeGroup] - if true, flatten all objects into the given container
   * @returns {boolean} true if the previous level was successfully loaded
   */
  previous(options) {
    if (currentLevelIdx - 1 >= 0) {
      return this.load(levelIdx[currentLevelIdx - 1], options);
    } else {
      return false;
    }
  },
  /**
   * return the amount of level preloaded
   * @name levelCount
   * @memberof level
   * @public
   * @returns {number} the amount of level preloaded
   */
  levelCount() {
    return levelIdx.length;
  }
};
function preloadTMX(tmxData, onload2, onerror2, settings) {
  if (typeof tmxList[tmxData.name] !== "undefined") {
    return 0;
  }
  function addToTMXList(data2) {
    tmxList[tmxData.name] = data2;
    if (tmxData.type === "tmx") {
      level.add(tmxData.type, tmxData.name);
    }
  }
  if (tmxData.data) {
    addToTMXList(tmxData.data);
    if (typeof onload2 === "function") {
      onload2();
    }
    return;
  }
  fetchData(tmxData.src, "text", settings).then((response) => {
    if (typeof response !== "string") {
      throw new Error("Invalid response type");
    }
    let result;
    switch (getExtension(tmxData.src)) {
      case "xml":
      case "tmx":
      case "tsx": {
        const parser = new DOMParser();
        if (typeof parser.parseFromString === "undefined") {
          throw new Error(
            "XML file format loading supported, use the JSON file format instead"
          );
        }
        const xmlDoc = parser.parseFromString(response, "text/xml");
        const data2 = parse(xmlDoc);
        result = data2.map || data2.tilesets[0] || data2;
        break;
      }
      case "json":
      case "tmj":
      case "tsj":
        result = JSON.parse(response);
        break;
      default:
        throw new Error(`TMX file format not supported: ${getExtension(tmxData.src)}`);
    }
    addToTMXList(result);
    if (typeof onload2 === "function") {
      onload2();
    }
  }).catch((error2) => {
    if (typeof onerror2 === "function") {
      onerror2(error2);
    }
  });
  return 1;
}
function preloadJSON(data2, onload2, onerror2, settings) {
  if (typeof jsonList[data2.name] !== "undefined") {
    return 0;
  }
  fetchData(data2.src, "json", settings).then((response) => {
    jsonList[data2.name] = response;
    if (typeof onload2 === "function") {
      onload2();
    }
  }).catch((error2) => {
    if (typeof onerror2 === "function") {
      onerror2(error2);
    }
  });
  return 1;
}
function preloadBinary(data2, onload2, onerror2, settings) {
  fetchData(data2.src, "arrayBuffer", settings).then((response) => {
    const decoder = new TextDecoder();
    binList[data2.name] = decoder.decode(response);
    if (typeof onload2 === "function") {
      onload2();
    }
  }).catch((error2) => {
    if (typeof onerror2 === "function") {
      onerror2(error2);
    }
  });
  return 1;
}
function preloadJavascript(data2, onload2, onerror2, settings) {
  let script = globalThis.document.createElement("script");
  script.src = data2.src;
  script.type = "text/javascript";
  if (typeof crossOrigin === "string") {
    script.crossOrigin = settings.crossOrigin;
  }
  script.defer = true;
  if (typeof onload2 === "function") {
    script.onload = () => {
      onload2();
    };
  }
  if (typeof onerror2 === "function") {
    script.onerror = () => {
      onerror2(data2.name);
    };
  }
  globalThis.document.getElementsByTagName("body")[0].appendChild(script);
  return 1;
}
function preloadVideo(data2, onload2, onerror2, settings) {
  if (typeof videoList[data2.name] !== "undefined") {
    return 0;
  }
  let videoElement = videoList[data2.name] = globalThis.document.createElement("video");
  if (isDataUrl(data2.src)) {
    const mimeType = data2.src.match(/[^:]\w+\/[\w-+\d.]+(?=;|,)/)[0];
    if (!mimeType || videoElement.canPlayType(mimeType) === "") {
      throw new Error(`Invalid dataURL or Video file format not supported: ${mimeType}`);
    }
  } else {
    if (!hasVideoFormat(getExtension(data2.src))) {
      throw new Error(`Video file format not supported: ${getExtension(data2.src)}`);
    }
  }
  if (isDataUrl(data2.src)) {
    fetchData(data2.src, "blob", settings).then((blob) => {
      videoElement.src = globalThis.URL.createObjectURL(blob);
    }).catch((error2) => {
      if (typeof onerror2 === "function") {
        onerror2(error2);
      }
    });
  } else {
    videoElement.src = data2.src;
  }
  videoElement.setAttribute("preload", data2.stream === true ? "metadata" : "auto");
  videoElement.setAttribute("playsinline", "true");
  videoElement.setAttribute("disablePictureInPicture", "true");
  videoElement.setAttribute("controls", "false");
  videoElement.setAttribute("crossorigin", settings.crossOrigin);
  if (data2.autoplay === true) {
    videoElement.setAttribute("autoplay", "true");
  }
  if (data2.loop === true) {
    videoElement.setAttribute("loop", "true");
  }
  if (typeof onload2 === "function") {
    if (data2.stream === true || data2.autoplay === false) {
      videoElement.onloadedmetadata = () => {
        if (typeof onload2 === "function") {
          onload2();
        }
      };
    } else {
      videoElement.oncanplay = () => {
        if (typeof onload2 === "function") {
          onload2();
        }
      };
    }
  }
  if (typeof onerror2 === "function") {
    videoElement.onerror = () => {
      onerror2();
    };
  }
  videoElement.load();
  return 1;
}
var nocache = "";
var baseURL = {};
var crossOrigin$1;
var withCredentials = false;
function setNocache(enable2 = false) {
  nocache = enable2 ? "?" + ~~(Math.random() * 1e7) : "";
}
function setOptions(options) {
  if (options.crossOrigin !== void 0) {
    crossOrigin$1 = options.crossOrigin;
  }
  if (options.nocache !== void 0) {
    setNocache(options.nocache);
  }
  if (options.withCredentials !== void 0) {
    withCredentials = options.withCredentials;
  }
}
function setBaseURL(type, url) {
  if (type !== "*") {
    baseURL[type] = url;
  } else {
    baseURL["audio"] = url;
    baseURL["video"] = url;
    baseURL["binary"] = url;
    baseURL["image"] = url;
    baseURL["json"] = url;
    baseURL["js"] = url;
    baseURL["tmx"] = url;
    baseURL["tsx"] = url;
  }
}
var onload;
var onProgress;
var onError;
var parsers = /* @__PURE__ */ new Map();
var parserInitialized = false;
var resourceCount = 0;
var loadCount = 0;
var timerId = 0;
var failureLoadedAssets = {};
function initParsers() {
  setParser("binary", preloadBinary);
  setParser("image", preloadImage);
  setParser("json", preloadJSON);
  setParser("js", preloadJavascript);
  setParser("tmx", preloadTMX);
  setParser("tsx", preloadTMX);
  setParser("audio", load$1);
  setParser("fontface", preloadFontFace);
  setParser("video", preloadVideo);
  parserInitialized = true;
}
function checkLoadStatus(onloadcb) {
  if (loadCount === resourceCount) {
    if (typeof onloadcb === "function" || onload) {
      clearTimeout(timerId);
      let callback = onloadcb || onload;
      setTimeout(() => {
        callback();
        emit(LOADER_COMPLETE);
      }, 300);
    } else {
      throw new Error("no load callback defined");
    }
  } else {
    timerId = setTimeout(() => {
      checkLoadStatus(onloadcb);
    }, 100);
  }
}
function onResourceLoaded(res) {
  delete failureLoadedAssets[res.src];
  loadCount++;
  let progress = loadCount / resourceCount;
  if (typeof onProgress === "function") {
    onProgress(progress, res);
  }
  emit(LOADER_PROGRESS, progress, res);
}
function onLoadingError(res) {
  failureLoadedAssets[res.src] = res;
  if (this.onError) {
    this.onError(res);
  }
  emit(LOADER_ERROR, res);
  throw new Error("Failed loading resource " + res.src);
}
function setParser(type, parserFn) {
  if (typeof parserFn !== "function") {
    throw new Error("invalid parser function for " + type);
  }
  if (typeof parsers.get(type) !== "undefined") {
    warning("overriding parser for " + type + " format");
  }
  parsers.set(type, parserFn);
}
function preload(assets, onloadcb, switchToLoadState = true) {
  for (let i = 0; i < assets.length; i++) {
    resourceCount += load(
      assets[i],
      onResourceLoaded.bind(this, assets[i]),
      onLoadingError.bind(this, assets[i])
    );
  }
  if (typeof onloadcb !== "undefined") {
    onload = onloadcb;
  }
  if (switchToLoadState === true) {
    state.change(state.LOADING);
  }
  checkLoadStatus(onload);
}
function reload(src) {
  const assetToReload = failureLoadedAssets[src];
  this.unload(assetToReload);
  resourceCount -= 1;
  resourceCount += this.load(
    assetToReload,
    this.onResourceLoaded.bind(this, assetToReload),
    this.onLoadingError.bind(this, assetToReload)
  );
  checkLoadStatus(this.onload);
}
function load(asset, onload2, onerror2) {
  if (parserInitialized === false) {
    initParsers();
  }
  if (typeof baseURL[asset.type] !== "undefined") {
    asset.src = baseURL[asset.type] + asset.src;
  }
  let parser = parsers.get(asset.type);
  if (typeof parser === "undefined") {
    throw new Error("load : unknown or invalid resource type : " + asset.type);
  }
  return parser.call(this, asset, onload2, onerror2, {
    nocache,
    crossOrigin: crossOrigin$1,
    withCredentials
  });
}
function unload(asset) {
  switch (asset.type) {
    case "binary":
      if (!(asset.name in binList)) {
        return false;
      }
      delete binList[asset.name];
      return true;
    case "image":
      if (!(asset.name in imgList)) {
        return false;
      }
      delete imgList[asset.name];
      return true;
    case "json":
      if (!(asset.name in jsonList)) {
        return false;
      }
      delete jsonList[asset.name];
      return true;
    case "js":
      return true;
    case "fontface":
      if (typeof typeof globalThis.document !== "undefined" && typeof globalThis.document.fonts !== "undefined") {
        globalThis.document.fonts.delete(fontList[asset.name]);
        delete fontList[asset.name];
        return true;
      }
      return false;
    case "tmx":
    case "tsx":
      if (!(asset.name in tmxList)) {
        return false;
      }
      delete tmxList[asset.name];
      return true;
    case "audio":
      return unload$1(asset.name);
    case "video":
      if (!(asset.name in videoList)) {
        return false;
      }
      delete videoList[asset.name];
      return true;
    default:
      throw new Error("unload : unknown or invalid resource type : " + asset.type);
  }
}
function unloadAll() {
  let name;
  for (name in binList) {
    if (binList.hasOwnProperty(name)) {
      unload({
        "name": name,
        "type": "binary"
      });
    }
  }
  for (name in imgList) {
    if (imgList.hasOwnProperty(name)) {
      unload({
        "name": name,
        "type": "image"
      });
    }
  }
  for (name in tmxList) {
    if (tmxList.hasOwnProperty(name)) {
      unload({
        "name": name,
        "type": "tmx"
      });
    }
  }
  for (name in jsonList) {
    if (jsonList.hasOwnProperty(name)) {
      unload({
        "name": name,
        "type": "json"
      });
    }
  }
  for (name in videoList) {
    if (videoList.hasOwnProperty(name)) {
      unload({
        "name": name,
        "type": "json"
      });
    }
  }
  for (name in fontList) {
    if (fontList.hasOwnProperty(name)) {
      unload({
        "name": name,
        "type": "font"
      });
    }
  }
  unloadAll$1();
}
function getTMX(elt) {
  elt = "" + elt;
  if (elt in tmxList) {
    return tmxList[elt];
  }
  return null;
}
function getBinary(elt) {
  elt = "" + elt;
  if (elt in binList) {
    return binList[elt];
  }
  return null;
}
function getImage(image) {
  image = getBasename("" + image);
  if (image in imgList) {
    return imgList[image];
  }
  return null;
}
function getJSON(elt) {
  elt = "" + elt;
  if (elt in jsonList) {
    return jsonList[elt];
  }
  return null;
}
function getVideo(elt) {
  elt = "" + elt;
  if (elt in videoList) {
    return videoList[elt];
  }
  return null;
}
function getFont(elt) {
  elt = "" + elt;
  if (elt in fontList) {
    return fontList[elt];
  }
  return null;
}
var loader = {
  __proto__: null,
  baseURL,
  get crossOrigin() {
    return crossOrigin$1;
  },
  getBinary,
  getFont,
  getImage,
  getJSON,
  getTMX,
  getVideo,
  load,
  get nocache() {
    return nocache;
  },
  onError,
  onProgress,
  get onload() {
    return onload;
  },
  preload,
  reload,
  setBaseURL,
  setNocache,
  setOptions,
  setParser,
  unload,
  unloadAll,
  get withCredentials() {
    return withCredentials;
  }
};
var Sprite = class extends Renderable {
  /**
   * @param {number} x - the x coordinates of the sprite object
   * @param {number} y - the y coordinates of the sprite object
   * @param {object} settings - Configuration parameters for the Sprite object
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|TextureAtlas|string} settings.image - reference to spritesheet image, a texture atlas, a video element, or to a texture atlas
   * @param {string} [settings.name=""] - name of this object
   * @param {string} [settings.region] - region name of a specific region to use when using a texture atlas, see {@link TextureAtlas}
   * @param {number} [settings.framewidth] - Width of a single frame within the spritesheet
   * @param {number} [settings.frameheight] - Height of a single frame within the spritesheet
   * @param {string|Color} [settings.tint] - a tint to be applied to this sprite
   * @param {number} [settings.flipX] - flip the sprite on the horizontal axis
   * @param {number} [settings.flipY] - flip the sprite on the vertical axis
   * @param {Vector2d} [settings.anchorPoint={x:0.5, y:0.5}] - Anchor point to draw the frame at (defaults to the center of the frame).
   * @example
   * // create a single sprite from a standalone image, with anchor in the center
   * let sprite = new me.Sprite(0, 0, {
   *     image : "PlayerTexture",
   *     framewidth : 64,
   *     frameheight : 64,
   *     anchorPoint : new me.Vector2d(0.5, 0.5)
   * });
   *
   * // create a single sprite from a packed texture
   * mytexture = new me.TextureAtlas(
   *     me.loader.getJSON("texture"),
   *     me.loader.getImage("texture")
   * );
   * let sprite = new me.Sprite(0, 0, {
   *     image : mytexture,
   *     region : "npc2.png",
   * });
   *
   * // create a video sprite
   * let videoSprite = new me.Sprite(0, 0, {
   *     image : me.loader.getVideo("bigbunny"),
   *     anchorPoint : new me.Vector2d(0.5, 0.5)
   * });
   * // scale the video sprite
   * videoSprite.currentTransform.scale(2);
   * // start playing the video (if video is preloaded with `autoplay` set to false)
   * videoSprite.play();
   */
  constructor(x, y, settings) {
    super(x, y, 0, 0);
    this.animationpause = false;
    this.animationspeed = 100;
    this.offset = pool.pull("Vector2d", 0, 0);
    this.isVideo = false;
    this.onended;
    this.source = null;
    this.anim = {};
    this.resetAnim = void 0;
    this.current = {
      // the current animation name
      name: void 0,
      // length of the current animation name
      length: 0,
      //current frame texture offset
      offset: pool.pull("Vector2d", 0, 0),
      // current frame size
      width: 0,
      height: 0,
      // Source rotation angle for pre-rotating the source image
      angle: 0,
      // current frame index
      idx: 0
    };
    this.dt = 0;
    this._flicker = {
      isFlickering: false,
      duration: 0,
      callback: null,
      state: false
    };
    if (settings.image instanceof TextureAtlas) {
      this.source = settings.image;
      this.image = this.source.getTexture();
      this.textureAtlas = settings.image;
      if (typeof settings.region !== "undefined") {
        let region = this.source.getRegion(settings.region);
        if (region) {
          this.setRegion(region);
        } else {
          throw new Error("Texture - region for " + settings.region + " not found");
        }
      }
    } else {
      this.image = typeof settings.image === "object" ? settings.image : getImage(settings.image);
      if (!this.image) {
        throw new Error("me.Sprite: '" + settings.image + "' image/texture not found!");
      }
      this.isVideo = HTMLVideoElement && this.image instanceof HTMLVideoElement;
      if (this.isVideo) {
        this.width = this.current.width = settings.framewidth = settings.framewidth || this.image.videoWidth;
        this.height = this.current.height = settings.frameheight = settings.frameheight || this.image.videoHeight;
        this.animationpause = this.image.autoplay !== true;
        if (this.animationpause) {
          this.image.pause();
        }
        this._onBlurFn = () => {
          this.image.pause();
        };
        on(STATE_PAUSE, this._onBlurFn);
        this.image.onended = () => {
          if (typeof this.onended === "function") {
            if (!this.image.loop) {
              this.animationpause = true;
            }
            this.onended();
          }
        };
      } else {
        this.width = this.current.width = settings.framewidth = settings.framewidth || this.image.width;
        this.height = this.current.height = settings.frameheight = settings.frameheight || this.image.height;
        this.source = renderer.cache.get(this.image, settings);
        this.textureAtlas = this.source.getAtlas();
      }
    }
    if (typeof settings.atlas !== "undefined") {
      this.textureAtlas = settings.atlas;
      this.atlasIndices = settings.atlasIndices;
    }
    if (typeof settings.flipX !== "undefined") {
      this.flipX(!!settings.flipX);
    }
    if (typeof settings.flipY !== "undefined") {
      this.flipY(!!settings.flipY);
    }
    if (typeof settings.rotation !== "undefined") {
      this.rotate(settings.rotation);
    }
    if (settings.anchorPoint) {
      this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
    }
    if (typeof settings.tint !== "undefined") {
      if (settings.tint instanceof Color) {
        this.tint.copy(settings.tint);
      } else {
        this.tint.parseCSS(settings.tint);
      }
    }
    if (typeof settings.name === "string") {
      this.name = settings.name;
    }
    if (typeof settings.z !== "undefined") {
      this.pos.z = settings.z;
    }
    if (typeof settings.anims !== "undefined") {
      for (const anim in settings.anims) {
        this.addAnimation(settings.anims[anim].name, settings.anims[anim].index, settings.anims[anim].speed);
      }
    }
    if (!this.isVideo && this.addAnimation("default", null) !== 0) {
      this.setCurrentAnimation("default");
    }
  }
  /**
   * return the flickering state of the object
   * @returns {boolean}
   */
  isFlickering() {
    return this._flicker.isFlickering;
  }
  /**
   * play or resume the current animation or video
   */
  play() {
    this.animationpause = false;
  }
  /**
   * play or resume the current animation or video
   */
  pause() {
    this.animationpause = true;
  }
  /**
   * make the object flicker
   * @param {number} duration - expressed in milliseconds
   * @param {Function} callback - Function to call when flickering ends
   * @returns {Sprite} Reference to this object for method chaining
   * @example
   * // make the object flicker for 1 second
   * // and then remove it
   * this.flicker(1000, function () {
   *     world.removeChild(this);
   * });
   */
  flicker(duration, callback) {
    this._flicker.duration = duration;
    if (this._flicker.duration <= 0) {
      this._flicker.isFlickering = false;
      this._flicker.callback = null;
    } else if (!this._flicker.isFlickering) {
      this._flicker.callback = callback;
      this._flicker.isFlickering = true;
    }
    return this;
  }
  /**
   * add an animation <br>
   * For fixed-sized cell sprite sheet, the index list must follow the
   * logic as per the following example :<br>
   * <img src="images/spritesheet_grid.png"/>
   * @param {string} name - animation id
   * @param {number[]|string[]|object[]} index - list of sprite index or name defining the animation. Can also use objects to specify delay for each frame, see below
   * @param {number} [animationspeed] - cycling speed for animation in ms
   * @returns {number} frame amount of frame added to the animation (delay between each frame).
   * @see Sprite#animationspeed
   * @example
   * // walking animation
   * this.addAnimation("walk", [ 0, 1, 2, 3, 4, 5 ]);
   * // standing animation
   * this.addAnimation("stand", [ 11, 12 ]);
   * // eating animation
   * this.addAnimation("eat", [ 6, 6 ]);
   * // rolling animation
   * this.addAnimation("roll", [ 7, 8, 9, 10 ]);
   * // slower animation
   * this.addAnimation("roll", [ 7, 8, 9, 10 ], 200);
   * // or get more specific with delay for each frame. Good solution instead of repeating:
   * this.addAnimation("turn", [{ name: 0, delay: 200 }, { name: 1, delay: 100 }])
   * // can do this with atlas values as well:
   * this.addAnimation("turn", [{ name: "turnone", delay: 200 }, { name: "turntwo", delay: 100 }])
   * // define an dying animation that stop on the last frame
   * this.addAnimation("die", [{ name: 3, delay: 200 }, { name: 4, delay: 100 }, { name: 5, delay: Infinity }])
   * // set the standing animation as default
   * this.setCurrentAnimation("stand");
   */
  addAnimation(name, index2, animationspeed) {
    this.anim[name] = {
      name,
      frames: [],
      idx: 0,
      length: 0
    };
    let counter = 0;
    if (typeof this.textureAtlas !== "object") {
      return 0;
    }
    if (index2 == null) {
      index2 = [];
      Object.keys(this.textureAtlas).forEach((v, i) => {
        index2[i] = i;
      });
    }
    for (let i = 0, len = index2.length; i < len; i++) {
      let frame = index2[i];
      let frameObject;
      if (typeof frame === "number" || typeof frame === "string") {
        frameObject = {
          name: frame,
          delay: animationspeed || this.animationspeed
        };
      } else {
        frameObject = frame;
      }
      let frameObjectName = frameObject.name;
      if (typeof frameObjectName === "number") {
        if (typeof this.textureAtlas[frameObjectName] !== "undefined") {
          this.anim[name].frames[i] = Object.assign(
            {},
            this.textureAtlas[frameObjectName],
            frameObject
          );
          counter++;
        }
      } else {
        if (this.source.getFormat().includes("Spritesheet")) {
          throw new Error(
            "string parameters for addAnimation are not allowed for standard spritesheet based Texture"
          );
        } else {
          this.anim[name].frames[i] = Object.assign(
            {},
            this.textureAtlas[this.atlasIndices[frameObjectName]],
            frameObject
          );
          counter++;
        }
      }
    }
    this.anim[name].length = counter;
    return counter;
  }
  /**
   * set the current animation
   * this will always change the animation & set the frame to zero
   * @param {string} name - animation id
   * @param {string|Function} [resetAnim] - animation id to switch to when complete, or callback
   * @param {boolean} [preserve_dt=false] - if false will reset the elapsed time counter since last frame
   * @returns {Sprite} Reference to this object for method chaining
   * @example
   * // set "walk" animation
   * this.setCurrentAnimation("walk");
   *
   * // set "walk" animation if it is not the current animation
   * if (this.isCurrentAnimation("walk")) {
   *     this.setCurrentAnimation("walk");
   * }
   *
   * // set "eat" animation, and switch to "walk" when complete
   * this.setCurrentAnimation("eat", "walk");
   *
   * // set "die" animation, and remove the object when finished
   * this.setCurrentAnimation("die", () => {
   *    world.removeChild(this);
   *    return false; // do not reset to first frame
   * });
   *
   * // set "attack" animation, and pause for a short duration
   * this.setCurrentAnimation("die", () => {
   *    this.animationpause = true;
   *
   *    // back to "standing" animation after 1 second
   *    setTimeout(function () {
   *        this.setCurrentAnimation("standing");
   *    }, 1000);
   *
   *    return false; // do not reset to first frame
   * });
   */
  setCurrentAnimation(name, resetAnim, preserve_dt = false) {
    if (typeof this.anim[name] !== "undefined") {
      if (!this.isCurrentAnimation(name)) {
        this.current.name = name;
        this.current.length = this.anim[this.current.name].length;
        if (typeof resetAnim === "string") {
          this.resetAnim = this.setCurrentAnimation.bind(this, resetAnim, null, true);
        } else if (typeof resetAnim === "function") {
          this.resetAnim = resetAnim;
        } else {
          this.resetAnim = void 0;
        }
        this.setAnimationFrame(0);
        if (!preserve_dt) {
          this.dt = 0;
        }
        this.isDirty = true;
      }
    } else {
      throw new Error("animation id '" + name + "' not defined");
    }
    return this;
  }
  /**
   * reverse the given or current animation if none is specified
   * @param {string} [name] - animation id
   * @returns {Sprite} Reference to this object for method chaining
   * @see Sprite#animationspeed
   */
  reverseAnimation(name) {
    if (typeof name !== "undefined" && typeof this.anim[name] !== "undefined") {
      this.anim[name].frames.reverse();
    } else {
      this.anim[this.current.name].frames.reverse();
    }
    this.isDirty = true;
    return this;
  }
  /**
   * return true if the specified animation is the current one.
   * @param {string} name - animation id
   * @returns {boolean}
   * @example
   * if (!this.isCurrentAnimation("walk")) {
   *     // do something funny...
   * }
   */
  isCurrentAnimation(name) {
    return this.current.name === name;
  }
  /**
   * change the current texture atlas region for this sprite
   * @see Texture.getRegion
   * @param {object} region - typically returned through me.Texture.getRegion()
   * @returns {Sprite} Reference to this object for method chaining
   * @example
   * // change the sprite to "shadedDark13.png";
   * mySprite.setRegion(mytexture.getRegion("shadedDark13.png"));
   */
  setRegion(region) {
    this.image = this.source.getTexture(region);
    this.current.offset.setV(region.offset);
    this.current.angle = typeof region.angle === "number" ? region.angle : 0;
    this.width = this.current.width = region.width;
    this.height = this.current.height = region.height;
    if (region.anchorPoint) {
      this.anchorPoint.setMuted(
        this._flip.x && region.trimmed === true ? 1 - region.anchorPoint.x : region.anchorPoint.x,
        this._flip.y && region.trimmed === true ? 1 - region.anchorPoint.y : region.anchorPoint.y
      );
    }
    this.updateBounds();
    this.isDirty = true;
    return this;
  }
  /**
   * force the current animation frame index.
   * @param {number} [index=0] - animation frame index
   * @returns {Sprite} Reference to this object for method chaining
   * @example
   * // reset the current animation to the first frame
   * this.setAnimationFrame();
   */
  setAnimationFrame(index2 = 0) {
    this.current.idx = index2 % this.current.length;
    return this.setRegion(this.getAnimationFrameObjectByIndex(this.current.idx));
  }
  /**
   * return the current animation frame index.
   * @returns {number} current animation frame index
   */
  getCurrentAnimationFrame() {
    return this.current.idx;
  }
  /**
   * Returns the frame object by the index.
   * @ignore
   * @param {number} id - the frame id
   * @returns {number} if using number indices. Returns {object} containing frame data if using texture atlas
   */
  getAnimationFrameObjectByIndex(id2) {
    return this.anim[this.current.name].frames[id2];
  }
  /**
   * update function. <br>
   * automatically called by the game manager {@link game}
   * @protected
   * @param {number} dt - time since the last update in milliseconds.
   * @returns {boolean} true if the Sprite is dirty
   */
  update(dt) {
    if (this.isVideo) {
      if (this.animationpause) {
        this.image.pause();
      } else if (this.image.paused) {
        this.image.play();
      }
      this.isDirty = !this.image.paused;
    } else {
      if (!this.animationpause && this.current.length > 1) {
        let duration = this.getAnimationFrameObjectByIndex(this.current.idx).delay;
        this.dt += dt;
        while (this.dt >= duration) {
          this.isDirty = true;
          this.dt -= duration;
          let nextFrame = this.current.length > 1 ? this.current.idx + 1 : this.current.idx;
          this.setAnimationFrame(nextFrame);
          if (this.current.idx === 0) {
            if (typeof this.onended === "function") {
              this.onended();
            }
            if (typeof this.resetAnim === "function") {
              if (this.resetAnim() === false) {
                this.setAnimationFrame(this.current.length - 1);
                this.dt %= duration;
                break;
              }
            }
          }
          duration = this.getAnimationFrameObjectByIndex(this.current.idx).delay;
        }
      }
    }
    if (this._flicker.isFlickering) {
      this._flicker.duration -= dt;
      if (this._flicker.duration < 0) {
        if (typeof this._flicker.callback === "function") {
          this._flicker.callback();
        }
        this.flicker(-1);
      }
      this.isDirty = true;
    }
    return super.update(dt);
  }
  /**
   * draw this srite (automatically called by melonJS)
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
    if (this._flicker.isFlickering) {
      this._flicker.state = !this._flicker.state;
      if (!this._flicker.state) {
        return;
      }
    }
    let frame = this.current;
    let xpos = this.pos.x, ypos = this.pos.y;
    let w = frame.width, h = frame.height;
    let frame_offset = frame.offset;
    let g_offset = this.offset;
    if (frame.angle !== 0) {
      renderer2.translate(-xpos, -ypos);
      renderer2.rotate(frame.angle);
      xpos -= h;
      w = frame.height;
      h = frame.width;
    }
    renderer2.drawImage(
      this.image,
      g_offset.x + frame_offset.x,
      // sx
      g_offset.y + frame_offset.y,
      // sy
      w,
      h,
      // sw,sh
      xpos,
      ypos,
      // dx,dy
      w,
      h
      // dw,dh
    );
  }
  /**
   * Destroy function<br>
   * @ignore
   */
  destroy() {
    pool.push(this.offset);
    this.offset = void 0;
    if (this.isVideo) {
      off(STATE_PAUSE, this._onBlurFn);
      this._onBlurFn = void 0;
      this.image.onended = void 0;
      this.image.pause();
      this.image.currentTime = 0;
    }
    this.image = void 0;
    super.destroy();
  }
};
var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA8FBMVEUgICBrqDHRZVtqpzEhJCAjKCBurTIfHyDQZFptrDEWAB8OAB7VZ1wtIiIAEhYlISDYaF4SAB4pIiEAFhkcFh8eGyBopDAMAB5noS8kKyAAGhtjmy4bEB9lni8ZBR/HYFdPeim/XFQ9XCUaCh9flS1VhCtSfyorOSEVHh4HHB1EZyatVExhmC5ajCxHbSc0SyMuQCInMiFKcSgxRSI6VSRBYiWdTUZdki09JyZ8PzpYiSs3UCRlNjK1WE9ckC1MdShbjywyJCONRkDKYliUSUNeMzBDKShXMC2kUEl1PDeEQj1OLStnNjNxOjZsODQAAAcMh1CFAAAU4UlEQVR42uyaa3fSMBjHk5EQkgClkBZKoXblNhlswIooc2N6pp7jUb//x/FpRbnt4JWwzv7eraQvfs/zby7tUEpKSkpKSkpKSkpKSkpKSkqKTsg30P8E+FIArJllqQaglMXQt6tPuhogGSlaLWFKKU2hEB33eqPRqDemRAlhRhdbVjwIBj8xogajhpBSkNH1dOJ37mYDt1mr2UCt1mwOZned7qQfjhxPVs0WovTpRIFFNkpIU42CSWfm2phnIzjHP+DLS9hutjuL4IqZUigC9yU/CWDBhBROOJkPbBxL4swKjDf/jEvBbXe4CMeiKixKEx0EAq03JbqeDJs4Ul9a7mE5AqqAazM/pJCb5JaAUmWa42nHBflYDf8y8WC4qznv9yRKZAUIRUKO+/Maz/J1+d8ugu0rK3kVoNSTVhDZr8v/WRGyQw8lC0KJMK989+/sVzXILiRNzmrACGXSC4Z2lsf2f08GN2lyHgJCLUn6bRw1/2dim+A9hIKiJMAQ6NOJu7f5a7r8B+u/7N7BAzMZBaBIkkkz0t83sfMsgDHsgN1BOybaFNvww2qblMgEUGKqi2aU/X3u2HZnHf8iuL4aO0S1PKDVQM54dBn0F50718bfq5CwOYBQIaaDVfd37MG91u5MwhER8WHQU8qC2wCEmFJefEYUrBdedGe15b4xQasAtaqXt/wh/W87W1679YNeCxQbjNCItTchBFheRErAmHEYb575ch/Qeuz9ByXpdHH2QX2wx4NuMBbSbJCfn3IJWZ4dndBvZ6Bytt949A8AbZjT6OHftQeDTHtx2VgebhFj6KfAmGisJaS46k+mj/4sELW/N+QP6UOIXf/Sqwq0p/F7okA8KU312BcAqmTf3k1/1Hx7HlgyskfsL96h7b3XMNCRcYQzz+KH9N3FSC57fxiYUTDOWLmAjgcjpBo2d9oPKxdv95Fs0UPGl5XPinWDVYqGwdBxYFQJH/Mdfc5nQUuyw77KYYXKm/ub09PzV/Xn5SNVAOJ/B/Hf0W8HwiQUHRTwf/2slM/nS6WbN/XjZIDK6534w8zv9r1In6GDUq6/y+VzMaVTdGYg7cDj38/wHX17YknQPzSGUb8p5U5icqX7ovaZkBFk+nw7/hx3epIdvPtAufIpf7Ikl39W0B0BRpToQPy32j8IZUPPW+xC8S0E4Afv6noLwGgL3WZ32u8roetbTqF4v1aA/JdKGWmEUc8ZgP/m0j+4riKKNFEoflwrQO6D1gQwKnrulj/mXUto048XgZV+/vQMaYQ5otfc8s/Wpprav5oFz5cRgHXwo85VgFHw55nN+Ld7UvMnPOP5y2elXMRJ6VzDA7DPH2e7XstBemHl+vubfAk4efGc6SsAo9542x9fVJH+D/lQgfrnF+fn9++KWv0bdHP+z3A7rFKC9MMMo1KsVIr1ssYHgFiqvemfdUemg45EuVAuFMpIH4SI4ZZ/2xEOQ8eCAUgjVHa3/G+txuN/Z/+vYE51suU/9NT/5G8GIL3uPxfsCfwf11fyrW1FgRiGTkna0vZpYHQUXRHdVZBhvCMorP7/V+3oyprgPiy2Dxk2HzA06TknpyHz19CjVfcpf9kj+6SBtqgcMPz/q/vPdPgwLP/DsCM1f2vTf7Ifap5/hYXQ/FGnX7S16LdABADc23oqVP91kYfgrU5b1GxKHSCo7tILzR/z9eJ8nliv0zqAMZ8ATEJfaP6+7jlj3CDlXpHVfsfnH+eyn4kMzMdGQRNO7fNkGEXbGTigBkDq1lZzU07BnaXzIab6LCMAuEEmdWcD8+ax9uNTckxFqyWxwKBgKXZrzerHtAbcPhFQ0R8oAExdChXADIt1Tz0KkGi9TjML1CBLqgA0YZGIFZhZqVNUtf9GCdBbF0IF4Be/vvQYz6pyxhRwH+QC4CpXoAgELvE6iKMtfwJLzv+5YU2iDasOR0MJMBdMgFsMK6ICrppGY+rELGAdhFpAYoXYgRdBRzsLUtB3L/z+7zpITFvHYhQAdorGyQudAdCuNe8qoJjVNgYAF0M+9iFbAe9tK2w4BKIIdVJ0CLASv7jeBFo7cBwCrxcgP1IAjEv5ALipwII1gmGGMR4A2uEB+blJK4x4E1kdZhQA5xYowPe58z3lwKfH199WbQRAc/LpuwPWu17k0qaFCnANAgHSvKJcZdMCxJtgOsQuKsexG2uCwMxa8O8aUa/axHZCe/OUZA42ag0Avqi5ll2nYSAaRQEbZI+NrbKwEFFYJURCiEcpqEE0aZOmBfH/f4PLQ+OEttwxLKg3jq5Or3TG9jyOJ/FjgSIGZvBRLhB1oFvi7/3X5CIDhZHodOLtfyyEXUlh0IGzyDoQM+rbGljFRNaE2ZOXj0MT3pALxGQo8v1z1ILRBb6+hTJoZgLvBoMYRjZAeALuv/v/hZCzeTxWRIu/iwEvbqQMmKcxUekwHqF/KQSo74OCVX8rCyQoC9C/QYBZENZTcYMlRkqjWFlVZfn9OWGXwcoDVFKewD+fo33v9AwQD3HGFqH5XsXHACWVA7BObfp+YyoL4BKpLvb+MuvBlVn1q03iwIONVNFy1jPUBvGyPOaGJT4GGOPAHd9v66bIuy7Pi3p5GKoTrYSdeRXaQrk7LD02P2Gbejv2FqrYdugFxgHM5ChBEFNpIn/czxaObdMJrcXP4Z94sdxZUGZmAZmA+7ws0im4a9oenFQsKg58uE8NhBgE43+LlBysa65FmvJweIppMzobsmJKWve+EFrMsUJ3+wEqGaUKPA9XkSYNhj0xUd8xYkbBsU516lnMhv+LFs1nKCX7BZYVjIUQZ8FC830PRjG6LnSqBzCSPcloP0U9IaLZhknntlynSGhOS+yV/bWuEla1EPwSONXdAc0VKYv4ZcyoWQBGEDp/2zdI/zyrYgfyR6CAL7nm18BC18pJFnlLhuUMsScgvs9CwjrXyOgCq/Q9yIQpBa0Q/DqW6+JoJSNX9AGNT4S2uezhx8B9kBvu2AZGjpQubwLRglHKLnX6Z7DodmgBQjDHkji7O3+MoFFZgITx+pLiMdiChL1G7DUL8DWQLBDPw3dGh5Yjn38YT+TuMrhuvy71HbGiGyzRAg8DVYQQzO49evYg7ArLiP7v82/7n3OcZ8u6F36+IzjfVCqivwkTetqNCHpP2nvdfS74PJTr7zH+NM9pTflPwTMbcN1YkgEwFcL7EXIddf85LQ1SrtZ8FsO6uh13w7Abt02nZ7tjbiuR1+2Xn2COYPxaCCM3+KCqQz86fnpDSgOkPQg+i/dtb8E6P/zUt8Vln+/pF4fVD7D103Gbz8B8cIbULeJlHXqLM2ZQZDHEuGMnpsF+m0Alpfk+pKmAtZdCJNf5wUGJYAervRB8eggotSH2SlAy2myBchi14VbCxKlzka+BScWCqofBUASYCbsVKAQzD65g7CbmEl9OCTQtocEm74ysiPsq6imhilLVxANyUfR2o9i0SN7YstH8DP+9db+DYcD/iFsgqnXWd02SXAc9CrLpx124yFd2w35HlQ4tEPCHxPwO9haY7oG1NbQbMnLPYPbw2YNIMYAlxeTIDlP+WP0axAUhTrGzefUXEeK+kXetvU3DUDQtqdxKSQwJG1romIbQSLWhfuChFRioG92rsP//c3AiwbErxfKxBMoFf/am5cyPc+899/hDkTOJHZ4IKMQQrC6irDZTh+YVa9VHlsbuyK6uEe7tINCdK9hVutGkUgL/S0pox5cEchPX2X9qrXVfuIQIoAcsDN2sj+yb5XuVU8JZlgkpZ+PMzMbhvG0AwKqfteh6O3VZbqL8J4tNhggAluxxBgaNEIK7A/BNWvkWC7DCV/X+3qsMU0+LkqiS75NyMUhD+LqqrjdT51TPlQeAVTZ11nXpW1nm1sDOWhA1blBBcGEincwV1crqwV7Vq6r0U8ZxiCEevONwtzaaKnGS6X3lCGRHSwaAuyzU4Uyr5tjaLv4wL6+cm3BbxwFw9pSujJsfowBY2UfAutHeyRftZGwXb4RxY2+XDQHAgQGAlblMHI382xeRABwnSicBpyDYjS/HADYILhiYFAMA6k8DUDgANCQAfue0bPy3AeC3QD48AGK2gHLOgJFwAKhDENfgvwkArkGGCH0SDcAuEeKp8MhQYcEAtFT4EU2Fn9nB0HvJAExQHEMwRIfDogFgw2GI7eGXIhkANyESlxITvQLc/2UwAO+cLILgW4BMikIg46TF01QwAGxaHOwBuoI9uQBwhRGMPbs09nouFwCo3fAlLG6GCooFAMVRrGVaXTUz5XGxAHjK44xAQioArUBiZgskYiUyUrcAKhygdDEiqT2xPACZDS6qSe2+y04hIROAFM5aSO6F2qe5pmxDAMBJivJCydFhqsiOK9SHhQLQNb/ahTHFycsglh7EFogB4IQUSyORsqT841Aay8aBxR7VqYlQHPfK33SysAUVwY/qzF/ZO5kRfKLljAkidJMfZaEPgJXVD+ubNnUZqL0yS0upwKAOWidW7ZY++UhSIRQxp79KmAvth8sIha5Q8VZJ0B6YdquFaZlBTjyl7UMQEQcXyG8fZ93TN+MHCJv75l4bzWQ3+RhlRI8A2UzGozpEdpvjgSDRYALh7TY6qS+PWpHvBcT9nmdizk+nmQHsNq+xAHoRuLkYt21k32qlQ/01D0es0gVUCIcAZUimdbG+u7z/XOP7PQgsiu395WpbNKUKaEKqNmbyeZFoNiEKOscrDHkf1bxpmz91GdZY2HWHhjWHlt3kRc6bS/I2IoijIkyadZ7nJTNZU5PpByHAAmhXvkgfGqXUACY77fOc5h2SeXRciTNQ2Gkef56oOAsNtF1KQwCRIN/9CxqFZII8E5WXFpdFiZeW2oNHyRrIhSAfGrMHUCUfrKN8yAI+oYyUkFK2HaVFW2khtR/rPzDal+UkZGjwzOMAwRSJkReScwyi5QGdEvxI2wqZSEdNeGryRNYl018dT9X/zlIzndt0eHR4MNSnVXyPgoAGR3tKYidJ8dOa4PRCTTD2eRl7CUyEmAqirIHqbuxveuOcAjIuApwAHjNFKqmC5lsZIdH8zGuuzp8mYJQCTgGo/FARix7KMSQzYzn8vAAU8gFGcPQS+DJ8AH4rndH8PqQ3S35yd2U7isNAMFHasWw/WcopQhRBIBICQsggJCIx/P9XrTMcDWbZY5YQs36Yh4EZXNXl7vJB3Hkjd7fCkCfc3/ZGbgh4zp5xwYbuBdBWGr00pF2OrT0E6p/sIH6V1uRHTANeDv1NE/j4rB1mFYMHgTYJsJtnrGORL1W9w107NA4/u+gqjL+cFXprU2+cbSvA828GxFKImwRmLpDiji6WwCdvsuDjOU1MA7iI+WzXBj4MmfFpQKuAeC7wOdss6n8afe8qjaUaqNdRWoeEPt1g4wPGpFkMUJKuIruDAaA/ahsToVmXr4NnYanq4GI4eq4waLKJZxADYF12MvFIEO3EZKPLTMxxhADo1ztK0zgtxIND3JhieKnTeKEEhacT4F9OHOB+qRkMXHZwcCOzgwxFv76IfKszMxgg4bqNDDa26cSs01hsmKMtDlj9X8La4sfAdHkvHn6vHhngtGcGAJT+EX+3RxnwDDV+GPf7rIYUQGQa/tyj3RFA063GwN4f98cAJT6f3HaIDaukO1FS8GCuMTCveGz10yhJvIWGP+rWolKSFkMtEw7LvuaGMa/yW/y208iO8GMxXEXslnRnE8LrUyEFIpqhht8edb5aRWNeawzYLJMvnxhQsMKZw16KHw2RzoC7iF+dCOJ0PGX2a/Hj0sNFA5gIPl4zDFD+KzX8dfzhoyh0zwCzP/nrREA8MQu0HtjOSHTeAcwDxcDVPt/d1iGQVygQiKx2rq1FIPh4BX7MA/G5AOEwCNZKBN3PjuJEbCLX0cZgVL90kY6SxFcW5E4EZegTq9N+ECssdszWyZ8X/DX4UYc+n+oydFx7SgR0Z4sogEzWgc684x6s9PV1GMS6DbsmguGMc9IRBUC4HM3d+w+d9jIlAxKOIi0R2A5z85HkHWRDCiQV5YIxR8PP7KWAfiblsSxyV++P6tDhQz5dBS38emLfhV9ZkKa/Q8xknKAdu04Fiw/OLfKssFCLAJf1xEH4PZpQ3ZBvMCdddcvejxLhE3hO8KnkzQ7hX8t/LfvdnwAiiz327IoCli9jwUFxQP8l9kBgLKzNvhX/Pc/zpo+JqD4M+NpBEVzlAjeaNqkYA4Hv00s8wetswJDj6/BPfQNOKlCAsN7+rIPtSMjXKy4SIH8rBGoBEPCkqGYHx8XMfx3+wUdombE9RzhfBg8ocIPDUnHAfULgr0JP1R8Vs13kovZvEq2TqfCbsC1xMkXFzsY46RxsPxuQioRWCQC/RA5AFPhUCL9cL6JW+j+Dz1rXTfuXPzaSiNEcY3XHgT3YLRvCheSeBQR5oKpdIQfLS6WQUM4mA8e9Qa/7TWPCf/FpfLwcIgU6B0zBGe6zWVklMlQ8jD2/BX0mg3pjLkUo07jcZIsWPEP0OvwgA9l78r9vBAT5jB5QcESjYDlRvpsuN01dES/lnEupfqQeVKtmtMx2+dBhJ/APmHSdaWGW+rERPyymAVKgtRMq5rYIg2g4z/P9YbFY7PN8PoyC4wuI/QH8yUokxDIu/Ofk7YVFFmllSyfhjJCxFvIXaqa99Ah+MKnF2KzBf0dBElbrAdNk8IAKbL9/txJIlK1EajT8Yzb0hTXb2pjC/7k5X55qvqzCxHT458mL4M10iDL4bsMSEuxGifDeAv5RBcBFPDsEWMq/H3vmOttlIbhFzKt8v5SBL/hquW85QBL+Xvmuk3+W/H2CfyuDccvBIrKxsP859jb0LNqvy1RweK/gYwMCiZDVKMsDdlLCr2m4vEWBD+bTTcFFCu8XfI0Dr53XjbL9yeRh/dNgo0+yo+10s1LcJW+O/ryo05IQ8ricZYt5pGg4Wr6bxo6/taP5YTprKh624AmYavn+urVgfC6F9KpSef7JYTtQ7jcInLYFyhcP8sMkW27KwudCcA/I+4f+Tgnn+a5CKCT3SVWs6ros63q1qgg9/do7vY3+L6H/0a4dqgAAg1AULYPBsjax+P//uA3TwuJAxj3RJiYf7xJ5rBVVLNzHcA8T7fkZl6iePpchSDvs8b9XBwAAAAAAqGQCc31B4/xqSwwAAAAASUVORK5CYII=";
var ProgressBar = class extends Renderable {
  /**
   * @ignore
   */
  constructor(x, y, w, h) {
    super(x, y, w, h);
    this.barHeight = h;
    this.anchorPoint.set(0, 0);
    on(LOADER_PROGRESS, this.onProgressUpdate, this);
    on(VIEWPORT_ONRESIZE, this.resize, this);
    this.anchorPoint.set(0, 0);
    this.progress = 0;
  }
  /**
   * make sure the screen is refreshed every frame
   * @ignore
   */
  onProgressUpdate(progress) {
    this.progress = ~~(progress * this.width);
    this.isDirty = true;
  }
  /**
   * draw function
   * @ignore
   */
  draw(renderer2, viewport) {
    renderer2.setColor("black");
    renderer2.fillRect(this.pos.x, viewport.centerY, renderer2.width, this.barHeight / 2);
    renderer2.setColor("#55aa00");
    renderer2.fillRect(this.pos.x, viewport.centerY, this.progress, this.barHeight / 2);
  }
  /**
   * Called by engine before deleting the object
   * @ignore
   */
  onDestroyEvent() {
    off(LOADER_PROGRESS, this.onProgressUpdate);
    off(VIEWPORT_ONRESIZE, this.resize);
  }
};
var DefaultLoadingScreen = class extends Stage {
  /**
   * call when the loader is resetted
   * @ignore
   */
  onResetEvent() {
    const barHeight = 8;
    game.world.backgroundColor.parseCSS("#202020");
    game.world.addChild(new ProgressBar(
      0,
      renderer.height / 2,
      renderer.width,
      barHeight
    ), 1);
    load({ name: "melonjs_logo", type: "image", src: img }, () => {
      game.world.addChild(
        new Sprite(
          renderer.width / 2,
          renderer.height / 2,
          {
            image: "melonjs_logo",
            framewidth: 256,
            frameheight: 256
          }
        ),
        2
      );
    });
  }
  /**
   * Called by engine before deleting the object
   * @ignore
   */
  onDestroyEvent() {
    unload({ name: "melonjs_logo", type: "image" });
  }
};
var _state = -1;
var _animFrameId = -1;
var _isPaused = false;
var _stages = {};
var _fade = {
  color: "",
  duration: 0
};
var _onSwitchComplete = null;
var _extraArgs = null;
var _pauseTime = 0;
function _startRunLoop() {
  if (_animFrameId === -1 && _state !== -1) {
    _animFrameId = globalThis.requestAnimationFrame(_renderFrame);
  }
}
function _resumeRunLoop() {
  if (_isPaused && _state !== -1) {
    _isPaused = false;
  }
}
function _pauseRunLoop() {
  _isPaused = true;
}
function _renderFrame(time) {
  emit(TICK, time);
  if (_animFrameId !== -1) {
    _animFrameId = globalThis.requestAnimationFrame(_renderFrame);
  }
}
function _stopRunLoop() {
  globalThis.cancelAnimationFrame(_animFrameId);
  _animFrameId = -1;
}
function _switchState(state2) {
  _stopRunLoop();
  if (_stages[_state]) {
    _stages[_state].stage.destroy();
  }
  if (_stages[state2]) {
    _state = state2;
    _stages[_state].stage.reset.apply(_stages[_state].stage, _extraArgs);
    _startRunLoop();
    emit(STATE_CHANGE);
    if (_onSwitchComplete) {
      _onSwitchComplete();
    }
  }
}
once(BOOT, () => {
  state.set(state.LOADING, new DefaultLoadingScreen());
  state.set(state.DEFAULT, new Stage());
  once(VIDEO_INIT, () => {
    state.change(state.DEFAULT, true);
  });
});
var state = {
  /**
   * default state ID for Loading Stage
   * @constant
   * @name LOADING
   * @memberof state
   */
  LOADING: 0,
  /**
   * default state ID for Menu Stage
   * @constant
   * @name MENU
   * @memberof state
   */
  MENU: 1,
  /**
   * default state ID for "Ready" Stage
   * @constant
   * @name READY
   * @memberof state
   */
  READY: 2,
  /**
   * default state ID for Play Stage
   * @constant
   * @name PLAY
   * @memberof state
   */
  PLAY: 3,
  /**
   * default state ID for Game Over Stage
   * @constant
   * @name GAMEOVER
   * @memberof state
   */
  GAMEOVER: 4,
  /**
   * default state ID for Game End Stage
   * @constant
   * @name GAME_END
   * @memberof state
   */
  GAME_END: 5,
  /**
   * default state ID for High Score Stage
   * @constant
   * @name SCORE
   * @memberof state
   */
  SCORE: 6,
  /**
   * default state ID for Credits Stage
   * @constant
   * @name CREDITS
   * @memberof state
   */
  CREDITS: 7,
  /**
   * default state ID for Settings Stage
   * @constant
   * @name SETTINGS
   * @memberof state
   */
  SETTINGS: 8,
  /**
   * default state ID for the default Stage
   * (the default stage is the one running as soon as melonJS is started)
   * @constant
   * @name DEFAULT
   * @memberof state
   */
  DEFAULT: 9,
  /**
   * default state ID for user defined constants<br>
   * @constant
   * @name USER
   * @memberof state
   * @example
   * let STATE_INFO = me.state.USER + 0;
   * let STATE_WARN = me.state.USER + 1;
   * let STATE_ERROR = me.state.USER + 2;
   * let STATE_CUTSCENE = me.state.USER + 3;
   */
  USER: 100,
  /**
   * Stop the current stage.
   * @name stop
   * @memberof state
   * @public
   * @param {boolean} [pauseTrack=false] - pause current track on screen stop.
   */
  stop(pauseTrack2 = false) {
    if (_state !== this.LOADING && this.isRunning()) {
      _stopRunLoop();
      if (pauseTrack2 === true) {
        pauseTrack2();
      }
      _pauseTime = globalThis.performance.now();
      emit(STATE_STOP);
    }
  },
  /**
   * pause the current stage
   * @name pause
   * @memberof state
   * @public
   * @param {boolean} [music=false] - pause current music track on screen pause
   */
  pause(music = false) {
    if (_state !== this.LOADING && !this.isPaused()) {
      _pauseRunLoop();
      if (music === true) {
        pauseTrack();
      }
      _pauseTime = globalThis.performance.now();
      emit(STATE_PAUSE);
    }
  },
  /**
   * Restart the current stage from a full stop.
   * @name restart
   * @memberof state
   * @public
   * @param {boolean} [music=false] - resume current music track on screen resume
   */
  restart(music = false) {
    if (!this.isRunning()) {
      _startRunLoop();
      if (music === true) {
        resumeTrack();
      }
      _pauseTime = globalThis.performance.now() - _pauseTime;
      emit(STATE_RESTART, _pauseTime);
    }
  },
  /**
   * resume the current stage
   * @name resume
   * @memberof state
   * @public
   * @param {boolean} [music=false] - resume current music track on screen resume
   */
  resume(music = false) {
    if (this.isPaused()) {
      _resumeRunLoop();
      if (music === true) {
        resumeTrack();
      }
      _pauseTime = globalThis.performance.now() - _pauseTime;
      emit(STATE_RESUME, _pauseTime);
    }
  },
  /**
   * return the running state of the state manager
   * @name isRunning
   * @memberof state
   * @public
   * @returns {boolean} true if a "process is running"
   */
  isRunning() {
    return _animFrameId !== -1;
  },
  /**
   * Return the pause state of the state manager
   * @name isPaused
   * @memberof state
   * @public
   * @returns {boolean} true if the game is paused
   */
  isPaused() {
    return _isPaused;
  },
  /**
   * associate the specified state with a Stage
   * @name set
   * @memberof state
   * @public
   * @param {number} state - State ID (see constants)
   * @param {Stage} stage - Instantiated Stage to associate with state ID
   * @param {boolean} [start = false] - if true the state will be changed immediately after adding it.
   * @example
   * class MenuButton extends me.GUI_Object {
   *     onClick() {
   *         // Change to the PLAY state when the button is clicked
   *         me.state.change(me.state.PLAY);
   *         return true;
   *     }
   * };
   *
   * class MenuScreen extends me.Stage {
   *     onResetEvent() {
   *         // Load background image
   *         me.game.world.addChild(
   *             new me.ImageLayer(0, 0, {
   *                 image : "bg",
   *                 z: 0 // z-index
   *             }
   *         );
   *
   *         // Add a button
   *         me.game.world.addChild(
   *             new MenuButton(350, 200, { "image" : "start" }),
   *             1 // z-index
   *         );
   *
   *         // Play music
   *         me.audio.playTrack("menu");
   *     }
   *
   *     onDestroyEvent() {
   *         // Stop music
   *         me.audio.stopTrack();
   *     }
   * };
   *
   * me.state.set(me.state.MENU, new MenuScreen());
   */
  set(state2, stage, start = false) {
    if (!(stage instanceof Stage)) {
      throw new Error(stage + " is not an instance of me.Stage");
    }
    _stages[state2] = {};
    _stages[state2].stage = stage;
    _stages[state2].transition = true;
    if (start === true) {
      this.change(state2);
    }
  },
  /**
   * returns the stage associated with the specified state
   * (or the current one if none is specified)
   * @name set
   * @memberof state
   * @public
   * @param {number} [state] - State ID (see constants)
   * @returns {Stage}
   */
  get(state2 = _state) {
    if (typeof _stages[state2] !== "undefined") {
      return _stages[state2].stage;
    } else {
      return void 0;
    }
  },
  /**
   * return a reference to the current stage<br>
   * useful to call a object specific method
   * @name current
   * @memberof state
   * @public
   * @returns {Stage}
   */
  current() {
    return this.get();
  },
  /**
   * specify a global transition effect
   * @name transition
   * @memberof state
   * @public
   * @param {string} effect - (only "fade" is supported for now)
   * @param {Color|string} color - a CSS color value
   * @param {number} [duration=1000] - expressed in milliseconds
   */
  transition(effect, color, duration) {
    if (effect === "fade") {
      _fade.color = color;
      _fade.duration = duration;
    }
  },
  /**
   * enable/disable the transition to a particular state (by default enabled for all)
   * @name setTransition
   * @memberof state
   * @public
   * @param {number} state - State ID (see constants)
   * @param {boolean} enable
   */
  setTransition(state2, enable2) {
    _stages[state2].transition = enable2;
  },
  /**
   * change the game/app state
   * @name change
   * @memberof state
   * @public
   * @param {number} state - State ID (see constants)
   * @param {boolean} forceChange - if true the state will be changed immediately
   * @param {...*} [args] - extra arguments to be passed to the reset functions
   * @example
   * // The onResetEvent method on the play screen will receive two args:
   * // "level_1" and the number 3
   * me.state.change(me.state.PLAY, "level_1", 3);
   */
  change(state2, forceChange) {
    if (typeof _stages[state2] === "undefined") {
      throw new Error("Undefined Stage for state '" + state2 + "'");
    }
    if (!this.isCurrent(state2)) {
      _extraArgs = null;
      if (arguments.length > 1) {
        _extraArgs = Array.prototype.slice.call(arguments, 1);
      }
      if (_fade.duration && _stages[state2].transition) {
        _onSwitchComplete = () => {
          game.viewport.fadeOut(_fade.color, _fade.duration);
        };
        game.viewport.fadeIn(
          _fade.color,
          _fade.duration,
          function() {
            defer(_switchState, this, state2);
          }
        );
      } else {
        if (forceChange === true) {
          _switchState(state2);
        } else {
          defer(_switchState, this, state2);
        }
      }
    }
  },
  /**
   * return true if the specified state is the current one
   * @name isCurrent
   * @memberof state
   * @public
   * @param {number} state - State ID (see constants)
   * @returns {boolean} true if the specified state is the current one
   */
  isCurrent(state2) {
    return _state === state2;
  }
};
var Timer = class {
  constructor() {
    this.tick = 1;
    this.fps = 0;
    this.maxfps = 60;
    this.interpolation = false;
    this.framecount = 0;
    this.framedelta = 0;
    this.last = 0;
    this.now = 0;
    this.delta = 0;
    this.step = 0;
    this.minstep = 0;
    this.timers = [];
    this.timerId = 0;
    once(BOOT, () => {
      this.reset();
      this.now = this.last = 0;
      on(GAME_BEFORE_UPDATE, (time) => this.update(time));
    });
    on(STATE_RESUME, () => {
      this.reset();
    });
    on(STATE_RESTART, () => {
      this.reset();
    });
    on(STATE_CHANGE, () => {
      this.reset();
    });
  }
  /**
   * reset time (e.g. usefull in case of pause)
   * @ignore
   */
  reset() {
    this.last = this.now = globalThis.performance.now();
    this.delta = 0;
    this.framedelta = 0;
    this.framecount = 0;
    this.step = Math.ceil(1e3 / this.maxfps);
    this.minstep = 1e3 / this.maxfps * 1.25;
  }
  /**
   * Calls a function once after a specified delay. See me.timer.setInterval to repeativly call a function.
   * @param {Function} fn - the function you want to execute after delay milliseconds.
   * @param {number} delay - the number of milliseconds (thousandths of a second) that the function call should be delayed by.
   * @param {boolean} [pauseable=true] - respects the pause state of the engine.
   * @param {...*} args - optional parameters which are passed through to the function specified by fn once the timer expires.
   * @returns {number} a positive integer value which identifies the timer created by the call to setTimeout(), which can be used later with me.timer.clearTimeout().
   * @example
   * // set a timer to call "myFunction" after 1000ms
   * me.timer.setTimeout(myFunction, 1000);
   * // set a timer to call "myFunction" after 1000ms (respecting the pause state) and passing param1 and param2
   * me.timer.setTimeout(myFunction, 1000, true, param1, param2);
   */
  setTimeout(fn, delay, pauseable, ...args) {
    this.timers.push({
      fn,
      delay,
      elapsed: 0,
      repeat: false,
      timerId: ++this.timerId,
      pauseable: pauseable === true || true,
      args
    });
    return this.timerId;
  }
  /**
   * Calls a function continously at the specified interval.  See setTimeout to call function a single time.
   * @param {Function} fn - the function to execute
   * @param {number} delay - the number of milliseconds (thousandths of a second) on how often to execute the function
   * @param {boolean} [pauseable=true] - respects the pause state of the engine.
   * @param {...*} args - optional parameters which are passed through to the function specified by fn once the timer expires.
   * @returns {number} a numeric, non-zero value which identifies the timer created by the call to setInterval(), which can be used later with me.timer.clearInterval().
   * @example
   * // set a timer to call "myFunction" every 1000ms
   * me.timer.setInterval(myFunction, 1000);
   * // set a timer to call "myFunction" every 1000ms (respecting the pause state) and passing param1 and param2
   * me.timer.setInterval(myFunction, 1000, true, param1, param2);
   */
  setInterval(fn, delay, pauseable, ...args) {
    this.timers.push({
      fn,
      delay,
      elapsed: 0,
      repeat: true,
      timerId: ++this.timerId,
      pauseable: pauseable === true || true,
      args
    });
    return this.timerId;
  }
  /**
   * Cancels a timeout previously established by calling setTimeout().
   * @param {number} timeoutID - ID of the timeout to be cancelled
   */
  clearTimeout(timeoutID) {
    if (timeoutID > 0) {
      defer(this.clearTimer.bind(this), this, timeoutID);
    }
  }
  /**
   * cancels the timed, repeating action which was previously established by a call to setInterval().
   * @param {number} intervalID - ID of the interval to be cleared
   */
  clearInterval(intervalID) {
    if (intervalID > 0) {
      defer(this.clearTimer.bind(this), this, intervalID);
    }
  }
  /**
   * Return the current timestamp in milliseconds <br>
   * since the game has started or since linux epoch (based on browser support for High Resolution Timer)
   * @returns {number}
   */
  getTime() {
    return this.now;
  }
  /**
   * Return elapsed time in milliseconds since the last update
   * @returns {number}
   */
  getDelta() {
    return this.delta;
  }
  /**
   * compute the actual frame time and fps rate
   * @ignore
   */
  countFPS() {
    this.framecount++;
    this.framedelta += this.delta;
    if (this.framecount % 10 === 0) {
      this.fps = clamp(Math.round(1e3 * this.framecount / this.framedelta), 0, this.maxfps);
      this.framedelta = 0;
      this.framecount = 0;
    }
  }
  /**
   * update
   * @ignore
   */
  update(time) {
    this.last = this.now;
    this.now = time;
    this.delta = this.now - this.last;
    if (this.delta < 0) {
      this.delta = 0;
    }
    this.tick = this.delta > this.minstep && this.interpolation ? this.delta / this.step : 1;
    this.updateTimers();
  }
  /**
   * clear Timers
   * @ignore
   */
  clearTimer(timerId2) {
    for (let i = 0, len = this.timers.length; i < len; i++) {
      if (this.timers[i].timerId === timerId2) {
        this.timers.splice(i, 1);
        break;
      }
    }
  }
  /**
   * update timers
   * @ignore
   */
  updateTimers() {
    for (let i = 0, len = this.timers.length; i < len; i++) {
      let _timer = this.timers[i];
      if (!(_timer.pauseable && state.isPaused())) {
        _timer.elapsed += this.delta;
      }
      if (_timer.elapsed >= _timer.delay) {
        _timer.fn.apply(null, _timer.args);
        if (_timer.repeat === true) {
          _timer.elapsed -= _timer.delay;
        } else {
          this.clearTimeout(_timer.timerId);
        }
      }
    }
  }
};
var timer = new Timer();
var Body = class {
  /**
   * @param {Renderable|Container|Entity|Sprite|NineSliceSprite} ancestor - the parent object this body is attached to
   * @param {Rect|Rect[]|Polygon|Polygon[]|Line|Line[]|Ellipse|Ellipse[]|Point|Point[]|Bounds|Bounds[]|object} [shapes] - a initial shape, list of shapes, or JSON object defining the body
   * @param {Function} [onBodyUpdate] - callback for when the body is updated (e.g. add/remove shapes)
   */
  constructor(ancestor, shapes, onBodyUpdate) {
    this.ancestor = ancestor;
    if (typeof this.bounds === "undefined") {
      this.bounds = pool.pull("Bounds");
    }
    if (typeof this.shapes === "undefined") {
      this.shapes = [];
    }
    this.collisionMask = collision.types.ALL_OBJECT;
    this.collisionType = collision.types.ENEMY_OBJECT;
    if (typeof this.vel === "undefined") {
      this.vel = pool.pull("Vector2d");
    }
    this.vel.set(0, 0);
    if (typeof this.force === "undefined") {
      this.force = pool.pull("Vector2d");
    }
    this.force.set(0, 0);
    if (typeof this.friction === "undefined") {
      this.friction = pool.pull("Vector2d");
    }
    this.friction.set(0, 0);
    this.bounce = 0;
    this.mass = 1;
    if (typeof this.maxVel === "undefined") {
      this.maxVel = pool.pull("Vector2d");
    }
    this.maxVel.set(490, 490);
    this.isStatic = false;
    this.gravityScale = 1;
    this.ignoreGravity = false;
    this.falling = false;
    this.jumping = false;
    if (typeof onBodyUpdate === "function") {
      this.onBodyUpdate = onBodyUpdate;
    }
    this.bounds.clear();
    if (typeof shapes !== "undefined") {
      if (Array.isArray(shapes)) {
        for (let s = 0; s < shapes.length; s++) {
          this.addShape(shapes[s]);
        }
      } else {
        this.addShape(shapes);
      }
    }
    this.ancestor.isKinematic = false;
  }
  /**
   * set the body as a static body
   * static body do not move automatically and do not check againt collision with others
   * @param {boolean} [isStatic=true]
   */
  setStatic(isStatic = true) {
    this.isStatic = isStatic === true;
  }
  /**
   * add a collision shape to this body <br>
   * (note: me.Rect objects will be converted to me.Polygon before being added)
   * @param {Rect|Polygon|Line|Ellipse|Point|Point[]|Bounds|object} shape - a shape or JSON object
   * @returns {number} the shape array length
   * @example
   * // add a rectangle shape
   * this.body.addShape(new me.Rect(0, 0, image.width, image.height));
   * // add a shape from a JSON object
   * this.body.addShape(me.loader.getJSON("shapesdef").banana);
   */
  addShape(shape) {
    if (shape instanceof Rect || shape instanceof Bounds) {
      let poly = shape.toPolygon();
      this.shapes.push(poly);
      this.bounds.add(poly.points);
      this.bounds.translate(poly.pos);
    } else if (shape instanceof Ellipse) {
      if (!this.shapes.includes(shape)) {
        this.shapes.push(shape);
      }
      this.bounds.addBounds(shape.getBounds());
      this.bounds.translate(
        shape.getBounds().x,
        shape.getBounds().y
      );
    } else if (shape instanceof Polygon) {
      if (!this.shapes.includes(shape)) {
        this.shapes.push(shape);
      }
      this.bounds.add(shape.points);
      this.bounds.translate(shape.pos);
    } else if (shape instanceof Point) {
      if (!this.shapes.includes(shape)) {
        this.shapes.push(shape);
      }
      this.bounds.addPoint(shape);
    } else {
      this.fromJSON(shape);
    }
    if (typeof this.onBodyUpdate === "function") {
      this.onBodyUpdate(this);
    }
    return this.shapes.length;
  }
  /**
   * set the body vertices to the given one
   * @param {Vector2d[]} vertices - an array of me.Vector2d points defining a convex hull
   * @param {number} [index=0] - the shape object for which to set the vertices
   * @param {boolean} [clear=true] - either to reset the body definition before adding the new vertices
   */
  setVertices(vertices, index2 = 0, clear = true) {
    let polygon = this.getShape(index2);
    if (polygon instanceof Polygon) {
      polygon.setShape(0, 0, vertices);
    } else {
      this.shapes[index2] = pool.pull("Polygon", 0, 0, vertices);
    }
    this.bounds.add(this.shapes[index2].points, clear);
    if (typeof this.onBodyUpdate === "function") {
      this.onBodyUpdate(this);
    }
  }
  /**
   * add the given vertices to the body shape
   * @param {Vector2d[]} vertices - an array of me.Vector2d points defining a convex hull
   * @param {number} [index=0] - the shape object for which to set the vertices
   */
  addVertices(vertices, index2 = 0) {
    this.setVertices(vertices, index2, false);
  }
  /**
   * add collision mesh based on a JSON object
   * (this will also apply any physic properties defined in the given JSON file)
   * @param {object} json - a JSON object as exported from a Physics Editor tool
   * @param {string} [id] - an optional shape identifier within the given the json object
   * @see https://www.codeandweb.com/physicseditor
   * @returns {number} how many shapes were added to the body
   * @example
   * // define the body based on the banana shape
   * this.body.fromJSON(me.loader.getJSON("shapesdef").banana);
   * // or ...
   * this.body.fromJSON(me.loader.getJSON("shapesdef"), "banana");
   */
  fromJSON(json, id2) {
    let data2 = json;
    if (typeof id2 !== "undefined") {
      data2 = json[id2];
    }
    if (typeof data2 === "undefined") {
      throw new Error("Identifier (" + id2 + ") undefined for the given JSON object)");
    }
    if (data2.length) {
      for (let i = 0; i < data2.length; i++) {
        this.addVertices(data2[i].shape, i);
      }
      this.mass = data2[0].density || 0;
      this.friction.set(data2[0].friction || 0, data2[0].friction || 0);
      this.bounce = data2[0].bounce || 0;
    }
    return data2.length;
  }
  /**
   * return the collision shape at the given index
   * @param {number} [index=0] - the shape object at the specified index
   * @returns {Polygon|Line|Ellipse} shape a shape object if defined
   */
  getShape(index2) {
    return this.shapes[index2 || 0];
  }
  /**
   * returns the AABB bounding box for this body
   * @returns {Bounds} bounding box Rectangle object
   */
  getBounds() {
    return this.bounds;
  }
  /**
   * remove the specified shape from the body shape list
   * @param {Polygon|Line|Ellipse} shape - a shape object
   * @returns {number} the shape array length
   */
  removeShape(shape) {
    this.bounds.clear();
    remove(this.shapes, shape);
    for (let s = 0; s < this.shapes.length; s++) {
      this.addShape(this.shapes[s]);
    }
    return this.shapes.length;
  }
  /**
   * remove the shape at the given index from the body shape list
   * @param {number} index - the shape object at the specified index
   * @returns {number} the shape array length
   */
  removeShapeAt(index2) {
    return this.removeShape(this.getShape(index2));
  }
  /**
   * By default all physic bodies are able to collide with all other bodies, <br>
   * but it's also possible to specify 'collision filters' to provide a finer <br>
   * control over which body can collide with each other.
   * @see collision.types
   * @param {number} [bitmask = collision.types.ALL_OBJECT] - the collision mask
   * @example
   * // filter collision detection with collision shapes, enemies and collectables
   * body.setCollisionMask(me.collision.types.WORLD_SHAPE | me.collision.types.ENEMY_OBJECT | me.collision.types.COLLECTABLE_OBJECT);
   * ...
   * // disable collision detection with all other objects
   * body.setCollisionMask(me.collision.types.NO_OBJECT);
   */
  setCollisionMask(bitmask = collision.types.ALL_OBJECT) {
    this.collisionMask = bitmask;
  }
  /**
   * define the collision type of the body for collision filtering
   * @see collision.types
   * @param {number} type - the collision type
   * @example
   * // set the body collision type
   * body.collisionType = me.collision.types.PLAYER_OBJECT;
   */
  setCollisionType(type) {
    if (typeof type !== "undefined") {
      if (typeof collision.types[type] !== "undefined") {
        this.collisionType = collision.types[type];
      } else {
        throw new Error("Invalid value for the collisionType property");
      }
    }
  }
  /**
   * the built-in function to solve the collision response
   * @param {object} response - the collision response object (see {@link ResponseObject})
   */
  respondToCollision(response) {
    let overlap = response.overlapV;
    this.ancestor.pos.sub(overlap);
    if (overlap.x !== 0) {
      this.vel.x = ~~(0.5 + this.vel.x - overlap.x) || 0;
      if (this.bounce > 0) {
        this.vel.x *= -this.bounce;
      }
    }
    if (overlap.y !== 0) {
      this.vel.y = ~~(0.5 + this.vel.y - overlap.y) || 0;
      if (this.bounce > 0) {
        this.vel.y *= -this.bounce;
      }
      if (!this.ignoreGravity) {
        let dir = this.falling === true ? 1 : this.jumping === true ? -1 : 0;
        this.falling = overlap.y >= dir;
        this.jumping = overlap.y <= -dir;
      }
    }
  }
  /**
   * The forEach() method executes a provided function once per body shape element. <br>
   * the callback function is invoked with three arguments: <br>
   *    - The current element being processed in the array <br>
   *    - The index of element in the array. <br>
   *    - The array forEach() was called upon. <br>
   * @param {Function} callback - fnction to execute on each element
   * @param {object} [thisArg] - value to use as this(i.e reference Object) when executing callback.
   * @example
   * // iterate through all shapes of the physic body
   * mySprite.body.forEach((shape) => {
   *    shape.doSomething();
   * });
   * mySprite.body.forEach((shape, index) => { ... });
   * mySprite.body.forEach((shape, index, array) => { ... });
   * mySprite.body.forEach((shape, index, array) => { ... }, thisArg);
   */
  forEach(callback, thisArg) {
    let context = this, i = 0;
    let shapes = this.shapes;
    let len = shapes.length;
    if (typeof callback !== "function") {
      throw new Error(callback + " is not a function");
    }
    if (arguments.length > 1) {
      context = thisArg;
    }
    while (i < len) {
      callback.call(context, shapes[i], i, shapes);
      i++;
    }
  }
  /**
   * Returns true if the any of the shape composing the body contains the given point.
   * @param {number|Vector2d} x -  x coordinate or a vector point to check
   * @param {number} [y] -  y coordinate
   * @returns {boolean} true if contains
   * @example
   * if (mySprite.body.contains(10, 10)) {
   *   // do something
   * }
   * // or
   * if (mySprite.body.contains(myVector2d)) {
   *   // do something
   * }
   */
  contains(...args) {
    let _x, _y;
    if (args.length === 2) {
      [_x, _y] = args;
    } else {
      [_x, _y] = [args[0].x, args[0].y];
    }
    if (this.getBounds().contains(_x, _y)) {
      for (let i = this.shapes.length, shape; i--, shape = this.shapes[i]; ) {
        if (shape.contains(_x, _y)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Rotate this body (counter-clockwise) by the specified angle (in radians).
   * Unless specified the body will be rotated around its center point
   * @param {number} angle - The angle to rotate (in radians)
   * @param {Vector2d|ObservableVector2d} [v=Body.getBounds().center] - an optional point to rotate around
   * @returns {Body} Reference to this object for method chaining
   */
  rotate(angle, v = this.getBounds().center) {
    if (angle !== 0) {
      this.bounds.clear();
      this.forEach((shape) => {
        shape.rotate(angle, v);
        this.bounds.addBounds(shape.getBounds());
      });
    }
    return this;
  }
  /**
   * cap the body velocity (body.maxVel property) to the specified value<br>
   * @param {number} x - max velocity on x axis
   * @param {number} y - max velocity on y axis
   */
  setMaxVelocity(x, y) {
    this.maxVel.x = x;
    this.maxVel.y = y;
  }
  /**
   * set the body default friction
   * @param {number} x - horizontal friction
   * @param {number} y - vertical friction
   */
  setFriction(x = 0, y = 0) {
    this.friction.x = x;
    this.friction.y = y;
  }
  /**
   * Updates the parent's position as well as computes the new body's velocity based
   * on the values of force/friction.  Velocity chages are proportional to the
   * me.timer.tick value (which can be used to scale velocities).  The approach to moving the
   * parent renderable is to compute new values of the Body.vel property then add them to
   * the parent.pos value thus changing the postion the amount of Body.vel each time the
   * update call is made. <br>
   * Updates to Body.vel are bounded by maxVel (which defaults to viewport size if not set) <br>
   * At this time a call to Body.Update does not call the onBodyUpdate callback that is listed in the constructor arguments.
   * @protected
   * @param {number} dt - time since the last update in milliseconds.
   * @returns {boolean} true if resulting velocity is different than 0
   */
  update(dt) {
    let deltaTime = (
      /* dt * */
      timer.tick
    );
    if (this.force.x !== 0) {
      this.vel.x += this.force.x * deltaTime;
    }
    if (this.force.y !== 0) {
      this.vel.y += this.force.y * deltaTime;
    }
    if (this.friction.x > 0) {
      let fx = this.friction.x * deltaTime, nx = this.vel.x + fx, x = this.vel.x - fx;
      this.vel.x = nx < 0 ? nx : x > 0 ? x : 0;
    }
    if (this.friction.y > 0) {
      let fy = this.friction.y * deltaTime, ny = this.vel.y + fy, y = this.vel.y - fy;
      this.vel.y = ny < 0 ? ny : y > 0 ? y : 0;
    }
    if (this.vel.y !== 0) {
      this.vel.y = clamp(this.vel.y, -this.maxVel.y, this.maxVel.y);
    }
    if (this.vel.x !== 0) {
      this.vel.x = clamp(this.vel.x, -this.maxVel.x, this.maxVel.x);
    }
    this.falling = this.vel.y * Math.sign(this.force.y) > 0;
    this.jumping = this.falling ? false : this.jumping;
    this.ancestor.pos.add(this.vel);
    return this.vel.x !== 0 || this.vel.y !== 0;
  }
  /**
   * Destroy function<br>
   * @ignore
   */
  destroy() {
    pool.push(this.bounds);
    pool.push(this.vel);
    pool.push(this.force);
    pool.push(this.friction);
    pool.push(this.maxVel);
    this.shapes.forEach((shape) => {
      pool.push(shape, false);
    });
    this.onBodyUpdate = void 0;
    this.ancestor = void 0;
    this.bounds = void 0;
    this.vel = void 0;
    this.force = void 0;
    this.friction = void 0;
    this.maxVel = void 0;
    this.shapes.length = 0;
    this.setStatic(false);
  }
};
var Easing = {
  Linear: {
    /** @ignore */
    None: function(k) {
      return k;
    }
  },
  Quadratic: {
    /** @ignore */
    In: function(k) {
      return k * k;
    },
    /** @ignore */
    Out: function(k) {
      return k * (2 - k);
    },
    /** @ignore */
    InOut: function(k) {
      if ((k *= 2) < 1) return 0.5 * k * k;
      return -0.5 * (--k * (k - 2) - 1);
    }
  },
  Cubic: {
    /** @ignore */
    In: function(k) {
      return k * k * k;
    },
    /** @ignore */
    Out: function(k) {
      return --k * k * k + 1;
    },
    /** @ignore */
    InOut: function(k) {
      if ((k *= 2) < 1) return 0.5 * k * k * k;
      return 0.5 * ((k -= 2) * k * k + 2);
    }
  },
  Quartic: {
    /** @ignore */
    In: function(k) {
      return k * k * k * k;
    },
    /** @ignore */
    Out: function(k) {
      return 1 - --k * k * k * k;
    },
    /** @ignore */
    InOut: function(k) {
      if ((k *= 2) < 1) return 0.5 * k * k * k * k;
      return -0.5 * ((k -= 2) * k * k * k - 2);
    }
  },
  Quintic: {
    /** @ignore */
    In: function(k) {
      return k * k * k * k * k;
    },
    /** @ignore */
    Out: function(k) {
      return --k * k * k * k * k + 1;
    },
    /** @ignore */
    InOut: function(k) {
      if ((k *= 2) < 1) return 0.5 * k * k * k * k * k;
      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    }
  },
  Sinusoidal: {
    /** @ignore */
    In: function(k) {
      return 1 - Math.cos(k * Math.PI / 2);
    },
    /** @ignore */
    Out: function(k) {
      return Math.sin(k * Math.PI / 2);
    },
    /** @ignore */
    InOut: function(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }
  },
  Exponential: {
    /** @ignore */
    In: function(k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    /** @ignore */
    Out: function(k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    /** @ignore */
    InOut: function(k) {
      if (k === 0) return 0;
      if (k === 1) return 1;
      if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1);
      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    }
  },
  Circular: {
    /** @ignore */
    In: function(k) {
      return 1 - Math.sqrt(1 - k * k);
    },
    /** @ignore */
    Out: function(k) {
      return Math.sqrt(1 - --k * k);
    },
    /** @ignore */
    InOut: function(k) {
      if ((k *= 2) < 1) return -0.5 * (Math.sqrt(1 - k * k) - 1);
      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    }
  },
  Elastic: {
    /** @ignore */
    In: function(k) {
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
    },
    /** @ignore */
    Out: function(k) {
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
    },
    /** @ignore */
    InOut: function(k) {
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      k *= 2;
      if (k < 1) {
        return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
    }
  },
  Back: {
    /** @ignore */
    In: function(k) {
      const s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },
    /** @ignore */
    Out: function(k) {
      const s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },
    /** @ignore */
    InOut: function(k) {
      const s = 1.70158 * 1.525;
      if ((k *= 2) < 1) return 0.5 * (k * k * ((s + 1) * k - s));
      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    }
  },
  Bounce: {
    /** @ignore */
    In: function(k) {
      return 1 - Easing.Bounce.Out(1 - k);
    },
    /** @ignore */
    Out: function(k) {
      if (k < 1 / 2.75) {
        return 7.5625 * k * k;
      } else if (k < 2 / 2.75) {
        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
      } else if (k < 2.5 / 2.75) {
        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
      } else {
        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
      }
    },
    /** @ignore */
    InOut: function(k) {
      if (k < 0.5) return Easing.Bounce.In(k * 2) * 0.5;
      return Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
    }
  }
};
var Interpolation = {
  /** @ignore */
  Linear: function(v, k) {
    let m = v.length - 1, f2 = m * k, i = Math.floor(f2), fn = Interpolation.Utils.Linear;
    if (k < 0) return fn(v[0], v[1], f2);
    if (k > 1) return fn(v[m], v[m - 1], m - f2);
    return fn(v[i], v[i + 1 > m ? m : i + 1], f2 - i);
  },
  /** @ignore */
  Bezier: function(v, k) {
    let b = 0, n = v.length - 1, pw = Math.pow, bn = Interpolation.Utils.Bernstein, i;
    for (i = 0; i <= n; i++) {
      b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
    }
    return b;
  },
  /** @ignore */
  CatmullRom: function(v, k) {
    let m = v.length - 1, f2 = m * k, i = Math.floor(f2), fn = Interpolation.Utils.CatmullRom;
    if (v[0] === v[m]) {
      if (k < 0) i = Math.floor(f2 = m * (1 + k));
      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f2 - i);
    } else {
      if (k < 0) return v[0] - (fn(v[0], v[0], v[1], v[1], -f2) - v[0]);
      if (k > 1) return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f2 - m) - v[m]);
      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f2 - i);
    }
  },
  Utils: {
    /** @ignore */
    Linear: function(p0, p1, t2) {
      return (p1 - p0) * t2 + p0;
    },
    /** @ignore */
    Bernstein: function(n, i) {
      let fc = Interpolation.Utils.Factorial;
      return fc(n) / fc(i) / fc(n - i);
    },
    /* @ignore */
    Factorial: /* @__PURE__ */ function() {
      let a = [1];
      return function(n) {
        let s = 1, i;
        if (a[n]) return a[n];
        for (i = n; i > 1; i--) s *= i;
        a[n] = s;
        return s;
      };
    }(),
    /** @ignore */
    CatmullRom: function(p0, p1, p2, p3, t2) {
      let v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t22 = t2 * t2, t3 = t2 * t22;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
    }
  }
};
var Tween = class {
  /**
   * @param {object} object - object on which to apply the tween
   * @example
   * // add a tween to change the object pos.x and pos.y variable to 200 in 3 seconds
   * tween = new me.Tween(myObject.pos).to({
   *       x: 200,
   *       y: 200,
   *    }, {
   *       duration: 3000,
   *       easing: me.Tween.Easing.Bounce.Out,
   *       autoStart : true
   * }).onComplete(myFunc);
   */
  constructor(object) {
    this.setProperties(object);
  }
  /**
   * reset the tween object to default value
   * @ignore
   */
  onResetEvent(object) {
    this.setProperties(object);
  }
  /**
   * @ignore
   */
  setProperties(object) {
    this._object = object;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1e3;
    this._repeat = 0;
    this._yoyo = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = null;
    this._easingFunction = Easing.Linear.None;
    this._interpolationFunction = Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallback = null;
    this._onStartCallbackFired = false;
    this._onUpdateCallback = null;
    this._onCompleteCallback = null;
    this._tweenTimeTracker = game.lastUpdate;
    this.isPersistent = false;
    this.updateWhenPaused = false;
    this.isRenderable = false;
    for (let field in object) {
      if (typeof object !== "object") {
        this._valuesStart[field] = parseFloat(object[field]);
      }
    }
  }
  /**
   * @ignore
   */
  _resumeCallback(elapsed) {
    if (this._startTime) {
      this._startTime += elapsed;
    }
  }
  /**
   * subscribe to the resume event when added
   * @ignore
   */
  onActivateEvent() {
    on(STATE_RESUME, this._resumeCallback, this);
  }
  /**
   * Unsubscribe when tween is removed
   * @ignore
   */
  onDeactivateEvent() {
    off(STATE_RESUME, this._resumeCallback);
  }
  /**
   * object properties to be updated and duration
   * @name to
   * @memberof Tween
   * @public
   * @param {object} properties - hash of properties
   * @param {object|number} [options] - object of tween properties, or a duration if a numeric value is passed
   * @param {number} [options.duration] - tween duration
   * @param {Tween.Easing} [options.easing] - easing function
   * @param {number} [options.delay] - delay amount expressed in milliseconds
   * @param {boolean} [options.yoyo] - allows the tween to bounce back to their original value when finished. To be used together with repeat to create endless loops.
   * @param {number} [options.repeat] - amount of times the tween should be repeated
   * @param {Tween.Interpolation} [options.interpolation] - interpolation function
   * @param {boolean} [options.autoStart] - allow this tween to start automatically. Otherwise call me.Tween.start().
   * @returns {Tween} this instance for object chaining
   */
  to(properties, options) {
    this._valuesEnd = properties;
    if (typeof options !== "undefined") {
      if (typeof options === "number") {
        this._duration = options;
      } else if (typeof options === "object") {
        if (options.duration) {
          this._duration = options.duration;
        }
        if (options.yoyo) {
          this.yoyo(options.yoyo);
        }
        if (options.easing) {
          this.easing(options.easing);
        }
        if (options.repeat) {
          this.repeat(options.repeat);
        }
        if (options.delay) {
          this.delay(options.delay);
        }
        if (options.interpolation) {
          this.interpolation(options.interpolation);
        }
        if (options.autoStart) {
          this.start();
        }
      }
    }
    return this;
  }
  /**
   * start the tween
   * @name start
   * @memberof Tween
   * @public
   * @param {number} [time] - the current time when the tween was started
   * @returns {Tween} this instance for object chaining
   */
  start(time = timer.getTime()) {
    this._onStartCallbackFired = false;
    game.world.addChild(this);
    this._startTime = time + this._delayTime;
    for (let property in this._valuesEnd) {
      if (this._valuesEnd[property] instanceof Array) {
        if (this._valuesEnd[property].length === 0) {
          continue;
        }
        this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
      }
      this._valuesStart[property] = this._object[property];
      if (this._valuesStart[property] instanceof Array === false) {
        this._valuesStart[property] *= 1;
      }
      this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
    }
    return this;
  }
  /**
   * stop the tween
   * @name stop
   * @memberof Tween
   * @public
   * @returns {Tween} this instance for object chaining
   */
  stop() {
    game.world.removeChildNow(this);
    return this;
  }
  /**
   * delay the tween
   * @name delay
   * @memberof Tween
   * @public
   * @param {number} amount - delay amount expressed in milliseconds
   * @returns {Tween} this instance for object chaining
   */
  delay(amount) {
    this._delayTime = amount;
    return this;
  }
  /**
   * Repeat the tween
   * @name repeat
   * @memberof Tween
   * @public
   * @param {number} times - amount of times the tween should be repeated
   * @returns {Tween} this instance for object chaining
   */
  repeat(times) {
    this._repeat = times;
    return this;
  }
  /**
   * Allows the tween to bounce back to their original value when finished.
   * To be used together with repeat to create endless loops.
   * @name yoyo
   * @memberof Tween
   * @public
   * @see Tween#repeat
   * @param {boolean} yoyo
   * @returns {Tween} this instance for object chaining
   */
  yoyo(yoyo) {
    this._yoyo = yoyo;
    return this;
  }
  /**
   * set the easing function
   * @name easing
   * @memberof Tween
   * @public
   * @param {Tween.Easing} easing - easing function
   * @returns {Tween} this instance for object chaining
   */
  easing(easing) {
    if (typeof easing !== "function") {
      throw new Error("invalid easing function for me.Tween.easing()");
    }
    this._easingFunction = easing;
    return this;
  }
  /**
   * set the interpolation function
   * @name interpolation
   * @memberof Tween
   * @public
   * @param {Tween.Interpolation} interpolation - interpolation function
   * @returns {Tween} this instance for object chaining
   */
  interpolation(interpolation) {
    this._interpolationFunction = interpolation;
    return this;
  }
  /**
   * chain the tween
   * @name chain
   * @memberof Tween
   * @public
   * @param {...Tween} chainedTween - Tween(s) to be chained
   * @returns {Tween} this instance for object chaining
   */
  chain() {
    this._chainedTweens = arguments;
    return this;
  }
  /**
   * onStart callback
   * @name onStart
   * @memberof Tween
   * @public
   * @param {Function} onStartCallback - callback
   * @returns {Tween} this instance for object chaining
   */
  onStart(onStartCallback) {
    this._onStartCallback = onStartCallback;
    return this;
  }
  /**
   * onUpdate callback
   * @name onUpdate
   * @memberof Tween
   * @public
   * @param {Function} onUpdateCallback - callback
   * @returns {Tween} this instance for object chaining
   */
  onUpdate(onUpdateCallback) {
    this._onUpdateCallback = onUpdateCallback;
    return this;
  }
  /**
   * onComplete callback
   * @name onComplete
   * @memberof Tween
   * @public
   * @param {Function} onCompleteCallback - callback
   * @returns {Tween} this instance for object chaining
   */
  onComplete(onCompleteCallback) {
    this._onCompleteCallback = onCompleteCallback;
    return this;
  }
  /** @ignore */
  update(dt) {
    this._tweenTimeTracker = game.lastUpdate > this._tweenTimeTracker ? game.lastUpdate : this._tweenTimeTracker + dt;
    let time = this._tweenTimeTracker;
    let property;
    if (time < this._startTime) {
      return true;
    }
    if (this._onStartCallbackFired === false) {
      if (this._onStartCallback !== null) {
        this._onStartCallback.call(this._object);
      }
      this._onStartCallbackFired = true;
    }
    let elapsed = (time - this._startTime) / this._duration;
    elapsed = elapsed > 1 ? 1 : elapsed;
    let value = this._easingFunction(elapsed);
    for (property in this._valuesEnd) {
      let start = this._valuesStart[property] || 0;
      let end = this._valuesEnd[property];
      if (end instanceof Array) {
        this._object[property] = this._interpolationFunction(end, value);
      } else {
        if (typeof end === "string") {
          end = start + parseFloat(end);
        }
        if (typeof end === "number") {
          this._object[property] = start + (end - start) * value;
        }
      }
    }
    if (this._onUpdateCallback !== null) {
      this._onUpdateCallback.call(this._object, value);
    }
    if (elapsed === 1) {
      if (this._repeat > 0) {
        if (isFinite(this._repeat)) {
          this._repeat--;
        }
        for (property in this._valuesStartRepeat) {
          if (typeof this._valuesEnd[property] === "string") {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
          }
          if (this._yoyo) {
            let tmp = this._valuesStartRepeat[property];
            this._valuesStartRepeat[property] = this._valuesEnd[property];
            this._valuesEnd[property] = tmp;
          }
          this._valuesStart[property] = this._valuesStartRepeat[property];
        }
        if (this._yoyo) {
          this._reversed = !this._reversed;
        }
        this._startTime = time + this._delayTime;
        return true;
      } else {
        game.world.removeChildNow(this);
        if (this._onCompleteCallback !== null) {
          this._onCompleteCallback.call(this._object);
        }
        for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
          this._chainedTweens[i].start(time);
        }
        return false;
      }
    }
    return true;
  }
  // export easing function as static class property
  static get Easing() {
    return Easing;
  }
  static get Interpolation() {
    return Interpolation;
  }
};
var VertexArrayBuffer = class {
  constructor(vertex_size, vertex_per_obj) {
    this.vertexSize = vertex_size;
    this.objSize = vertex_per_obj;
    this.maxVertex = 256;
    this.vertexCount = 0;
    this.buffer = new ArrayBuffer(this.maxVertex * this.vertexSize * this.objSize);
    this.bufferF32 = new Float32Array(this.buffer);
    this.bufferU32 = new Uint32Array(this.buffer);
  }
  /**
   * clear the vertex array buffer
   * @ignore
   */
  clear() {
    this.vertexCount = 0;
  }
  /**
   * return true if full
   * @ignore
   */
  isFull(vertex = this.objSize) {
    return this.vertexCount + vertex >= this.maxVertex;
  }
  /**
   * resize the vertex buffer, retaining its original contents
   * @ignore
   */
  resize(vertexCount) {
    while (vertexCount > this.maxVertex) {
      this.maxVertex <<= 1;
    }
    let data2 = this.bufferF32;
    this.buffer = new ArrayBuffer(this.maxVertex * this.vertexSize * this.objSize);
    this.bufferF32 = new Float32Array(this.buffer);
    this.bufferU32 = new Uint32Array(this.buffer);
    this.bufferF32.set(data2);
    return this;
  }
  /**
   * push a new vertex to the buffer
   * @ignore
   */
  push(x, y, u, v, tint) {
    let offset = this.vertexCount * this.vertexSize;
    if (this.vertexCount >= this.maxVertex) {
      this.resize(this.vertexCount);
    }
    this.bufferF32[offset] = x;
    this.bufferF32[++offset] = y;
    if (typeof u !== "undefined") {
      this.bufferF32[++offset] = u;
      this.bufferF32[++offset] = v;
    }
    if (typeof tint !== "undefined") {
      this.bufferU32[++offset] = tint;
    }
    this.vertexCount++;
    return this;
  }
  /**
   * return a reference to the data in Float32 format
   * @ignore
   */
  toFloat32(begin, end) {
    if (typeof end !== "undefined") {
      return this.bufferF32.subarray(begin, end);
    } else {
      return this.bufferF32;
    }
  }
  /**
   * return a reference to the data in Uint32 format
   * @ignore
   */
  toUint32(begin, end) {
    if (typeof end !== "undefined") {
      return this.bufferU32.subarray(begin, end);
    } else {
      return this.bufferU32;
    }
  }
  /**
   * return the size of the vertex in vertex
   * @ignore
   */
  length() {
    return this.vertexCount;
  }
  /**
   * return true if empty
   * @ignore
   */
  isEmpty() {
    return this.vertexCount === 0;
  }
};
var Compositor = class {
  /**
   * @param {WebGLRenderer} renderer - the current WebGL renderer session
   * @param {object} settings - additional settings to initialize this compositors
   * @param {object[]} settings.attribute - an array of attributes definition
   * @param {string} settings.attribute.name - name of the attribute in the vertex shader
   * @param {number} settings.attribute.size - number of components per vertex attribute. Must be 1, 2, 3, or 4.
   * @param {GLenum} settings.attribute.type - data type of each component in the array
   * @param {boolean} settings.attribute.normalized - whether integer data values should be normalized into a certain range when being cast to a float
   * @param {number} settings.attribute.offset - offset in bytes of the first component in the vertex attribute array
   * @param {object} settings.shader - an array of attributes definition
   * @param {string} settings.shader.vertex - a string containing the GLSL source code to set
   * @param {string} settings.shader.fragment - a string containing the GLSL source code to set
   */
  constructor(renderer2, settings) {
    this.init(renderer2, settings);
  }
  /**
   * Initialize the compositor
   * @ignore
   */
  init(renderer2, settings) {
    this.renderer = renderer2;
    this.gl = renderer2.gl;
    this.color = renderer2.currentColor;
    this.viewMatrix = renderer2.currentTransform;
    this.defaultShader = void 0;
    this.currentShader = void 0;
    this.mode = this.gl.TRIANGLES;
    this.attributes = [];
    this.vertexByteSize = 0;
    this.vertexSize = 0;
    this.vertexData = null;
    if (typeof settings !== "undefined" && Array.isArray(settings.attributes)) {
      settings.attributes.forEach((attr) => {
        this.addAttribute(attr.name, attr.size, attr.type, attr.normalized, attr.offset);
        this.vertexData = new VertexArrayBuffer(this.vertexSize, 6);
      });
    } else {
      throw new Error("attributes definition missing");
    }
    if (typeof settings !== "undefined" && typeof settings.shader !== "undefined") {
      this.defaultShader = new GLShader(this.gl, settings.shader.vertex, settings.shader.fragment);
    } else {
      throw new Error("shader definition missing");
    }
  }
  /**
   * Reset compositor internal state
   * @ignore
   */
  reset() {
    this.gl = this.renderer.gl;
    this.vertexData.clear();
  }
  /**
   * called by the WebGL renderer when a compositor become the current one
   */
  bind() {
    if (this.renderer.currentProgram !== this.defaultShader.program) {
      this.useShader(this.defaultShader);
    }
  }
  /**
   * Select the shader to use for compositing
   * @see GLShader
   * @param {GLShader} shader - a reference to a GLShader instance
   */
  useShader(shader) {
    if (this.renderer.currentProgram !== shader.program) {
      this.flush();
      shader.bind();
      shader.setUniform("uProjectionMatrix", this.renderer.projectionMatrix);
      shader.setVertexAttributes(this.gl, this.attributes, this.vertexByteSize);
      this.currentShader = shader;
      this.renderer.currentProgram = this.currentShader.program;
    }
  }
  /**
   * add vertex attribute property definition to the compositor
   * @param {string} name - name of the attribute in the vertex shader
   * @param {number} size - number of components per vertex attribute. Must be 1, 2, 3, or 4.
   * @param {GLenum} type - data type of each component in the array
   * @param {boolean} normalized - whether integer data values should be normalized into a certain range when being cast to a float
   * @param {number} offset - offset in bytes of the first component in the vertex attribute array
   */
  addAttribute(name, size, type, normalized, offset) {
    this.attributes.push({
      name,
      size,
      type,
      normalized,
      offset
    });
    switch (type) {
      case this.gl.BYTE:
        this.vertexByteSize += size * Int8Array.BYTES_PER_ELEMENT;
        break;
      case this.gl.UNSIGNED_BYTE:
        this.vertexByteSize += size * Uint8Array.BYTES_PER_ELEMENT;
        break;
      case this.gl.SHORT:
        this.vertexByteSize += size * Int16Array.BYTES_PER_ELEMENT;
        break;
      case this.gl.UNSIGNED_SHORT:
        this.vertexByteSize += size * Uint16Array.BYTES_PER_ELEMENT;
        break;
      case this.gl.INT:
        this.vertexByteSize += size * Int32Array.BYTES_PER_ELEMENT;
        break;
      case this.gl.UNSIGNED_INT:
        this.vertexByteSize += size * Uint32Array.BYTES_PER_ELEMENT;
        break;
      case this.gl.FLOAT:
        this.vertexByteSize += size * Float32Array.BYTES_PER_ELEMENT;
        break;
      default:
        throw new Error("Invalid GL Attribute type");
    }
    this.vertexSize = this.vertexByteSize / Float32Array.BYTES_PER_ELEMENT;
  }
  /**
   * set/change the current projection matrix
   * @param {Matrix3d} matrix - the new projection matrix
   */
  setProjection(matrix) {
    this.currentShader.setUniform("uProjectionMatrix", matrix);
  }
  /**
   * Flush batched vertex data to the GPU
   * @param {number} [mode=gl.TRIANGLES] - the GL drawing mode
   */
  flush(mode = this.mode) {
    let vertex = this.vertexData;
    let vertexCount = vertex.vertexCount;
    if (vertexCount > 0) {
      let gl = this.gl;
      let vertexSize = vertex.vertexSize;
      if (this.renderer.WebGLVersion > 1) {
        gl.bufferData(gl.ARRAY_BUFFER, vertex.toFloat32(), gl.STREAM_DRAW, 0, vertexCount * vertexSize);
      } else {
        gl.bufferData(gl.ARRAY_BUFFER, vertex.toFloat32(0, vertexCount * vertexSize), gl.STREAM_DRAW);
      }
      gl.drawArrays(mode, 0, vertexCount);
      vertex.clear();
    }
  }
};
var primitiveVertex = "// Current vertex point\nattribute vec2 aVertex;\nattribute vec4 aColor;\n\n// Projection matrix\nuniform mat4 uProjectionMatrix;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n    // Transform the vertex position by the projection matrix\n    gl_Position = uProjectionMatrix * vec4(aVertex, 0.0, 1.0);\n    // Pass the remaining attributes to the fragment shader\n    vColor = vec4(aColor.bgr * aColor.a, aColor.a);\n}\n";
var primitiveFragment = "varying vec4 vColor;\n\nvoid main(void) {\n    gl_FragColor = vColor;\n}\n";
var PrimitiveCompositor = class extends Compositor {
  /**
   * Initialize the compositor
   * @ignore
   */
  init(renderer2) {
    super.init(renderer2, {
      attributes: [
        { name: "aVertex", size: 2, type: renderer2.gl.FLOAT, normalized: false, offset: 0 * Float32Array.BYTES_PER_ELEMENT },
        { name: "aColor", size: 4, type: renderer2.gl.UNSIGNED_BYTE, normalized: true, offset: 2 * Float32Array.BYTES_PER_ELEMENT }
      ],
      shader: {
        vertex: primitiveVertex,
        fragment: primitiveFragment
      }
    });
  }
  /**
   * Draw an array of vertices
   * @param {GLenum} mode - primitive type to render (gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, gl.TRIANGLES)
   * @param {Point[]} verts - an array of vertices
   * @param {number} [vertexCount=verts.length] - amount of points defined in the points array
   */
  drawVertices(mode, verts, vertexCount = verts.length) {
    let viewMatrix = this.viewMatrix;
    let vertexData = this.vertexData;
    let alpha2 = this.renderer.getGlobalAlpha();
    let colorUint32 = this.renderer.currentColor.toUint32(alpha2);
    if (vertexData.isFull(vertexCount)) {
      this.flush();
    }
    if (mode !== this.mode) {
      this.flush(this.mode);
      this.mode = mode;
    }
    if (!viewMatrix.isIdentity()) {
      verts.forEach((vert) => {
        viewMatrix.apply(vert);
        vertexData.push(vert.x, vert.y, void 0, void 0, colorUint32);
      });
    } else {
      verts.forEach((vert) => {
        vertexData.push(vert.x, vert.y, void 0, void 0, colorUint32);
      });
    }
    if (this.mode === this.gl.LINE_STRIP || this.mode === this.gl.LINE_LOOP) {
      this.flush(this.mode);
    }
  }
};
var quadVertex = "// Current vertex point\nattribute vec2 aVertex;\nattribute vec2 aRegion;\nattribute vec4 aColor;\n\n// Projection matrix\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vRegion;\nvarying vec4 vColor;\n\nvoid main(void) {\n    // Transform the vertex position by the projection matrix\n    gl_Position = uProjectionMatrix * vec4(aVertex, 0.0, 1.0);\n    // Pass the remaining attributes to the fragment shader\n    vColor = vec4(aColor.bgr * aColor.a, aColor.a);\n    vRegion = aRegion;\n}\n";
var quadFragment = "uniform sampler2D uSampler;\nvarying vec4 vColor;\nvarying vec2 vRegion;\n\nvoid main(void) {\n    gl_FragColor = texture2D(uSampler, vRegion) * vColor;\n}\n";
var V_ARRAY = [
  new Vector2d(),
  new Vector2d(),
  new Vector2d(),
  new Vector2d()
];
var QuadCompositor = class extends Compositor {
  /**
   * Initialize the compositor
   * @ignore
   */
  init(renderer2) {
    super.init(renderer2, {
      attributes: [
        { name: "aVertex", size: 2, type: renderer2.gl.FLOAT, normalized: false, offset: 0 * Float32Array.BYTES_PER_ELEMENT },
        { name: "aRegion", size: 2, type: renderer2.gl.FLOAT, normalized: false, offset: 2 * Float32Array.BYTES_PER_ELEMENT },
        { name: "aColor", size: 4, type: renderer2.gl.UNSIGNED_BYTE, normalized: true, offset: 4 * Float32Array.BYTES_PER_ELEMENT }
      ],
      shader: {
        vertex: quadVertex,
        fragment: quadFragment
      }
    });
    this.currentTextureUnit = -1;
    this.boundTextures = [];
  }
  /**
   * Reset compositor internal state
   * @ignore
   */
  reset() {
    super.reset();
    for (let i = 0; i < this.renderer.maxTextures; i++) {
      let texture2D = this.getTexture2D(i);
      if (typeof texture2D !== "undefined") {
        this.deleteTexture2D(texture2D);
      }
    }
    this.currentTextureUnit = -1;
  }
  /**
   * Create a WebGL texture from an image
   * @param {number} unit - Destination texture unit
   * @param {Image|HTMLCanvasElement|ImageData|Uint8Array[]|Float32Array[]} [pixels=null] - Source image
   * @param {number} filter - gl.LINEAR or gl.NEAREST
   * @param {string} [repeat="no-repeat"] - Image repeat behavior (see {@link ImageLayer#repeat})
   * @param {number} [w=pixels.width] - Source image width (Only use with UInt8Array[] or Float32Array[] source image)
   * @param {number} [h=pixels.height] - Source image height (Only use with UInt8Array[] or Float32Array[] source image)
   * @param {boolean} [premultipliedAlpha=true] - Multiplies the alpha channel into the other color channels
   * @param {boolean} [mipmap=true] - Whether mipmap levels should be generated for this texture
   * @returns {WebGLTexture} a WebGL texture
   */
  createTexture2D(unit, pixels = null, filter, repeat = "no-repeat", w = pixels.width, h = pixels.height, premultipliedAlpha = true, mipmap = true) {
    let gl = this.gl;
    let isPOT = isPowerOfTwo(w) && isPowerOfTwo(h);
    let rs = repeat.search(/^repeat(-x)?$/) === 0 && (isPOT || this.renderer.WebGLVersion > 1) ? gl.REPEAT : gl.CLAMP_TO_EDGE;
    let rt = repeat.search(/^repeat(-y)?$/) === 0 && (isPOT || this.renderer.WebGLVersion > 1) ? gl.REPEAT : gl.CLAMP_TO_EDGE;
    let texture = gl.createTexture();
    this.bindTexture2D(texture, unit);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, rs);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, rt);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
    if (pixels === null || typeof pixels.byteLength !== "undefined") {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels, 0);
    } else if (typeof globalThis.OffscreenCanvas !== "undefined" && pixels instanceof globalThis.OffscreenCanvas) {
      const imageBitmap = pixels.transferToImageBitmap();
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageBitmap);
      imageBitmap.close();
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    }
    if (isPOT && mipmap === true) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    return texture;
  }
  /**
   * delete the given WebGL texture
   * @param {WebGLTexture} [texture] - a WebGL texture to delete
   */
  deleteTexture2D(texture) {
    this.gl.deleteTexture(texture);
    this.unbindTexture2D(texture);
  }
  /**
   * returns the WebGL texture associated to the given texture unit
   * @param {number} unit - Texture unit to which a texture is bound
   * @returns {WebGLTexture} texture a WebGL texture
   */
  getTexture2D(unit) {
    return this.boundTextures[unit];
  }
  /**
   * assign the given WebGL texture to the current batch
   * @param {WebGLTexture} texture - a WebGL texture
   * @param {number} unit - Texture unit to which the given texture is bound
   */
  bindTexture2D(texture, unit) {
    let gl = this.gl;
    if (texture !== this.boundTextures[unit]) {
      this.flush();
      if (this.currentTextureUnit !== unit) {
        this.currentTextureUnit = unit;
        gl.activeTexture(gl.TEXTURE0 + unit);
      }
      gl.bindTexture(gl.TEXTURE_2D, texture);
      this.boundTextures[unit] = texture;
    } else if (this.currentTextureUnit !== unit) {
      this.flush();
      this.currentTextureUnit = unit;
      gl.activeTexture(gl.TEXTURE0 + unit);
    }
  }
  /**
   * unbind the given WebGL texture, forcing it to be reuploaded
   * @param {WebGLTexture} [texture] - a WebGL texture
   * @param {number} [unit] - a WebGL texture
   * @returns {number} unit the unit number that was associated with the given texture
   */
  unbindTexture2D(texture, unit) {
    if (typeof unit === "undefined") {
      unit = this.boundTextures.indexOf(texture);
    }
    if (unit !== -1) {
      delete this.boundTextures[unit];
      if (unit === this.currentTextureUnit) {
        this.currentTextureUnit = -1;
      }
    }
    return unit;
  }
  /**
   * @ignore
   */
  uploadTexture(texture, w, h, force = false) {
    let unit = this.renderer.cache.getUnit(texture);
    let texture2D = this.boundTextures[unit];
    if (typeof texture2D === "undefined" || force) {
      this.createTexture2D(
        unit,
        texture.getTexture(),
        this.renderer.settings.antiAlias ? this.gl.LINEAR : this.gl.NEAREST,
        texture.repeat,
        w,
        h,
        texture.premultipliedAlpha
      );
    } else {
      this.bindTexture2D(texture2D, unit);
    }
    return this.currentTextureUnit;
  }
  /**
   * Add a textured quad
   * @param {TextureAtlas} texture - Source texture atlas
   * @param {number} x - Destination x-coordinate
   * @param {number} y - Destination y-coordinate
   * @param {number} w - Destination width
   * @param {number} h - Destination height
   * @param {number} u0 - Texture UV (u0) value.
   * @param {number} v0 - Texture UV (v0) value.
   * @param {number} u1 - Texture UV (u1) value.
   * @param {number} v1 - Texture UV (v1) value.
   * @param {number} tint - tint color to be applied to the texture in UINT32 (argb) format
   * @param {boolean} reupload - Force the texture to be reuploaded even if already bound
   */
  addQuad(texture, x, y, w, h, u0, v0, u1, v1, tint, reupload = false) {
    let vertexData = this.vertexData;
    if (vertexData.isFull(6)) {
      this.flush();
    }
    let unit = this.uploadTexture(texture, w, h, reupload);
    this.currentShader.setUniform("uSampler", unit);
    let m = this.viewMatrix, vec0 = V_ARRAY[0].set(x, y), vec1 = V_ARRAY[1].set(x + w, y), vec2 = V_ARRAY[2].set(x, y + h), vec3 = V_ARRAY[3].set(x + w, y + h);
    if (!m.isIdentity()) {
      m.apply(vec0);
      m.apply(vec1);
      m.apply(vec2);
      m.apply(vec3);
    }
    vertexData.push(vec0.x, vec0.y, u0, v0, tint);
    vertexData.push(vec1.x, vec1.y, u1, v0, tint);
    vertexData.push(vec2.x, vec2.y, u0, v1, tint);
    vertexData.push(vec2.x, vec2.y, u0, v1, tint);
    vertexData.push(vec1.x, vec1.y, u1, v0, tint);
    vertexData.push(vec3.x, vec3.y, u1, v1, tint);
  }
};
var supportedCompressedTextureFormats;
var WebGLRenderer = class extends Renderer {
  /**
   * @param {ApplicationSettings} [options] - optional parameters for the renderer
   */
  constructor(options) {
    super(Object.assign(options, { context: "webgl" }));
    this.GPUVendor = void 0;
    this.GPURenderer = void 0;
    this.gl = this.renderTarget.context;
    this.lineWidth = 1;
    this.lineJoin = "round";
    this.vertexBuffer = this.gl.createBuffer();
    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
    this._colorStack = [];
    this._matrixStack = [];
    this._scissorStack = [];
    this._blendStack = [];
    this.currentTransform = new Matrix2d();
    this.currentCompositor = void 0;
    this.currentProgram = void 0;
    this.compositors = /* @__PURE__ */ new Map();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
    this.addCompositor(new (this.settings.compositor || QuadCompositor)(this), "quad", true);
    this.addCompositor(new (this.settings.compositor || PrimitiveCompositor)(this), "primitive");
    this.depthTest = options.depthTest;
    if (this.depthTest === "z-buffer") {
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.depthMask(true);
    } else {
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.depthMask(false);
    }
    this.gl.disable(this.gl.SCISSOR_TEST);
    this.gl.enable(this.gl.BLEND);
    this.setBlendMode(this.settings.blendMode);
    let debugInfo = this.gl.getExtension("WEBGL_debug_renderer_info");
    if (debugInfo !== null) {
      this.GPUVendor = this.gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
      this.GPURenderer = this.gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
    }
    this.customShader = void 0;
    this.cache = new TextureCache(this.maxTextures);
    this.type = "WebGL" + this.WebGLVersion;
    this.getCanvas().addEventListener("webglcontextlost", (e) => {
      e.preventDefault();
      this.isContextValid = false;
      emit(ONCONTEXT_LOST, this);
    }, false);
    this.getCanvas().addEventListener("webglcontextrestored", () => {
      this.reset();
      this.isContextValid = true;
      emit(ONCONTEXT_RESTORED, this);
    }, false);
    on(GAME_RESET, () => {
      this.reset();
    });
    on(CANVAS_ONRESIZE, (width, height) => {
      this.flush();
      this.setViewport(0, 0, width, height);
    });
  }
  /**
   * The WebGL version used by this renderer (1 or 2)
   * @type {number}
   * @default 1
   */
  get WebGLVersion() {
    return this.renderTarget.WebGLVersion;
  }
  /**
   * return the list of supported compressed texture formats
   * @return {Object}
   */
  getSupportedCompressedTextureFormats() {
    if (typeof supportedCompressedTextureFormats === "undefined") {
      const gl = this.gl;
      supportedCompressedTextureFormats = {
        astc: gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
        bptc: gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
        s3tc_srgb: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
        etc2: gl.getExtension("WEBGL_compressed_texture_etc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || gl.getExtension("WEBGL_compressed_texture_es3_0")
      };
    }
    return supportedCompressedTextureFormats;
  }
  /**
   * return true if the given compressed texture format is supported
   * @param {Number} format
   * @returns
   */
  hasSupportedCompressedFormats(format) {
    const supportedFormats = this.getSupportedCompressedTextureFormats();
    for (var supportedFormat in supportedFormats) {
      for (var extension in supportedFormats[supportedFormat]) {
        if (format === supportedFormats[supportedFormat][extension]) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Reset context state
   */
  reset() {
    super.reset();
    this._colorStack.forEach((color) => {
      pool.push(color);
    });
    this._matrixStack.forEach((matrix) => {
      pool.push(matrix);
    });
    this._colorStack.length = 0;
    this._matrixStack.length = 0;
    this._blendStack.length = 0;
    this.clear();
    this.setViewport();
    if (this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING) !== this.vertexBuffer) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
    }
    this.currentCompositor = void 0;
    this.currentProgram = void 0;
    this.customShader = void 0;
    this.compositors.forEach((compositor) => {
      if (this.isContextValid === false) {
        compositor.init(this);
      } else {
        compositor.reset();
      }
    });
    this.setCompositor("quad");
    this.gl.disable(this.gl.SCISSOR_TEST);
  }
  /**
   * add a new compositor to this renderer
   * @param {Compositor} compositor - a compositor instance
   * @param {string} name - a name uniquely identifying this compositor
   * @param {boolean} [activate=false] - true if the given compositor should be set as the active one
   */
  addCompositor(compositor, name = "default", activate = false) {
    if (typeof this.compositors.get(name) !== "undefined") {
      throw new Error("Invalid Compositor name");
    }
    this.compositors.set(name, compositor);
    if (activate === true) {
      this.setCompositor(name);
    }
  }
  /**
   * set the active compositor for this renderer
   * @param {string} name - a compositor name
   * @param {GLShader} [shader] - an optional shader program to be used, instead of the default one, when activating the compositor
   * @returns {Compositor} an instance to the current active compositor
   */
  setCompositor(name = "default", shader = this.customShader) {
    let compositor = this.compositors.get(name);
    if (typeof compositor === "undefined") {
      throw new Error("Invalid Compositor");
    }
    if (this.currentCompositor !== compositor) {
      if (this.currentCompositor !== void 0) {
        this.currentCompositor.flush();
      }
      this.currentCompositor = compositor;
    }
    if (name === "quad" && typeof shader === "object") {
      this.currentCompositor.useShader(shader);
    } else {
      this.currentCompositor.bind();
    }
    return this.currentCompositor;
  }
  /**
   * Reset the gl transform to identity
   */
  resetTransform() {
    this.currentTransform.identity();
  }
  /**
   * Create a pattern with the specified repetition
   * @param {HTMLImageElement|SVGImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap|OffscreenCanvas|VideoFrame} image - Source image to be used as the pattern's image
   * @param {string} repeat - Define how the pattern should be repeated
   * @returns {TextureAtlas} the patterned texture created
   * @see ImageLayer#repeat
   * @example
   * let tileable   = renderer.createPattern(image, "repeat");
   * let horizontal = renderer.createPattern(image, "repeat-x");
   * let vertical   = renderer.createPattern(image, "repeat-y");
   * let basic      = renderer.createPattern(image, "no-repeat");
   */
  createPattern(image, repeat) {
    this.setCompositor("quad");
    if (renderer.WebGLVersion === 1 && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height))) {
      let src = typeof image.src !== "undefined" ? image.src : image;
      throw new Error(
        "[WebGL Renderer] " + src + " is not a POT texture (" + image.width + "x" + image.height + ")"
      );
    }
    let texture = new TextureAtlas(createAtlas(image.width, image.height, "pattern", repeat), image);
    this.currentCompositor.uploadTexture(texture);
    return texture;
  }
  /**
   * Flush the compositor to the frame buffer
   */
  flush() {
    this.currentCompositor.flush();
  }
  /**
   * set/change the current projection matrix (WebGL only)
   * @param {Matrix3d} matrix - the new projection matrix
   */
  setProjection(matrix) {
    super.setProjection(matrix);
    this.currentCompositor.setProjection(matrix);
  }
  /**
   * Sets the WebGL viewport, which specifies the affine transformation of x and y from normalized device coordinates to window coordinates
   * @param {number} [x = 0] - x the horizontal coordinate for the lower left corner of the viewport origin
   * @param {number} [y = 0] - y the vertical coordinate for the lower left corner of the viewport origin
   * @param {number} [w = width of the canvas] - the width of viewport
   * @param {number} [h = height of the canvas] - the height of viewport
   */
  setViewport(x = 0, y = 0, w = this.getCanvas().width, h = this.getCanvas().height) {
    this.gl.viewport(x, y, w, h);
  }
  /**
   * Clear the frame buffer
   */
  clear() {
    let gl = this.gl;
    gl.clearColor(0, 0, 0, this.settings.transparent ? 0 : 1);
    this.lineWidth = 1;
    if (this.depthTest === "z-buffer") {
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    } else {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    }
  }
  /**
   * Clears the gl context with the given color.
   * @param {Color|string} [color="#000000"] - CSS color.
   * @param {boolean} [opaque=false] - Allow transparency [default] or clear the surface completely [true]
   */
  clearColor(color = "#000000", opaque = false) {
    let glArray;
    let gl = this.gl;
    if (color instanceof Color) {
      glArray = color.toArray();
    } else {
      let _color = pool.pull("me.Color");
      glArray = _color.parseCSS(color).toArray();
      pool.push(_color);
    }
    gl.clearColor(glArray[0], glArray[1], glArray[2], opaque === true ? 1 : glArray[3]);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  /**
   * Erase the pixels in the given rectangular area by setting them to transparent black (rgba(0,0,0,0)).
   * @param {number} x - x axis of the coordinate for the rectangle starting point.
   * @param {number} y - y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   */
  clearRect(x, y, width, height) {
    this.save();
    this.clipRect(x, y, width, height);
    this.clearColor();
    this.restore();
  }
  /**
   * Draw an image to the gl context
   * @param {HTMLImageElement|SVGImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap|OffscreenCanvas|VideoFrame} image - An element to draw into the context.
   * @param {number} sx - The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
   * @param {number} sy - The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
   * @param {number} sw - The width of the sub-rectangle of the source image to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by sx and sy to the bottom-right corner of the image is used.
   * @param {number} sh - The height of the sub-rectangle of the source image to draw into the destination context.
   * @param {number} dx - The X coordinate in the destination canvas at which to place the top-left corner of the source image.
   * @param {number} dy - The Y coordinate in the destination canvas at which to place the top-left corner of the source image.
   * @param {number} dw - The width to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn.
   * @param {number} dh - The height to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn.
   * @example
   * // Position the image on the canvas:
   * renderer.drawImage(image, dx, dy);
   * // Position the image on the canvas, and specify width and height of the image:
   * renderer.drawImage(image, dx, dy, dWidth, dHeight);
   * // Clip the image and position the clipped part on the canvas:
   * renderer.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
   */
  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (typeof sw === "undefined") {
      sw = dw = image.width;
      sh = dh = image.height;
      dx = sx;
      dy = sy;
      sx = 0;
      sy = 0;
    } else if (typeof dx === "undefined") {
      dx = sx;
      dy = sy;
      dw = sw;
      dh = sh;
      sw = image.width;
      sh = image.height;
      sx = 0;
      sy = 0;
    }
    if (this.settings.subPixel === false) {
      dx |= 0;
      dy |= 0;
    }
    this.setCompositor("quad");
    let reupload = typeof image.videoWidth !== "undefined";
    let texture = this.cache.get(image);
    let uvs = texture.getUVs(sx + "," + sy + "," + sw + "," + sh);
    this.currentCompositor.addQuad(texture, dx, dy, dw, dh, uvs[0], uvs[1], uvs[2], uvs[3], this.currentTint.toUint32(this.getGlobalAlpha()), reupload);
  }
  /**
   * Draw a pattern within the given rectangle.
   * @param {TextureAtlas} pattern - Pattern object
   * @param {number} x - x position where to draw the pattern
   * @param {number} y - y position where to draw the pattern
   * @param {number} width - width of the pattern
   * @param {number} height - height of the pattern
   * @see WebGLRenderer#createPattern
   */
  drawPattern(pattern, x, y, width, height) {
    let uvs = pattern.getUVs("0,0," + width + "," + height);
    this.setCompositor("quad");
    this.currentCompositor.addQuad(pattern, x, y, width, height, uvs[0], uvs[1], uvs[2], uvs[3], this.currentTint.toUint32(this.getGlobalAlpha()));
  }
  /**
   * starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path
   * @example
   * // First path
   * renderer.beginPath();
   * renderer.setColor("blue");
   * renderer.moveTo(20, 20);
   * renderer.lineTo(200, 20);
   * renderer.stroke();
   * // Second path
   * renderer.beginPath();
   * renderer.setColor("green");
   * renderer.moveTo(20, 20);
   * renderer.lineTo(120, 120);
   * renderer.stroke();
   */
  beginPath() {
    this.path2D.beginPath();
  }
  /**
   * begins a new sub-path at the point specified by the given (x, y) coordinates.
   * @param {number} x - The x axis of the point.
   * @param {number} y - The y axis of the point.
   */
  moveTo(x, y) {
    this.path2D.moveTo(x, y);
  }
  /**
   * adds a straight line to the current sub-path by connecting the sub-path's last point to the specified (x, y) coordinates.
   */
  lineTo(x, y) {
    this.path2D.lineTo(x, y);
  }
  /**
   * creates a rectangular path whose starting point is at (x, y) and whose size is specified by width and height.
   * @param {number} x - The x axis of the coordinate for the rectangle starting point.
   * @param {number} y - The y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   */
  rect(x, y, width, height) {
    this.path2D.rect(x, y, width, height);
  }
  /**
   * adds a rounded rectangle to the current path.
   * @param {number} x - The x axis of the coordinate for the rectangle starting point.
   * @param {number} y - The y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   * @param {number} radius - The corner radius.
   */
  roundRect(x, y, width, height, radii) {
    this.path2D.roundRect(x, y, width, height, radii);
  }
  /**
   * stroke the given shape or the current defined path
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [shape] - a shape object to stroke
   * @param {boolean} [fill=false] - fill the shape with the current color if true
   */
  stroke(shape, fill) {
    this.setCompositor("primitive");
    if (typeof shape === "undefined") {
      if (fill === true) {
        this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
      } else {
        this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
      }
    } else {
      super.stroke(shape, fill);
    }
  }
  /**
   * fill the given shape or the current defined path
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [shape] - a shape object to fill
   */
  fill(shape) {
    this.stroke(shape, true);
  }
  /**
   * add a straight line from the current point to the start of the current sub-path. If the shape has already been closed or has only one point, this function does nothing
  */
  closePath() {
    this.path2D.closePath();
  }
  /**
   * Returns the WebGLContext instance for the renderer
   * return a reference to the system 2d Context
   * @returns {WebGLRenderingContext} the current WebGL context
   */
  getContext() {
    return this.gl;
  }
  /**
   * set a blend mode for the given context. <br>
   * Supported blend mode between Canvas and WebGL remderer : <br>
   * - "normal" : this is the default mode and draws new content on top of the existing content <br>
   * <img src="images/normal-blendmode.png" width="510"/> <br>
   * - "multiply" : the pixels of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result. <br>
   * <img src="images/multiply-blendmode.png" width="510"/> <br>
   * - "additive or lighter" : where both content overlap the color is determined by adding color values. <br>
   * <img src="images/lighter-blendmode.png" width="510"/> <br>
   * - "screen" : The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply) <br>
   * <img src="images/screen-blendmode.png" width="510"/> <br>
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @param {string} [mode="normal"] - blend mode : "normal", "multiply", "lighter", "additive", "screen"
   * @param {WebGLRenderingContext} [gl] - a WebGL context
   */
  setBlendMode(mode = "normal", gl = this.gl) {
    if (this.currentBlendMode !== mode) {
      this.flush();
      gl.enable(gl.BLEND);
      this.currentBlendMode = mode;
      switch (mode) {
        case "screen":
          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
          break;
        case "lighter":
        case "additive":
          gl.blendFunc(gl.ONE, gl.ONE);
          break;
        case "multiply":
          gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
          break;
        default:
          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          this.currentBlendMode = "normal";
          break;
      }
    }
  }
  /**
   * restores the most recently saved renderer state by popping the top entry in the drawing state stack
   * @example
   * // Save the current state
   * renderer.save();
   *
   * // apply a transform and draw a rect
   * renderer.tranform(matrix);
   * renderer.fillRect(10, 10, 100, 100);
   *
   * // Restore to the state saved by the most recent call to save()
   * renderer.restore();
   */
  restore() {
    if (this._matrixStack.length !== 0) {
      let color = this._colorStack.pop();
      let matrix = this._matrixStack.pop();
      this.currentColor.copy(color);
      this.currentTransform.copy(matrix);
      this.setBlendMode(this._blendStack.pop());
      pool.push(color);
      pool.push(matrix);
    }
    if (this._scissorStack.length !== 0) {
      this.currentScissor.set(this._scissorStack.pop());
    } else {
      const canvas = this.getCanvas();
      this.gl.disable(this.gl.SCISSOR_TEST);
      this.currentScissor[0] = 0;
      this.currentScissor[1] = 0;
      this.currentScissor[2] = canvas.width;
      this.currentScissor[3] = canvas.height;
    }
  }
  /**
   * saves the entire state of the renderer by pushing the current state onto a stack.
   * @example
   * // Save the current state
   * renderer.save();
   *
   * // apply a transform and draw a rect
   * renderer.tranform(matrix);
   * renderer.fillRect(10, 10, 100, 100);
   *
   * // Restore to the state saved by the most recent call to save()
   * renderer.restore();
   */
  save() {
    this._colorStack.push(this.currentColor.clone());
    this._matrixStack.push(this.currentTransform.clone());
    if (this.gl.isEnabled(this.gl.SCISSOR_TEST)) {
      this._scissorStack.push(this.currentScissor.slice());
    }
    this._blendStack.push(this.getBlendMode());
  }
  /**
   * adds a rotation to the transformation matrix.
   * @param {number} angle - the rotation angle, clockwise in radians
   * @example
   * // Rotated rectangle
   * renderer.rotate((45 * Math.PI) / 180);
   * renderer.setColor("red");
   * renderer.fillRect(10, 10, 100, 100);
   *
   * // Reset transformation matrix to the identity matrix
   * renderer.setTransform(1, 0, 0, 1, 0, 0);
   */
  rotate(angle) {
    this.currentTransform.rotate(angle);
  }
  /**
   * adds a scaling transformation to the renderer units horizontally and/or vertically
   * @param {number} x - Scaling factor in the horizontal direction. A negative value flips pixels across the vertical axis. A value of 1 results in no horizontal scaling.
   * @param {number} y - Scaling factor in the vertical direction. A negative value flips pixels across the horizontal axis. A value of 1 results in no vertical scaling
   */
  scale(x, y) {
    this.currentTransform.scale(x, y);
  }
  /**
   * not used by this renderer?
   * @param {boolean} [enable=false]
   * @ignore
   */
  setAntiAlias(enable2 = false) {
    super.setAntiAlias(enable2);
  }
  /**
   * Set the global alpha
   * @param {number} alpha - 0.0 to 1.0 values accepted.
   */
  setGlobalAlpha(alpha2) {
    this.currentColor.alpha = alpha2;
  }
  /**
   * Return the global alpha
   * @returns {number} global alpha value
   */
  getGlobalAlpha() {
    return this.currentColor.alpha;
  }
  /**
   * Set the current fill & stroke style color.
   * By default, or upon reset, the value is set to #000000.
   * @param {Color|string} color - css color string.
   */
  setColor(color) {
    let alpha2 = this.currentColor.alpha;
    this.currentColor.copy(color);
    this.currentColor.alpha *= alpha2;
  }
  /**
   * Stroke an arc at the specified coordinates with given radius, start and end points
   * @param {number} x - arc center point x-axis
   * @param {number} y - arc center point y-axis
   * @param {number} radius - arc radius
   * @param {number} start - start angle in radians
   * @param {number} end - end angle in radians
   * @param {boolean} [antiClockwise=false] - draw arc anti-clockwise
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeArc(x, y, radius, start, end, antiClockwise = false, fill = false) {
    this.setCompositor("primitive");
    this.path2D.beginPath();
    this.path2D.arc(x, y, radius, start, end, antiClockwise);
    if (fill === false) {
      this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
    } else {
      this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
    }
  }
  /**
   * Fill an arc at the specified coordinates with given radius, start and end points
   * @param {number} x - arc center point x-axis
   * @param {number} y - arc center point y-axis
   * @param {number} radius - arc radius
   * @param {number} start - start angle in radians
   * @param {number} end - end angle in radians
   * @param {boolean} [antiClockwise=false] - draw arc anti-clockwise
   */
  fillArc(x, y, radius, start, end, antiClockwise = false) {
    this.strokeArc(x, y, radius, start, end, antiClockwise, true);
  }
  /**
   * Stroke an ellipse at the specified coordinates with given radius
   * @param {number} x - ellipse center point x-axis
   * @param {number} y - ellipse center point y-axis
   * @param {number} w - horizontal radius of the ellipse
   * @param {number} h - vertical radius of the ellipse
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeEllipse(x, y, w, h, fill = false) {
    this.setCompositor("primitive");
    this.path2D.beginPath();
    this.path2D.ellipse(x, y, w, h, 0, 0, 360);
    if (fill === false) {
      this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
    } else {
      this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
    }
  }
  /**
   * Fill an ellipse at the specified coordinates with given radius
   * @param {number} x - ellipse center point x-axis
   * @param {number} y - ellipse center point y-axis
   * @param {number} w - horizontal radius of the ellipse
   * @param {number} h - vertical radius of the ellipse
   */
  fillEllipse(x, y, w, h) {
    this.strokeEllipse(x, y, w, h, true);
  }
  /**
   * Stroke a line of the given two points
   * @param {number} startX - the start x coordinate
   * @param {number} startY - the start y coordinate
   * @param {number} endX - the end x coordinate
   * @param {number} endY - the end y coordinate
   */
  strokeLine(startX, startY, endX, endY) {
    this.setCompositor("primitive");
    if (this.lineWidth === 1) {
      this.path2D.beginPath();
      this.path2D.moveTo(startX, startY);
      this.path2D.lineTo(endX, endY);
      this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
    } else if (this.lineWidth > 1) {
      const halfWidth = this.lineWidth / 2;
      const angle = Math.atan2(endY - startY, endX - startX);
      const dx = Math.sin(angle) * halfWidth;
      const dy = Math.cos(angle) * halfWidth;
      const x1 = startX - dx;
      const y1 = startY + dy;
      const x2 = startX + dx;
      const y2 = startY - dy;
      const x3 = endX + dx;
      const y3 = endY - dy;
      const x4 = endX - dx;
      const y4 = endY + dy;
      this.path2D.beginPath();
      this.path2D.moveTo(x1, y1);
      this.path2D.lineTo(x2, y2);
      this.path2D.lineTo(x3, y3);
      this.path2D.lineTo(x4, y4);
      this.path2D.closePath();
      this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
    }
  }
  /**
   * Fill a line of the given two points
   * @param {number} startX - the start x coordinate
   * @param {number} startY - the start y coordinate
   * @param {number} endX - the end x coordinate
   * @param {number} endY - the end y coordinate
   */
  fillLine(startX, startY, endX, endY) {
    this.strokeLine(startX, startY, endX, endY);
  }
  /**
   * Stroke a Polygon on the screen with a specified color
   * @param {Polygon} poly - the shape to draw
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokePolygon(poly, fill = false) {
    const points = poly.points;
    const len = points.length;
    this.translate(poly.pos.x, poly.pos.y);
    if (fill === false && this.lineWidth > 1) {
      const radius = this.lineWidth / 2;
      for (let i = 0; i < len - 1; i++) {
        const curPoint = points[i];
        const nextPoint = points[i + 1];
        this.fillEllipse(nextPoint.x, nextPoint.y, radius, radius);
        this.strokeLine(curPoint.x, curPoint.y, nextPoint.x, nextPoint.y);
      }
      const lastPoint = points[len - 1];
      const firstPoint = points[0];
      if (!lastPoint.equals(firstPoint)) {
        this.fillEllipse(firstPoint.x, firstPoint.y, radius, radius);
        this.strokeLine(lastPoint.x, lastPoint.y, firstPoint.x, firstPoint.y);
      }
    } else {
      this.setCompositor("primitive");
      this.path2D.beginPath();
      for (let i = 0; i < len - 1; i++) {
        const curPoint = points[i];
        const nextPoint = points[i + 1];
        this.path2D.moveTo(curPoint.x, curPoint.y);
        this.path2D.lineTo(nextPoint.x, nextPoint.y);
      }
      this.path2D.closePath();
      if (fill === false) {
        this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
      } else {
        this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
      }
    }
    this.translate(-poly.pos.x, -poly.pos.y);
  }
  /**
   * Fill a me.Polygon on the screen
   * @param {Polygon} poly - the shape to draw
   */
  fillPolygon(poly) {
    this.strokePolygon(poly, true);
  }
  /**
   * Draw a stroke rectangle at the specified coordinates
   * @param {number} x - x axis of the coordinate for the rectangle starting point.
   * @param {number} y - y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeRect(x, y, width, height, fill = false) {
    if (fill === false && this.lineWidth > 1) {
      const radius = this.lineWidth / 2;
      this.strokeLine(x, y, x + width, y);
      this.strokeLine(x + width, y, x + width, y + height);
      this.strokeLine(x + width, y + height, x, y + height);
      this.strokeLine(x, y + height, x, y);
      this.fillEllipse(x, y, radius, radius);
      this.fillEllipse(x + width, y, radius, radius);
      this.fillEllipse(x + width, y + height, radius, radius);
      this.fillEllipse(x, y + height, radius, radius);
    } else {
      this.setCompositor("primitive");
      this.path2D.beginPath();
      this.path2D.rect(x, y, width, height);
      if (fill === false) {
        this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
      } else {
        this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
      }
    }
  }
  /**
   * Draw a filled rectangle at the specified coordinates
   * @param {number} x - x axis of the coordinate for the rectangle starting point.
   * @param {number} y - y axis of the coordinate for the rectangle starting point.
   * @param {number} width - The rectangle's width.
   * @param {number} height - The rectangle's height.
   */
  fillRect(x, y, width, height) {
    this.strokeRect(x, y, width, height, true);
  }
  /**
   * Stroke a rounded rectangle at the specified coordinates
   * @param {number} x - x axis of the coordinate for the rounded rectangle starting point.
   * @param {number} y - y axis of the coordinate for the rounded rectangle starting point.
   * @param {number} width - The rounded rectangle's width.
   * @param {number} height - The rounded rectangle's height.
   * @param {number} radius - The rounded corner's radius.
   * @param {boolean} [fill=false] - also fill the shape with the current color if true
   */
  strokeRoundRect(x, y, width, height, radius, fill = false) {
    this.setCompositor("primitive");
    this.path2D.beginPath();
    this.path2D.roundRect(x, y, width, height, radius);
    if (fill === false) {
      this.currentCompositor.drawVertices(this.gl.LINES, this.path2D.points);
    } else {
      this.currentCompositor.drawVertices(this.gl.TRIANGLES, this.path2D.triangulatePath());
    }
  }
  /**
   * Draw a rounded filled rectangle at the specified coordinates
   * @param {number} x - x axis of the coordinate for the rounded rectangle starting point.
   * @param {number} y - y axis of the coordinate for the rounded rectangle starting point.
   * @param {number} width - The rounded rectangle's width.
   * @param {number} height - The rounded rectangle's height.
   * @param {number} radius - The rounded corner's radius.
   */
  fillRoundRect(x, y, width, height, radius) {
    this.strokeRoundRect(x, y, width, height, radius, true);
  }
  /**
   * Stroke a Point at the specified coordinates
   * @param {number} x - x axis of the coordinate for the point.
   * @param {number} y - y axis of the coordinate for the point.
   */
  strokePoint(x, y) {
    this.strokeLine(x, y, x + 1, y + 1);
  }
  /**
   * Draw a a point at the specified coordinates
   * @param {number} x - x axis of the coordinate for the point.
   * @param {number} y - y axis of the coordinate for the point.
   */
  fillPoint(x, y) {
    this.strokePoint(x, y);
  }
  /**
   * Reset (overrides) the renderer transformation matrix to the
   * identity one, and then apply the given transformation matrix.
   * @param {Matrix2d|number} a - a matrix2d to transform by, or a the a component to multiply the current matrix by
   * @param {number} b - the b component to multiply the current matrix by
   * @param {number} c - the c component to multiply the current matrix by
   * @param {number} d - the d component to multiply the current matrix by
   * @param {number} e - the e component to multiply the current matrix by
   * @param {number} f - the f component to multiply the current matrix by
   */
  setTransform(a, b, c, d, e, f2) {
    this.resetTransform();
    this.transform(a, b, c, d, e, f2);
  }
  /**
   * Multiply given matrix into the renderer tranformation matrix
   * @see {@link WebGLRenderer.setTransform} which will reset the current transform matrix prior to performing the new transformation
   * @param {Matrix2d|number} a - a matrix2d to transform by, or a the a component to multiply the current matrix by
   * @param {number} b - the b component to multiply the current matrix by
   * @param {number} c - the c component to multiply the current matrix by
   * @param {number} d - the d component to multiply the current matrix by
   * @param {number} e - the e component to multiply the current matrix by
   * @param {number} f - the f component to multiply the current matrix by
   */
  transform(a, b, c, d, e, f2) {
    if (typeof a === "object") {
      this.currentTransform.multiply(a);
    } else {
      this.currentTransform.transform(a, b, c, d, e, f2);
    }
    if (this.settings.subPixel === false) {
      let a2 = this.currentTransform.toArray();
      a2[6] |= 0;
      a2[7] |= 0;
    }
  }
  /**
   * adds a translation transformation to the current matrix.
   * @param {number} x - Distance to move in the horizontal direction. Positive values are to the right, and negative to the left.
   * @param {number} y - Distance to move in the vertical direction. Positive values are down, and negative are up.
   */
  translate(x, y) {
    let currentTransform = this.currentTransform;
    currentTransform.translate(x, y);
    if (this.settings.subPixel === false) {
      let a = currentTransform.toArray();
      a[6] |= 0;
      a[7] |= 0;
    }
  }
  /**
   * clip the given region from the original canvas. Once a region is clipped,
   * all future drawing will be limited to the clipped region.
   * You can however save the current region using the save(),
   * and restore it (with the restore() method) any time in the future.
   * (<u>this is an experimental feature !</u>)
   * @param {number} x - x axis of the coordinate for the upper-left corner of the rectangle to start clipping from.
   * @param {number} y - y axis of the coordinate for the upper-left corner of the rectangle to start clipping from.
   * @param {number} width - the width of the rectangle to start clipping from.
   * @param {number} height - the height of the rectangle to start clipping from.
   */
  clipRect(x, y, width, height) {
    let canvas = this.getCanvas();
    let gl = this.gl;
    if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
      let currentScissor = this.currentScissor;
      if (gl.isEnabled(gl.SCISSOR_TEST)) {
        if (currentScissor[0] === x && currentScissor[1] === y && currentScissor[2] === width && currentScissor[3] === height) {
          return;
        }
      }
      this.flush();
      gl.enable(this.gl.SCISSOR_TEST);
      gl.scissor(
        // scissor does not account for currentTransform, so manually adjust
        x + this.currentTransform.tx,
        canvas.height - height - y - this.currentTransform.ty,
        width,
        height
      );
      currentScissor[0] = x;
      currentScissor[1] = y;
      currentScissor[2] = width;
      currentScissor[3] = height;
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  /**
   * A mask limits rendering elements to the shape and position of the given mask object.
   * If the drawing or rendering area is larger than the mask, only the intersecting part of the renderable will be visible.
   * (Note Mask are not preserved through renderer context save and restore and need so be manually cleared)
   * @see CanvasRenderer#clearMask
   * @param {Rect|RoundRect|Polygon|Line|Ellipse} [mask] - a shape defining the mask to be applied
   * @param {boolean} [invert=false] - either the given shape should define what is visible (default) or the opposite
   */
  setMask(mask, invert = false) {
    let gl = this.gl;
    this.flush();
    if (this.maskLevel === 0) {
      gl.enable(gl.STENCIL_TEST);
      gl.clear(gl.STENCIL_BUFFER_BIT);
    }
    this.maskLevel++;
    gl.colorMask(false, false, false, false);
    gl.stencilFunc(gl.EQUAL, this.maskLevel, 1);
    gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
    this.fill(mask);
    this.flush();
    gl.colorMask(true, true, true, true);
    if (invert === true) {
      gl.stencilFunc(gl.EQUAL, this.maskLevel + 1, 1);
    } else {
      gl.stencilFunc(gl.NOTEQUAL, this.maskLevel + 1, 1);
    }
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
  /**
   * disable (remove) the rendering mask set through setMask.
   * @see WebGLRenderer#setMask
   */
  clearMask() {
    if (this.maskLevel > 0) {
      this.flush();
      this.maskLevel = 0;
      this.gl.disable(this.gl.STENCIL_TEST);
    }
  }
};
var ColorLayer = class extends Renderable {
  /**
   * @param {string} name - Layer name
   * @param {Color|string} color - CSS color
   * @param {number} [z = 0] - z-index position
   */
  constructor(name, color, z) {
    super(0, 0, Infinity, Infinity);
    this.color = pool.pull("Color").parseCSS(color);
    this.onResetEvent(name, color, z);
  }
  onResetEvent(name, color, z = 0) {
    this.name = name;
    this.pos.z = z;
    this.floating = true;
    this.color.parseCSS(color);
  }
  /**
   * draw this color layer (automatically called by melonJS)
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
    renderer2.save();
    renderer2.clipRect(
      0,
      0,
      viewport.width,
      viewport.height
    );
    renderer2.clearColor(this.color);
    renderer2.restore();
  }
  /**
   * Destroy function
   * @ignore
   */
  destroy() {
    pool.push(this.color);
    this.color = void 0;
    super.destroy();
  }
};
var ImageLayer = class extends Sprite {
  /**
   * @param {number} x - x coordinate
   * @param {number} y - y coordinate
   * @param {object} settings - ImageLayer properties
   * @param {HTMLImageElement|HTMLCanvasElement|string} settings.image - Image reference. See {@link loader.getImage}
   * @param {string} [settings.name="me.ImageLayer"] - layer name
   * @param {number} [settings.z=0] - z-index position
   * @param {number|Vector2d} [settings.ratio=1.0] - Scrolling ratio to be applied. See {@link ImageLayer#ratio}
   * @param {"repeat"|"repeat-x"|"repeat-y"|"no-repeat"} [settings.repeat="repeat"] - define if and how an Image Layer should be repeated. See {@link ImageLayer#repeat}
   * @param {number|Vector2d} [settings.anchorPoint=<0.0,0.0>] - Define how the image is anchored to the viewport bound. By default, its upper-left corner is anchored to the viewport bounds upper left corner.
   * @example
   * // create a repetitive background pattern on the X axis using the citycloud image asset
   * me.game.world.addChild(new me.ImageLayer(0, 0, {
   *     image:"citycloud",
   *     repeat :"repeat-x"
   * }), 1);
   */
  constructor(x, y, settings) {
    super(x, y, settings);
    this.floating = true;
    this.offset.set(x, y);
    this.ratio = pool.pull("Vector2d", 1, 1);
    if (typeof settings.ratio !== "undefined") {
      if (isNumeric(settings.ratio)) {
        this.ratio.set(settings.ratio, +settings.ratio);
      } else {
        this.ratio.setV(settings.ratio);
      }
    }
    if (typeof settings.anchorPoint === "undefined") {
      this.anchorPoint.set(0, 0);
    } else {
      if (typeof settings.anchorPoint === "number") {
        this.anchorPoint.set(settings.anchorPoint, settings.anchorPoint);
      } else {
        this.anchorPoint.setV(settings.anchorPoint);
      }
    }
    this.repeat = settings.repeat || "repeat";
    on(ONCONTEXT_RESTORED, this.createPattern, this);
  }
  /**
   * Define if and how an Image Layer should be repeated.<br>
   * By default, an Image Layer is repeated both vertically and horizontally.<br>
   * Acceptable values : <br>
   * - 'repeat' - The background image will be repeated both vertically and horizontally <br>
   * - 'repeat-x' - The background image will be repeated only horizontally.<br>
   * - 'repeat-y' - The background image will be repeated only vertically.<br>
   * - 'no-repeat' - The background-image will not be repeated.<br>
   * @type {string}
   * @default 'repeat'
   */
  get repeat() {
    return this._repeat;
  }
  set repeat(value) {
    this._repeat = value;
    switch (this._repeat) {
      case "no-repeat":
        this.repeatX = false;
        this.repeatY = false;
        break;
      case "repeat-x":
        this.repeatX = true;
        this.repeatY = false;
        break;
      case "repeat-y":
        this.repeatX = false;
        this.repeatY = true;
        break;
      default:
        this.repeatX = true;
        this.repeatY = true;
        break;
    }
    this.resize(game.viewport.width, game.viewport.height);
    this.createPattern();
  }
  // called when the layer is added to the game world or a container
  onActivateEvent() {
    on(VIEWPORT_ONCHANGE, this.updateLayer, this);
    on(VIEWPORT_ONRESIZE, this.resize, this);
    on(LEVEL_LOADED, this.updateLayer, this);
    if (this.ancestor.root !== true) {
      this.updateLayer();
    }
  }
  /**
   * resize the Image Layer to match the given size
   * @param {number} w - new width
   * @param {number} h - new height
   */
  resize(w, h) {
    return super.resize(
      this.repeatX ? Infinity : w,
      this.repeatY ? Infinity : h
    );
  }
  /**
   * createPattern function
   * @ignore
   */
  createPattern() {
    this._pattern = renderer.createPattern(this.image, this._repeat);
  }
  /**
   * updateLayer function
   * @ignore
   */
  updateLayer() {
    const rx = this.ratio.x, ry = this.ratio.y;
    const viewport = game.viewport;
    if (rx === 0 && ry === 0) {
      return;
    }
    const width = this.width, height = this.height, bw = viewport.bounds.width, bh = viewport.bounds.height, ax = this.anchorPoint.x, ay = this.anchorPoint.y, x = ax * (rx - 1) * (bw - viewport.width) + this.offset.x - rx * viewport.pos.x, y = ay * (ry - 1) * (bh - viewport.height) + this.offset.y - ry * viewport.pos.y;
    if (this.repeatX) {
      this.pos.x = x % width;
    } else {
      this.pos.x = x;
    }
    if (this.repeatY) {
      this.pos.y = y % height;
    } else {
      this.pos.y = y;
    }
    this.isDirty = true;
  }
  /**
  * override the default predraw function
  * as repeat and anchor are managed directly in the draw method
  * @ignore
  */
  preDraw(renderer2) {
    renderer2.save();
    renderer2.setGlobalAlpha(renderer2.globalAlpha() * this.getOpacity());
    renderer2.setTint(this.tint);
    if (this.blendMode !== renderer2.getBlendMode()) {
      renderer2.setBlendMode(this.blendMode);
    }
  }
  /**
   * draw this ImageLayer (automatically called by melonJS)
   * @protected
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
    const width = this.width, height = this.height, bw = viewport.bounds.width, bh = viewport.bounds.height, ax = this.anchorPoint.x, ay = this.anchorPoint.y;
    let x = this.pos.x, y = this.pos.y;
    if (this.ratio.x === 0 && this.ratio.y === 0) {
      x = x + ax * (bw - width);
      y = y + ay * (bh - height);
    }
    renderer2.translate(x, y);
    renderer2.drawPattern(
      this._pattern,
      0,
      0,
      viewport.width * 2,
      viewport.height * 2
    );
  }
  // called when the layer is removed from the game world or a container
  onDeactivateEvent() {
    off(VIEWPORT_ONCHANGE, this.updateLayer);
    off(VIEWPORT_ONRESIZE, this.resize);
    off(LEVEL_LOADED, this.updateLayer);
  }
  /**
   * Destroy function
   * @ignore
   */
  destroy() {
    pool.push(this.ratio);
    this.ratio = void 0;
    off(ONCONTEXT_RESTORED, this.createPattern);
    super.destroy();
  }
};
var NineSliceSprite = class extends Sprite {
  /**
   * @param {number} x - the x coordinates of the sprite object
   * @param {number} y - the y coordinates of the sprite object
   * @param {object} settings - Configuration parameters for the Sprite object
   * @param {number} settings.width - the width of the Renderable over which the sprite needs to be stretched
   * @param {number} settings.height - the height of the Renderable over which the sprite needs to be stretched
   * @param {number} [settings.insetx] - the width of a corner over which the sprite is unscaled (default is a quarter of the sprite width)
   * @param {number} [settings.insety] - the height of a corner over which the sprite is unscaled (default is a quarter of the sprite height)
   * @param {HTMLImageElement|HTMLCanvasElement|TextureAtlas|string} settings.image - reference to spritesheet image, a texture atlas or to a texture atlas
   * @param {string} [settings.name=""] - name of this object
   * @param {string} [settings.region] - region name of a specific region to use when using a texture atlas, see {@link TextureAtlas}
   * @param {number} [settings.framewidth] - Width of a single frame within the spritesheet
   * @param {number} [settings.frameheight] - Height of a single frame within the spritesheet
   * @param {string|Color} [settings.tint] - a tint to be applied to this sprite
   * @param {number} [settings.flipX] - flip the sprite on the horizontal axis
   * @param {number} [settings.flipY] - flip the sprite on the vertical axis
   * @param {Vector2d} [settings.anchorPoint={x:0.5, y:0.5}] - Anchor point to draw the frame at (defaults to the center of the frame).
   * @example
   * this.panelSprite = new me.NineSliceSprite(0, 0, {
   *     image : game.texture,
   *     region : "grey_panel",
   *     width : this.width,
   *     height : this.height
   * });
   */
  constructor(x, y, settings) {
    super(x, y, settings);
    if (typeof settings.width !== "number" || typeof settings.height !== "number") {
      throw new Error("height and width properties are mandatory");
    }
    this.width = Math.floor(settings.width);
    this.height = Math.floor(settings.height);
    this.nss_width = this.width;
    this.nss_height = this.height;
    this.insetx = settings.insetx;
    this.insety = settings.insety;
  }
  /**
   * width of the NineSliceSprite
   * @type {number}
   */
  get width() {
    return super.width;
  }
  set width(value) {
    super.width = this.nss_width = value;
  }
  /**
   * height of the NineSliceSprite
   * @type {number}
   */
  get height() {
    return super.height;
  }
  set height(value) {
    super.height = this.nss_height = value;
  }
  /**
   * @ignore
   */
  draw(renderer2) {
    let frame = this.current;
    let dx = this.pos.x, dy = this.pos.y;
    let w = frame.width, h = frame.height;
    let frame_offset = frame.offset;
    let g_offset = this.offset;
    if (frame.angle !== 0) {
      renderer2.translate(-dx, -dy);
      renderer2.rotate(frame.angle);
      dx -= h;
      w = frame.height;
      h = frame.width;
    }
    let sx = g_offset.x + frame_offset.x, sy = g_offset.y + frame_offset.y;
    let corner_width = this.insetx || w / 4, corner_height = this.insety || h / 4;
    renderer2.drawImage(
      this.image,
      sx,
      // sx
      sy,
      // sy
      corner_width,
      corner_height,
      // sw,sh
      dx,
      dy,
      // dx,dy
      corner_width,
      corner_height
      // dw,dh
    );
    renderer2.drawImage(
      this.image,
      sx + w - corner_width,
      // sx
      sy,
      // sy
      corner_width,
      corner_height,
      // sw,sh
      dx + this.nss_width - corner_width,
      // dx
      dy,
      // dy
      corner_width,
      corner_height
      // dw,dh
    );
    renderer2.drawImage(
      this.image,
      sx,
      // sx
      sy + h - corner_height,
      // sy
      corner_width,
      corner_height,
      // sw,sh
      dx,
      // dx
      dy + this.nss_height - corner_height,
      // dy
      corner_width,
      corner_height
      // dw,dh
    );
    renderer2.drawImage(
      this.image,
      sx + w - corner_width,
      // sx
      sy + h - corner_height,
      // sy
      corner_width,
      corner_height,
      // sw,sh
      dx + this.nss_width - corner_width,
      //dx
      dy + this.nss_height - corner_height,
      // dy
      corner_width,
      corner_height
      // dw,dh
    );
    let image_center_width = w - (corner_width << 1);
    let image_center_height = h - (corner_height << 1);
    let target_center_width = this.nss_width - (corner_width << 1);
    let target_center_height = this.nss_height - (corner_height << 1);
    renderer2.drawImage(
      this.image,
      sx + corner_width,
      // sx
      sy,
      // sy
      image_center_width,
      // sw
      corner_height,
      // sh
      dx + corner_width,
      // dx
      dy,
      // dy
      target_center_width,
      // dw
      corner_height
      // dh
    );
    renderer2.drawImage(
      this.image,
      sx + corner_width,
      // sx
      sy + h - corner_height,
      // sy
      image_center_width,
      // sw
      corner_height,
      // sh
      dx + corner_width,
      // dx
      dy + this.nss_height - corner_height,
      // dx
      target_center_width,
      // dw
      corner_height
      // dh
    );
    renderer2.drawImage(
      this.image,
      sx,
      // sx
      sy + corner_height,
      // sy
      corner_width,
      // sw
      image_center_height,
      // sh
      dx,
      // dx
      dy + corner_height,
      // dy
      corner_width,
      // dw
      target_center_height
      // dh
    );
    renderer2.drawImage(
      this.image,
      sx + w - corner_width,
      // sx
      sy + corner_height,
      // sy
      corner_width,
      // sw
      image_center_height,
      // sh
      dx + this.nss_width - corner_width,
      // dx
      dy + corner_height,
      // dy
      corner_width,
      // dw
      target_center_height
      // dh
    );
    renderer2.drawImage(
      this.image,
      sx + corner_width,
      // sx
      sy + corner_height,
      // sy
      image_center_width,
      // sw
      image_center_height,
      // sh
      dx + corner_width,
      // dx
      dy + corner_height,
      // dy
      target_center_width,
      // dw
      target_center_height
      // dh
    );
  }
};
var UIBaseElement = class extends Container {
  /**
   *
   * @param {number} x - The x position of the container
   * @param {number} y - The y position of the container
   * @param {number} w - width of the container
   * @param {number} h - height of the container
   */
  constructor(x, y, w, h) {
    super(x, y, w, h);
    this.isClickable = true;
    this.isDraggable = false;
    this.holdThreshold = 250;
    this.isHoldable = false;
    this.hover = false;
    this.released = true;
    this.floating = true;
    this.holdTimeout = -1;
    this.isKinematic = false;
    this.enableChildBoundsUpdate = true;
  }
  /**
   * function callback for the pointerdown event
   * @ignore
   */
  clicked(event2) {
    if (event2.button === 0 && this.isClickable) {
      this.isDirty = true;
      this.released = false;
      if (this.isHoldable) {
        timer.clearTimeout(this.holdTimeout);
        this.holdTimeout = timer.setTimeout(
          () => this.hold(),
          this.holdThreshold,
          false
        );
        this.released = false;
      }
      if (this.isDraggable) {
        this.grabOffset.set(event2.gameX, event2.gameY);
        this.grabOffset.sub(this.pos);
      }
      return this.onClick(event2);
    }
  }
  /**
   * function called when the object is pressed (to be extended)
   * @param {Pointer} event - the event object
   * @returns {boolean} return false if we need to stop propagating the event
   */
  onClick(event2) {
    return true;
  }
  /**
   * function callback for the pointerEnter event
   * @ignore
   */
  enter(event2) {
    this.hover = true;
    this.isDirty = true;
    if (this.isDraggable === true) {
      on(POINTERMOVE, this.pointerMove, this);
      this.grabOffset = pool.pull("Vector2d", 0, 0);
    }
    return this.onOver(event2);
  }
  /**
   * pointermove function
   * @ignore
   */
  pointerMove(event2) {
    if (this.hover === true && this.released === false) {
      this.pos.set(event2.gameX, event2.gameY, this.pos.z);
      this.pos.sub(this.grabOffset);
      this.isDirty = true;
      return this.onMove(event2);
    }
  }
  /**
   * function called when the pointer is moved over the object
   * @param {Pointer} event - the event object
   */
  onMove(event2) {
  }
  /**
   * function called when the pointer is over the object
   * @param {Pointer} event - the event object
   */
  onOver(event2) {
  }
  /**
   * function callback for the pointerLeave event
   * @ignore
   */
  leave(event2) {
    this.hover = false;
    this.isDirty = true;
    if (this.isDraggable === true) {
      off(POINTERMOVE, this.pointerMove);
      pool.push(this.grabOffset);
      this.grabOffset = void 0;
    }
    this.release(event2);
    return this.onOut(event2);
  }
  /**
   * function called when the pointer is leaving the object area
   * @param {Pointer} event - the event object
   */
  onOut(event2) {
  }
  /**
   * function callback for the pointerup event
   * @ignore
   */
  release(event2) {
    if (this.released === false) {
      this.released = true;
      this.isDirty = true;
      timer.clearTimeout(this.holdTimeout);
      this.holdTimeout = -1;
      return this.onRelease(event2);
    }
  }
  /**
   * function called when the object is pressed and released (to be extended)
   * @returns {boolean} return false if we need to stop propagating the event
   */
  onRelease() {
    return true;
  }
  /**
   * function callback for the tap and hold timer event
   * @ignore
   */
  hold() {
    timer.clearTimeout(this.holdTimeout);
    this.holdTimeout = -1;
    this.isDirty = true;
    if (!this.released) {
      this.onHold();
    }
  }
  /**
   * function called when the object is pressed and held<br>
   * to be extended <br>
   */
  onHold() {
  }
  /**
   * function called when added to the game world or a container
   * @ignore
   */
  onActivateEvent() {
    registerPointerEvent("pointerdown", this, (e) => this.clicked(e));
    registerPointerEvent("pointerup", this, (e) => this.release(e));
    registerPointerEvent("pointercancel", this, (e) => this.release(e));
    registerPointerEvent("pointerenter", this, (e) => this.enter(e));
    registerPointerEvent("pointerleave", this, (e) => this.leave(e));
    super.onActivateEvent();
  }
  /**
   * function called when removed from the game world or a container
   * @ignore
   */
  onDeactivateEvent() {
    releasePointerEvent("pointerdown", this);
    releasePointerEvent("pointerup", this);
    releasePointerEvent("pointercancel", this);
    releasePointerEvent("pointerenter", this);
    releasePointerEvent("pointerleave", this);
    timer.clearTimeout(this.holdTimeout);
    this.holdTimeout = -1;
    if (this.isDraggable === true) {
      off(POINTERMOVE, this.pointerMove);
      if (typeof this.grabOffset !== "undefined") {
        pool.push(this.grabOffset);
        this.grabOffset = void 0;
      }
    }
    super.onDeactivateEvent();
  }
};
function setContextStyle(context, style) {
  context.font = style.font;
  context.fillStyle = style.fillStyle.toRGBA();
  context.strokeStyle = style.strokeStyle.toRGBA();
  context.lineWidth = style.lineWidth;
  context.textAlign = style.textAlign;
  context.textBaseline = style.textBaseline;
}
var runits = ["ex", "em", "pt", "px"];
var toPX = [12, 24, 0.75, 1];
var Text = class extends Renderable {
  /**
   * @param {number} x - position of the text object
   * @param {number} y - position of the text object
   * @param {object} settings - the text configuration
   * @param {string} settings.font - a CSS family font name
   * @param {number|string} settings.size - size, or size + suffix (px, em, pt)
   * @param {Color|string} [settings.fillStyle="#000000"] - a CSS color value
   * @param {Color|string} [settings.strokeStyle="#000000"] - a CSS color value
   * @param {number} [settings.lineWidth=0] - line width, in pixels, when drawing stroke
   * @param {string} [settings.textAlign="left"] - horizontal text alignment
   * @param {string} [settings.textBaseline="top"] - the text baseline
   * @param {number} [settings.lineHeight=1.0] - line spacing height
   * @param {Vector2d} [settings.anchorPoint={x:0.0, y:0.0}] - anchor point to draw the text at
   * @param {number} [settings.wordWrapWidth] - the maximum length in CSS pixel for a single segment of text
   * @param {(string|string[])} [settings.text=""] - a string, or an array of strings
   * @example
   * let font = new me.Text(0, 0, {font: "Arial", size: 8, fillStyle: this.color});
   */
  constructor(x, y, settings) {
    super(x, y, settings.width || 0, settings.height || 0);
    this.fillStyle = pool.pull("Color", 0, 0, 0);
    this.strokeStyle = pool.pull("Color", 0, 0, 0);
    this.lineWidth = 0;
    this.textAlign = "left";
    this.textBaseline = "top";
    this.lineHeight = 1;
    this.wordWrapWidth = -1;
    this.fontSize = 10;
    this._text = [];
    this.onResetEvent(x, y, settings);
  }
  /** @ignore */
  onResetEvent(x, y, settings) {
    if (typeof this.fillStyle === "undefined") {
      this.fillStyle = pool.pull("Color", 0, 0, 0);
    }
    if (typeof this.strokeStyle === "undefined") {
      this.strokeStyle = pool.pull("Color", 0, 0, 0);
    }
    if (typeof settings.fillStyle !== "undefined") {
      if (settings.fillStyle instanceof Color) {
        this.fillStyle.copy(settings.fillStyle);
      } else {
        this.fillStyle.parseCSS(settings.fillStyle);
      }
    }
    if (typeof settings.strokeStyle !== "undefined") {
      if (settings.strokeStyle instanceof Color) {
        this.strokeStyle.copy(settings.strokeStyle);
      } else {
        this.strokeStyle.parseCSS(settings.strokeStyle);
      }
    }
    this.lineWidth = settings.lineWidth || 0;
    this.textAlign = settings.textAlign || "left";
    this.textBaseline = settings.textBaseline || "top";
    this.lineHeight = settings.lineHeight || 1;
    this.wordWrapWidth = settings.wordWrapWidth || -1;
    this.fontSize = 10;
    if (typeof settings.anchorPoint !== "undefined") {
      this.anchorPoint.setV(settings.anchorPoint);
    } else {
      this.anchorPoint.set(0, 0);
    }
    if (typeof settings.floating !== "undefined") {
      this.floating = !!settings.floating;
    }
    this.setFont(settings.font, settings.size);
    if (settings.bold === true) {
      this.bold();
    }
    if (settings.italic === true) {
      this.italic();
    }
    this.canvasTexture = pool.pull("CanvasRenderTarget", 2, 2, { offscreenCanvas: false });
    this.metrics = new TextMetrics(this);
    this.setText(settings.text);
  }
  /**
   * make the font bold
   * @returns {Text} this object for chaining
   */
  bold() {
    this.font = "bold " + this.font;
    this.isDirty = true;
    return this;
  }
  /**
   * make the font italic
   * @returns {Text} this object for chaining
   */
  italic() {
    this.font = "italic " + this.font;
    this.isDirty = true;
    return this;
  }
  /**
   * set the font family and size
   * @param {string} font - a CSS font name
   * @param {number|string} [size=10] - size in px, or size + suffix (px, em, pt)
   * @returns {Text} this object for chaining
   * @example
   * font.setFont("Arial", 20);
   * font.setFont("Arial", "1.5em");
   */
  setFont(font, size = 10) {
    let font_names = font.split(",").map((value) => {
      value = value.trim();
      return !/(^".*"$)|(^'.*'$)/.test(value) ? '"' + value + '"' : value;
    });
    if (typeof size === "number") {
      this.fontSize = size;
      size += "px";
    } else {
      let CSSval = size.match(/([-+]?[\d.]*)(.*)/);
      this.fontSize = parseFloat(CSSval[1]);
      if (CSSval[2]) {
        this.fontSize *= toPX[runits.indexOf(CSSval[2])];
      } else {
        size += "px";
      }
    }
    this.height = this.fontSize;
    this.font = size + " " + font_names.join(",");
    this.isDirty = true;
    return this;
  }
  /**
   * change the text to be displayed
   * @param {number|string|string[]} value - a string, or an array of strings
   * @returns {Text} this object for chaining
   */
  setText(value = "") {
    let bounds = this.getBounds();
    if (this._text.toString() !== value.toString()) {
      if (!Array.isArray(value)) {
        this._text = ("" + value).split("\n");
      } else {
        this._text = value;
      }
    }
    if (this._text.length > 0 && this.wordWrapWidth > 0) {
      this._text = this.metrics.wordWrap(this._text, this.wordWrapWidth, this.canvasTexture.context);
    }
    bounds.addBounds(this.metrics.measureText(this._text, this.canvasTexture.context), true);
    let width = Math.ceil(this.metrics.width), height = Math.ceil(this.metrics.height);
    if (renderer.WebGLVersion === 1) {
      width = nextPowerOfTwo(this.metrics.width);
      height = nextPowerOfTwo(this.metrics.height);
    }
    this.canvasTexture.invalidate(renderer);
    if (this.canvasTexture.width < width || this.canvasTexture.height < height) {
      this.canvasTexture.resize(width, height);
    }
    this.canvasTexture.clear();
    this._drawFont(this.canvasTexture.context, this._text, this.pos.x - this.metrics.x, this.pos.y - this.metrics.y);
    this.isDirty = true;
    return this;
  }
  /**
   * measure the given text size in pixels
   * @param {CanvasRenderer|WebGLRenderer} renderer - reference to the active renderer
   * @param {string} [text] - the text to be measured
   * @returns {TextMetrics} a TextMetrics object defining the dimensions of the given piece of text
   */
  measureText(renderer2, text = this._text) {
    return this.metrics.measureText(text, this.canvasTexture.context);
  }
  /**
   * draw a text at the specified coord
   * @param {CanvasRenderer|WebGLRenderer} renderer - Reference to the destination renderer instance
   * @param {string} [text]
   * @param {number} [x]
   * @param {number} [y]
   */
  draw(renderer2, text, x = this.pos.x, y = this.pos.y) {
    if (typeof this.ancestor === "undefined") {
      if (this.pos.x !== x || this.pos.y !== y) {
        this.pos.x = x;
        this.pos.y = y;
        this.isDirty = true;
      }
      this.setText(text);
      renderer2.save();
      renderer2.setGlobalAlpha(renderer2.globalAlpha() * this.getOpacity());
    }
    x = this.metrics.x;
    y = this.metrics.y;
    if (renderer2.settings.subPixel === false) {
      x = ~~x;
      y = ~~y;
    }
    renderer2.drawImage(this.canvasTexture.canvas, x, y);
    if (typeof this.ancestor === "undefined") {
      renderer2.restore();
    }
  }
  /**
   * draw a stroke text at the specified coord, as defined by the `lineWidth` and `fillStroke` properties.
   * @deprecated since 15.0.0
   * @param {CanvasRenderer|WebGLRenderer} renderer - Reference to the destination renderer instance
   * @param {string} text
   * @param {number} x
   * @param {number} y
   */
  drawStroke(renderer2, text, x, y) {
    this.draw(renderer2, text, x, y);
  }
  /**
   * @ignore
   */
  _drawFont(context, text, x, y) {
    setContextStyle(context, this);
    for (let i = 0; i < text.length; i++) {
      const string = text[i].trimEnd();
      if (this.fillStyle.alpha > 0) {
        context.fillText(string, x, y);
      }
      if (this.lineWidth > 0 && this.strokeStyle.alpha > 0) {
        context.strokeText(string, x, y);
      }
      y += this.metrics.lineHeight();
    }
    return this.metrics;
  }
  /**
   * Destroy function
   * @ignore
   */
  destroy() {
    if (typeof renderer.gl !== "undefined") {
      renderer.setCompositor("quad");
      renderer.currentCompositor.deleteTexture2D(renderer.currentCompositor.getTexture2D(this.glTextureUnit));
      this.glTextureUnit = void 0;
    }
    renderer.cache.delete(this.canvasTexture.canvas);
    pool.push(this.canvasTexture);
    this.canvasTexture = void 0;
    pool.push(this.fillStyle);
    pool.push(this.strokeStyle);
    this.fillStyle = this.strokeStyle = void 0;
    this.metrics = void 0;
    this._text.length = 0;
    super.destroy();
  }
};
var TextMetrics = class extends Bounds {
  /**
   * @param {Text|BitmapText} ancestor - the parent object that contains this TextMetrics object
   */
  constructor(ancestor) {
    super();
    this.ancestor = ancestor;
    this.setMinMax(0, 0, 0, 0);
  }
  /**
   * Returns the height of a segment of inline text in CSS pixels.
   * @returns {number} the height of a segment of inline text in CSS pixels.
   */
  lineHeight() {
    if (this.ancestor instanceof Text) {
      return this.ancestor.fontSize * this.ancestor.lineHeight;
    } else {
      return this.ancestor.fontData.capHeight * this.ancestor.lineHeight * this.ancestor.fontScale.y;
    }
  }
  /**
   * Returns the width of the given segment of inline text in CSS pixels.
   * @param {string} text - the text to be measured
   * @param {CanvasRenderingContext2D} [context] - reference to an active 2d context for canvas rendering
   * @returns {number} the width of the given segment of inline text in CSS pixels.
   */
  lineWidth(text, context) {
    if (this.ancestor instanceof Text) {
      return context.measureText(text).width;
    } else {
      let characters = text.split("");
      const charactersLength = characters.length;
      let width = 0;
      let lastGlyph = null;
      for (let i = 0; i < charactersLength; i++) {
        let ch = characters[i].charCodeAt(0);
        let glyph = this.ancestor.fontData.glyphs[ch];
        if (typeof glyph !== "undefined") {
          let kerning = lastGlyph && lastGlyph.kerning ? lastGlyph.getKerning(ch) : 0;
          width += (glyph.xadvance + kerning) * this.ancestor.fontScale.x;
          lastGlyph = glyph;
        }
      }
      return width;
    }
  }
  /**
   * measure the given text size in CSS pixels
   * @param {string} text - the text to be measured
   * @param {CanvasRenderingContext2D} [context] - reference to an active 2d context for canvas rendering
   * @returns {TextMetrics} this
   */
  measureText(text, context) {
    let strings;
    if (!Array.isArray(text)) {
      strings = ("" + text).split("\n");
    } else {
      strings = text;
    }
    if (typeof context !== "undefined") {
      context.save();
      setContextStyle(context, this.ancestor);
    }
    this.width = this.height = 0;
    for (let i = 0; i < strings.length; i++) {
      this.width = Math.max(this.lineWidth(strings[i].trimEnd(), context), this.width);
      this.height += this.lineHeight();
    }
    this.width = Math.ceil(this.width);
    this.height = Math.ceil(this.height);
    this.x = Math.floor(this.ancestor.textAlign === "right" ? this.ancestor.pos.x - this.width : this.ancestor.textAlign === "center" ? this.ancestor.pos.x - this.width / 2 : this.ancestor.pos.x);
    this.y = Math.floor(this.ancestor.textBaseline.search(/^(top|hanging)$/) === 0 ? this.ancestor.pos.y : this.ancestor.textBaseline === "middle" ? this.ancestor.pos.y - this.lineHeight() / 2 : this.ancestor.pos.y - this.lineHeight());
    if (typeof context !== "undefined") {
      context.restore();
    }
    return this;
  }
  /**
   * wrap the given text based on the given width
   * @param {string|string[]} text - the text to be wrapped
   * @param {number} width - maximum width of one segment of text in css pixel
   * @param {CanvasRenderingContext2D} [context] - reference to an active 2d context for canvas rendering
   * @returns {string[]} an array of string representing wrapped text
   */
  wordWrap(text, width, context) {
    let words;
    let currentLine = "";
    let output = [];
    if (Array.isArray(text)) {
      text = text.join(" ");
    }
    words = text.replace(/[\r\n]+/g, " ").split(" ");
    if (typeof context !== "undefined") {
      context.save();
      setContextStyle(context, this.ancestor);
    }
    for (let i = 0; i < words.length; i++) {
      let word = words[i];
      let lineWidth = this.lineWidth(currentLine + word + " ", context);
      if (lineWidth < width) {
        currentLine += word + " ";
      } else {
        output.push(currentLine + "\n");
        currentLine = word + " ";
      }
    }
    output.push(currentLine);
    if (typeof context !== "undefined") {
      context.restore();
    }
    return output;
  }
};
var BitmapText = class extends Renderable {
  /**
   * @param {number} x - position of the text object
   * @param {number} y - position of the text object
   * @param {object} settings - the text configuration
   * @param {string|Image} settings.font - a font name to identify the corresponing source image
   * @param {string} [settings.fontData=settings.font] - the bitmap font data corresponding name, or the bitmap font data itself
   * @param {number} [settings.size] - size a scaling ratio
   * @param {Color|string} [settings.fillStyle] - a CSS color value used to tint the bitmapText (@see BitmapText.tint)
   * @param {number} [settings.lineWidth=1] - line width, in pixels, when drawing stroke
   * @param {string} [settings.textAlign="left"] - horizontal text alignment
   * @param {string} [settings.textBaseline="top"] - the text baseline
   * @param {number} [settings.lineHeight=1.0] - line spacing height
   * @param {Vector2d} [settings.anchorPoint={x:0.0, y:0.0}] - anchor point to draw the text at
   * @param {number} [settings.wordWrapWidth] - the maximum length in CSS pixel for a single segment of text
   * @param {(string|string[])} [settings.text] - a string, or an array of strings
   * @example
   * // Use me.loader.preload or me.loader.load to load assets
   * me.loader.preload([
   *     { name: "arial", type: "binary" src: "data/font/arial.fnt" },
   *     { name: "arial", type: "image" src: "data/font/arial.png" },
   * ])
   * // Then create an instance of your bitmap font:
   * let myFont = new me.BitmapText(x, y, {font:"arial", text:"Hello"});
   * // two possibilities for using "myFont"
   * // either call the draw function from your Renderable draw function
   * myFont.draw(renderer, "Hello!", 0, 0);
   * // or just add it to the word container
   * me.game.world.addChild(myFont);
   */
  constructor(x, y, settings) {
    super(x, y, settings.width || 0, settings.height || 0);
    this.textAlign = settings.textAlign || "left";
    this.textBaseline = settings.textBaseline || "top";
    this.lineHeight = settings.lineHeight || 1;
    this.wordWrapWidth = settings.wordWrapWidth || -1;
    this._text = [];
    this.fontScale = pool.pull("Vector2d", 1, 1);
    this.fontImage = typeof settings.font === "object" ? settings.font : getImage(settings.font);
    if (typeof settings.fontData !== "string") {
      this.fontData = pool.pull("BitmapTextData", getBinary(settings.font));
    } else {
      this.fontData = pool.pull(
        "BitmapTextData",
        // if starting/includes "info face" the whole data string was passed as parameter
        settings.fontData.includes("info face") ? settings.fontData : getBinary(settings.fontData)
      );
    }
    if (typeof settings.floating !== "undefined") {
      this.floating = !!settings.floating;
    }
    if (typeof settings.fillStyle !== "undefined") {
      this.fillStyle = settings.fillStyle;
    }
    if (typeof settings.anchorPoint !== "undefined") {
      this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
    } else {
      this.anchorPoint.set(0, 0);
    }
    this.metrics = new TextMetrics(this);
    if (typeof settings.size === "number" && settings.size !== 1) {
      this.resize(settings.size);
    }
    this.setText(settings.text);
  }
  /**
   * change the font settings
   * @param {string} textAlign - ("left", "center", "right")
   * @param {number} [scale]
   * @returns {BitmapText} this object for chaining
   */
  set(textAlign, scale2) {
    this.textAlign = textAlign;
    if (scale2) {
      this.resize(scale2);
    }
    this.isDirty = true;
    return this;
  }
  /**
   * change the text to be displayed
   * @param {number|string|string[]} value - a string, or an array of strings
   * @returns {BitmapText} this object for chaining
   */
  setText(value = "") {
    if (this._text.toString() !== value.toString()) {
      if (!Array.isArray(value)) {
        this._text = ("" + value).split("\n");
      } else {
        this._text = value;
      }
      this.isDirty = true;
    }
    if (this._text.length > 0 && this.wordWrapWidth > 0) {
      this._text = this.metrics.wordWrap(this._text, this.wordWrapWidth);
    }
    this.updateBounds();
    return this;
  }
  /**
   * update the bounding box for this Bitmap Text.
   * @param {boolean} [absolute=true] - update the bounds size and position in (world) absolute coordinates
   * @returns {Bounds} this Bitmap Text bounding box Rectangle object
   */
  updateBounds(absolute = true) {
    let bounds = this.getBounds();
    bounds.clear();
    if (typeof this.metrics !== "undefined") {
      let ax, ay;
      bounds.addBounds(this.metrics.measureText(this._text));
      switch (this.textAlign) {
        case "right":
          ax = this.metrics.width * 1;
          break;
        case "center":
          ax = this.metrics.width * 0.5;
          break;
        default:
          ax = 0;
          break;
      }
      switch (this.textBaseline) {
        case "middle":
          ay = this.metrics.height * 0.5;
          break;
        case "ideographic":
        case "alphabetic":
        case "bottom":
          ay = this.metrics.height * 1;
          break;
        default:
          ay = 0;
          break;
      }
      bounds.translate(ax, ay);
    }
    if (absolute === true) {
      if (typeof this.ancestor !== "undefined" && typeof this.ancestor.getAbsolutePosition === "function" && this.floating !== true) {
        bounds.translate(this.ancestor.getAbsolutePosition());
      }
    }
    return bounds;
  }
  /**
   * defines the color used to tint the bitmap text
   * @public
   * @type {Color}
   * @see Renderable#tint
   */
  get fillStyle() {
    return this.tint;
  }
  set fillStyle(value) {
    if (value instanceof Color) {
      this.tint.copy(value);
    } else {
      this.tint.parseCSS(value);
    }
  }
  /**
   * change the font display size
   * @param {number} scale - ratio
   * @returns {BitmapText} this object for chaining
   */
  resize(scale2) {
    this.fontScale.set(scale2, scale2);
    this.updateBounds();
    this.isDirty = true;
    return this;
  }
  /**
   * measure the given text size in pixels
   * @param {string} [text]
   * @returns {TextMetrics} a TextMetrics object with two properties: `width` and `height`, defining the output dimensions
   */
  measureText(text = this._text) {
    return this.metrics.measureText(text);
  }
  /**
   * draw the bitmap font
   * @param {CanvasRenderer|WebGLRenderer} renderer - Reference to the destination renderer instance
   * @param {string} [text]
   * @param {number} [x]
   * @param {number} [y]
   */
  draw(renderer2, text, x, y) {
    let _alpha = renderer2.globalAlpha();
    if (typeof this.ancestor === "undefined") {
      this.setText(text);
      renderer2.setGlobalAlpha(_alpha * this.getOpacity());
    } else {
      x = this.pos.x;
      y = this.pos.y;
    }
    let lX = x;
    let stringHeight = this.metrics.lineHeight();
    let maxWidth = 0;
    for (let i = 0; i < this._text.length; i++) {
      x = lX;
      const string = this._text[i].trimEnd();
      let stringWidth = this.metrics.lineWidth(string);
      switch (this.textAlign) {
        case "right":
          x -= stringWidth;
          break;
        case "center":
          x -= stringWidth * 0.5;
          break;
        default:
          break;
      }
      switch (this.textBaseline) {
        case "middle":
          y -= stringHeight * 0.5;
          break;
        case "ideographic":
        case "alphabetic":
        case "bottom":
          y -= stringHeight;
          break;
        default:
          break;
      }
      if (this.isDirty === true && typeof this.ancestor === "undefined") {
        if (i === 0) {
          this.pos.y = y;
        }
        if (maxWidth < stringWidth) {
          maxWidth = stringWidth;
          this.pos.x = x;
        }
      }
      let lastGlyph = null;
      for (let c = 0, len = string.length; c < len; c++) {
        let ch = string.charCodeAt(c);
        let glyph = this.fontData.glyphs[ch];
        if (typeof glyph !== "undefined") {
          let glyphWidth = glyph.width;
          let glyphHeight = glyph.height;
          let kerning = lastGlyph && lastGlyph.kerning ? lastGlyph.getKerning(ch) : 0;
          let scaleX = this.fontScale.x;
          let scaleY = this.fontScale.y;
          if (glyphWidth !== 0 && glyphHeight !== 0) {
            renderer2.drawImage(
              this.fontImage,
              glyph.x,
              glyph.y,
              glyphWidth,
              glyphHeight,
              x + glyph.xoffset * scaleX,
              y + glyph.yoffset * scaleY,
              glyphWidth * scaleX,
              glyphHeight * scaleY
            );
          }
          x += (glyph.xadvance + kerning) * scaleX;
          lastGlyph = glyph;
        } else {
          console.warn("BitmapText: no defined Glyph in for " + String.fromCharCode(ch));
        }
      }
      y += stringHeight;
    }
    if (typeof this.ancestor === "undefined") {
      renderer2.setGlobalAlpha(_alpha);
    }
    this.isDirty = false;
  }
  /**
   * Destroy function
   * @ignore
   */
  destroy() {
    pool.push(this.fontScale);
    this.fontScale = void 0;
    pool.push(this.fontData);
    this.fontData = void 0;
    this._text.length = 0;
    this.metrics = void 0;
    super.destroy();
  }
};
var UITextButton = class extends UIBaseElement {
  /**
   * A Bitmap Text Button with an outlined background border, filled with background color.
   * It uses a RoundRect as background and changes the background color on hovering over.
   * The background will be drawn with 0.5 opacity, so that the background of the button is
   * slightly shining through.
   * @param {number} x - x pos of the button
   * @param {number} y - y pos of the button
   * @param {string} [settings.font] - The name of the BitmapText font to use
   * @param {number} [settings.size=1] - The scale factor of the BitmapText
   * @param {string} [settings.text] - The text to display
   * @param {string} [settings.bindKey] - The key to bind the action to (default: none)
   * @param {string} [settings.hoverOffColor="#00aa0080"] - The css value of a color to be used if the pointer is not hovering over the button
   * @param {string} [settings.hoverOnColor="#00ff00ff"] - The css value of a color to be used if the pointer hovers over the button
   * @param {string} [settings.borderStrokeColor="#000000"] - The css value of a color to be used to draw the border
   * @param {string} [settings.fillStyle] - The css value of a tint color to be used to tint the BitmapText
   * @param {string} [settings.textAlign="center"] - horizontal text alignment
   * @param {string} [settings.textBaseline="middle"] - the text baseline
   * @param {number} [settings.borderWidth] - Width of the button
   * @param {number} [settings.borderHeight] - Height of the button
   * @example
   * // Create a new Button
   * class PlayButton extends UITextButton {
   *      constructor(x,y) {
   *          super(x,y, {
   *              font: 'my-font',
   *              text: 'Play',
   *              // if you omit the next two, size is calculated by the size of the text
   *              borderWidth: 200,
   *              borderHeight: 20,
   *              backgroundColor: '#00aa0080',
   *              hoverColor: '#00ff00ff'
   *          });
   *      }
   *
   *      onClick(){
   *          state.change(state.PLAY);
   *      }
   * }
   *
   * world.addChild(new PlayButton(15,200));
   */
  constructor(x, y, settings) {
    super(x, y);
    this.bindKey = settings.bindKey || -1;
    this.hoverOffColor = settings.hoverOffColor || settings.backgroundColor || "#00aa0080";
    this.hoverOnColor = settings.hoverOnColor || settings.hoverColor || "#00ff00ff";
    this.borderStrokeColor = settings.borderStrokeColor || "#000000";
    this.textAlign = settings.textAlign = settings.textAlign || "center";
    this.textBaseline = settings.textBaseline = settings.textBaseline || "middle";
    this.bitmapText = new BitmapText(0, 0, settings);
    this.dimensions = this.bitmapText.measureText();
    settings.borderWidth = settings.borderWidth || this.dimensions.width + 16;
    settings.borderHeight = settings.borderHeight || this.dimensions.height + 16;
    this.border = new RoundRect(x, y, settings.borderWidth, settings.borderHeight);
    this.resize(
      this.border.getBounds().width,
      this.border.getBounds().height
    );
    this.bitmapText.pos.set(this.width / 2, this.height / 2);
    this.addChild(this.bitmapText);
  }
  draw(renderer2) {
    if (this.hover === true) {
      renderer2.setColor(this.hoverOnColor);
    } else {
      renderer2.setColor(this.hoverOffColor);
    }
    renderer2.fill(this.border);
    renderer2.setColor(this.borderStrokeColor);
    renderer2.stroke(this.border);
    super.draw(renderer2);
  }
};
var UISpriteElement = class extends Sprite {
  /**
   * @param {number} x - the x coordinate of the UISpriteElement Object
   * @param {number} y - the y coordinate of the UISpriteElement Object
   * @param {object} settings - See {@link Sprite}
   * @example
   * // create a basic GUI Object
   * class myButton extends UISpriteElement {
   *    constructor(x, y) {
   *       // call the UISpriteElement parent constructor
   *       super(x, y, {
   *          image: "button",
   *          framewidth: 100,
   *          frameheight: 50
   *       });
   *    }
   *
   *    // output something in the console
   *    // when the object is clicked
   *    onClick(event) {
   *       console.log("clicked!");
   *       // don't propagate the event
   *       return false;
   *    }
   * });
   *
   * // add the object at pos (10,10)
   * world.addChild(new myButton(10,10));
   */
  constructor(x, y, settings) {
    super(x, y, settings);
    this.isClickable = true;
    this.holdThreshold = 250;
    this.isHoldable = false;
    this.hover = false;
    this.holdTimeout = -1;
    this.released = true;
    this.floating = true;
    this.isKinematic = false;
  }
  /**
   * function callback for the pointerdown event
   * @ignore
   */
  clicked(event2) {
    if (event2.button === 0 && this.isClickable) {
      this.isDirty = true;
      this.released = false;
      if (this.isHoldable) {
        timer.clearTimeout(this.holdTimeout);
        this.holdTimeout = timer.setTimeout(() => this.hold(), this.holdThreshold, false);
        this.released = false;
      }
      return this.onClick(event2);
    }
  }
  /**
   * function called when the object is pressed (to be extended)
   * @param {Pointer} event - the event object
   * @returns {boolean} return false if we need to stop propagating the event
   */
  onClick(event2) {
    return false;
  }
  /**
   * function callback for the pointerEnter event
   * @ignore
   */
  enter(event2) {
    this.hover = true;
    this.isDirty = true;
    return this.onOver(event2);
  }
  /**
   * function called when the pointer is over the object
   * @param {Pointer} event - the event object
   */
  onOver(event2) {
  }
  /**
   * function callback for the pointerLeave event
   * @ignore
   */
  leave(event2) {
    this.hover = false;
    this.isDirty = true;
    this.release(event2);
    return this.onOut(event2);
  }
  /**
   * function called when the pointer is leaving the object area
   * @param {Pointer} event - the event object
   */
  onOut(event2) {
  }
  /**
   * function callback for the pointerup event
   * @ignore
   */
  release(event2) {
    if (this.released === false) {
      this.released = true;
      this.isDirty = true;
      timer.clearTimeout(this.holdTimeout);
      this.holdTimeout = -1;
      return this.onRelease(event2);
    }
  }
  /**
   * function called when the object is pressed and released (to be extended)
   * @returns {boolean} return false if we need to stop propagating the event
   */
  onRelease() {
    return false;
  }
  /**
   * function callback for the tap and hold timer event
   * @ignore
   */
  hold() {
    timer.clearTimeout(this.holdTimeout);
    this.holdTimeout = -1;
    this.isDirty = true;
    if (!this.released) {
      this.onHold();
    }
  }
  /**
   * function called when the object is pressed and held<br>
   * to be extended <br>
   */
  onHold() {
  }
  /**
   * function called when added to the game world or a container
   * @ignore
   */
  onActivateEvent() {
    registerPointerEvent("pointerdown", this, (e) => this.clicked(e));
    registerPointerEvent("pointerup", this, (e) => this.release(e));
    registerPointerEvent("pointercancel", this, (e) => this.release(e));
    registerPointerEvent("pointerenter", this, (e) => this.enter(e));
    registerPointerEvent("pointerleave", this, (e) => this.leave(e));
  }
  /**
   * function called when removed from the game world or a container
   * @ignore
   */
  onDeactivateEvent() {
    releasePointerEvent("pointerdown", this);
    releasePointerEvent("pointerup", this);
    releasePointerEvent("pointercancel", this);
    releasePointerEvent("pointerenter", this);
    releasePointerEvent("pointerleave", this);
    timer.clearTimeout(this.holdTimeout);
    this.holdTimeout = -1;
  }
};
var Collectable = class extends Sprite {
  /**
   * @param {number} x - the x coordinates of the collectable
   * @param {number} y - the y coordinates of the collectable
   * @param {object} settings - See {@link Sprite}
   */
  constructor(x, y, settings) {
    super(x, y, settings);
    this.name = settings.name;
    this.type = settings.type;
    this.id = settings.id;
    let shape = settings.shapes;
    if (typeof shape === "undefined") {
      shape = pool.pull("Polygon", 0, 0, [
        pool.pull("Vector2d", 0, 0),
        pool.pull("Vector2d", this.width, 0),
        pool.pull("Vector2d", this.width, this.height)
      ]);
    }
    this.body = new Body(this, shape);
    this.body.collisionType = collision.types.COLLECTABLE_OBJECT;
    this.body.setCollisionMask(collision.types.PLAYER_OBJECT);
    this.body.setStatic(true);
    if (settings.anchorPoint) {
      this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
    } else {
      this.anchorPoint.set(0, 0);
    }
  }
};
var Trigger = class extends Renderable {
  /**
   * @param {number} x - the x coordinates of the trigger area
   * @param {number} y - the y coordinates of the trigger area
   * @param {number} [settings.width] - width of the trigger area
   * @param {number} [settings.height] - height of the trigger area
   * @param {Rect[]|Polygon[]|Line[]|Ellipse[]} [settings.shapes] - collision shape(s) that will trigger the event
   * @param {string} [settings.duration] - Fade duration (in ms)
   * @param {string|Color} [settings.color] - Fade color
   * @param {string} [settings.event="level"] - the type of event to trigger (only "level" supported for now)
   * @param {string} [settings.to] - level to load if level trigger
   * @param {string|Container} [settings.container] - Target container. See {@link level.load}
   * @param {Function} [settings.onLoaded] - Level loaded callback. See {@link level.load}
   * @param {boolean} [settings.flatten] - Flatten all objects into the target container. See {@link level.load}
   * @param {boolean} [settings.setViewportBounds] - Resize the viewport to match the level. See {@link level.load}
   * @example
   * world.addChild(new me.Trigger(
   *     x, y, {
   *         shapes: [new me.Rect(0, 0, 100, 100)],
   *         "duration" : 250,
   *         "color" : "#000",
   *         "to" : "mymap2"
   *     }
   * ));
   */
  constructor(x, y, settings) {
    super(x, y, settings.width || 0, settings.height || 0);
    this.anchorPoint.set(0, 0);
    this.fade = settings.fade;
    this.duration = settings.duration;
    this.fading = false;
    this.name = "Trigger";
    this.type = settings.type;
    this.id = settings.id;
    this.gotolevel = settings.to;
    this.triggerSettings = {
      // the default (and only for now) action
      event: "level"
    };
    ["type", "container", "onLoaded", "flatten", "setViewportBounds", "to"].forEach((property) => {
      if (typeof settings[property] !== "undefined") {
        this.triggerSettings[property] = settings[property];
      }
    });
    let shape = settings.shapes;
    if (typeof shape === "undefined") {
      shape = pool.pull("Polygon", 0, 0, [
        pool.pull("Vector2d", 0, 0),
        pool.pull("Vector2d", this.width, 0),
        pool.pull("Vector2d", this.width, this.height)
      ]);
    }
    this.body = new Body(this, shape);
    this.body.collisionType = collision.types.ACTION_OBJECT;
    this.body.setCollisionMask(collision.types.PLAYER_OBJECT);
    this.body.setStatic(true);
    this.resize(this.body.getBounds().width, this.body.getBounds().height);
  }
  /**
   * @ignore
   */
  getTriggerSettings() {
    let world = this.ancestor.getRootAncestor();
    if (typeof this.triggerSettings.container === "string") {
      this.triggerSettings.container = world.getChildByName(this.triggerSettings.container)[0];
    }
    return this.triggerSettings;
  }
  /**
   * @ignore
   */
  onFadeComplete() {
    let world = this.ancestor.getRootAncestor();
    level.load(this.gotolevel, this.getTriggerSettings());
    world.app.viewport.fadeOut(this.fade, this.duration);
  }
  /**
   * trigger this event
   * @name triggerEvent
   * @memberof Trigger
   * @protected
   */
  triggerEvent() {
    let triggerSettings = this.getTriggerSettings();
    let world = this.ancestor.getRootAncestor();
    if (triggerSettings.event === "level") {
      this.gotolevel = triggerSettings.to;
      if (this.fade && this.duration) {
        if (!this.fading) {
          this.fading = true;
          world.app.viewport.fadeIn(
            this.fade,
            this.duration,
            () => this.onFadeComplete()
          );
        }
      } else {
        level.load(this.gotolevel, triggerSettings);
      }
    } else {
      throw new Error("Trigger invalid type");
    }
  }
  /**
   * onCollision callback, triggered in case of collision with this trigger
   * @name onCollision
   * @memberof Trigger
   * @param {ResponseObject} response - the collision response object
   * @param {Renderable} other - the other renderable touching this one (a reference to response.a or response.b)
   * @returns {boolean} true if the object should respond to the collision (its position and velocity will be corrected)
   */
  onCollision(response, other) {
    if (this.name === "Trigger") {
      this.triggerEvent.apply(this);
    }
    return false;
  }
};
function createGradient(light) {
  let context = light.texture.context;
  let x1 = light.texture.width / 2, y1 = light.texture.height / 2;
  let radiusX = light.radiusX, radiusY = light.radiusY;
  let scaleX, scaleY, invScaleX, invScaleY;
  let gradient;
  light.texture.clear();
  if (radiusX >= radiusY) {
    scaleX = 1;
    invScaleX = 1;
    scaleY = radiusY / radiusX;
    invScaleY = radiusX / radiusY;
    gradient = context.createRadialGradient(x1, y1 * invScaleY, 0, x1, radiusY * invScaleY, radiusX);
  } else {
    scaleY = 1;
    invScaleY = 1;
    scaleX = radiusX / radiusY;
    invScaleX = radiusY / radiusX;
    gradient = context.createRadialGradient(x1 * invScaleX, y1, 0, x1 * invScaleX, y1, radiusY);
  }
  gradient.addColorStop(0, light.color.toRGBA(light.intensity));
  gradient.addColorStop(1, light.color.toRGBA(0));
  context.fillStyle = gradient;
  context.setTransform(scaleX, 0, 0, scaleY, 0, 0);
  context.fillRect(0, 0, light.texture.width * invScaleX, light.texture.height * invScaleY);
}
var Light2d = class extends Renderable {
  /**
  * @param {number} x - The horizontal position of the light.
  * @param {number} y - The vertical position of the light.
  * @param {number} radiusX - The horizontal radius of the light.
  * @param {number} [radiusY=radiusX] - The vertical radius of the light.
  * @param {Color|string} [color="#FFF"] - the color of the light
  * @param {number} [intensity=0.7] - The intensity of the light.
  */
  constructor(x, y, radiusX, radiusY = radiusX, color = "#FFF", intensity = 0.7) {
    super(x, y, radiusX * 2, radiusY * 2);
    this.color = pool.pull("Color").parseCSS(color);
    this.radiusX = radiusX;
    this.radiusY = radiusY;
    this.intensity = intensity;
    this.blendMode = "lighter";
    this.visibleArea = pool.pull("Ellipse", this.centerX, this.centerY, this.width, this.height);
    this.texture = pool.pull("CanvasRenderTarget", this.width, this.height, { offscreenCanvas: false });
    this.anchorPoint.set(0, 0);
    createGradient(this);
  }
  /**
   * returns a geometry representing the visible area of this light
   * @name getVisibleArea
   * @memberof Light2d
   * @returns {Ellipse} the light visible mask
   */
  getVisibleArea() {
    return this.visibleArea.setShape(this.getBounds().centerX, this.getBounds().centerY, this.width, this.height);
  }
  /**
   * update function
   * @param {number} dt - time since the last update in milliseconds.
   * @returns {boolean} true if dirty
   */
  update(dt) {
    return true;
  }
  /**
   * draw this Light2d (automatically called by melonJS)
   * @name draw
   * @memberof Light2d
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
    renderer2.drawImage(this.texture.canvas, this.getBounds().x, this.getBounds().y);
  }
  /**
   * Destroy function<br>
   * @ignore
   */
  destroy() {
    pool.push(this.color);
    this.color = void 0;
    pool.push(this.texture);
    this.texture = void 0;
    pool.push(this.visibleArea);
    this.visibleArea = void 0;
    super.destroy();
  }
};
var LOG2_PAGE_SIZE = 9;
var PAGE_SIZE = 1 << LOG2_PAGE_SIZE;
var Glyph = class {
  /**
   * @ignore
   */
  constructor() {
    this.id = 0;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.u = 0;
    this.v = 0;
    this.u2 = 0;
    this.v2 = 0;
    this.xoffset = 0;
    this.yoffset = 0;
    this.xadvance = 0;
    this.fixedWidth = false;
  }
  /**
   * @ignore
   */
  getKerning(ch) {
    if (this.kerning) {
      let page = this.kerning[ch >>> LOG2_PAGE_SIZE];
      if (page) {
        return page[ch & PAGE_SIZE - 1] || 0;
      }
    }
    return 0;
  }
  /**
   * @ignore
   */
  setKerning(ch, value) {
    if (!this.kerning) {
      this.kerning = {};
    }
    let page = this.kerning[ch >>> LOG2_PAGE_SIZE];
    if (typeof page === "undefined") {
      this.kerning[ch >>> LOG2_PAGE_SIZE] = {};
      page = this.kerning[ch >>> LOG2_PAGE_SIZE];
    }
    page[ch & PAGE_SIZE - 1] = value;
  }
};
var capChars = ["M", "N", "B", "D", "C", "E", "F", "K", "A", "G", "H", "I", "J", "L", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
function getValueFromPair(string, pattern) {
  let value = string.match(pattern);
  if (!value) {
    throw new Error("Could not find pattern " + pattern + " in string: " + string);
  }
  return value[0].split("=")[1];
}
function getFirstGlyph(glyphs) {
  let keys2 = Object.keys(glyphs);
  for (let i = 0; i < keys2.length; i++) {
    if (keys2[i] > 32) {
      return glyphs[keys2[i]];
    }
  }
  return null;
}
function createSpaceGlyph(glyphs) {
  let spaceCharCode = " ".charCodeAt(0);
  let glyph = glyphs[spaceCharCode];
  if (!glyph) {
    glyph = new Glyph();
    glyph.id = spaceCharCode;
    glyph.xadvance = getFirstGlyph(glyphs).xadvance;
    glyphs[spaceCharCode] = glyph;
  }
}
var BitmapTextData = class {
  /**
  * @param {string} data - The bitmap font data pulled from the resource loader using me.loader.getBinary()
  */
  constructor(data2) {
    this.onResetEvent(data2);
  }
  /**
   * @ignore
   */
  onResetEvent(data2) {
    this.padTop = 0;
    this.padRight = 0;
    this.padBottom = 0;
    this.padLeft = 0;
    this.lineHeight = 0;
    this.capHeight = 1;
    this.descent = 0;
    this.glyphs = {};
    this.parse(data2);
  }
  /**
   * This parses the font data text and builds a map of glyphs containing the data for each character
   * @name parse
   * @memberof BitmapTextData
   * @param {string} fontData
   */
  parse(fontData) {
    if (!fontData) {
      throw new Error("File containing font data was empty, cannot load the bitmap font.");
    }
    let lines = fontData.split(/\r\n|\n/);
    let padding = fontData.match(/padding\=\d+,\d+,\d+,\d+/g);
    if (!padding) {
      throw new Error("Padding not found in first line");
    }
    let paddingValues = padding[0].split("=")[1].split(",");
    this.padTop = parseFloat(paddingValues[0]);
    this.padLeft = parseFloat(paddingValues[1]);
    this.padBottom = parseFloat(paddingValues[2]);
    this.padRight = parseFloat(paddingValues[3]);
    this.lineHeight = parseFloat(getValueFromPair(lines[1], /lineHeight\=\d+/g));
    let baseLine = parseFloat(getValueFromPair(lines[1], /base\=\d+/g));
    let padY = this.padTop + this.padBottom;
    let glyph = null;
    for (let i = 4; i < lines.length; i++) {
      let line = lines[i];
      let characterValues = line.split(/=|\s+/);
      if (!line || /^kernings/.test(line)) {
        continue;
      }
      if (/^kerning\s/.test(line)) {
        let first = parseFloat(characterValues[2]);
        let second = parseFloat(characterValues[4]);
        let amount = parseFloat(characterValues[6]);
        glyph = this.glyphs[first];
        if (glyph !== null && typeof glyph !== "undefined") {
          glyph.setKerning(second, amount);
        }
      } else {
        glyph = new Glyph();
        let ch = parseFloat(characterValues[2]);
        glyph.id = ch;
        glyph.x = parseFloat(characterValues[4]);
        glyph.y = parseFloat(characterValues[6]);
        glyph.width = parseFloat(characterValues[8]);
        glyph.height = parseFloat(characterValues[10]);
        glyph.xoffset = parseFloat(characterValues[12]);
        glyph.yoffset = parseFloat(characterValues[14]);
        glyph.xadvance = parseFloat(characterValues[16]);
        if (glyph.width > 0 && glyph.height > 0) {
          this.descent = Math.min(baseLine + glyph.yoffset, this.descent);
        }
        this.glyphs[ch] = glyph;
      }
    }
    this.descent += this.padBottom;
    createSpaceGlyph(this.glyphs);
    let capGlyph = null;
    for (let i = 0; i < capChars.length; i++) {
      let capChar = capChars[i];
      capGlyph = this.glyphs[capChar.charCodeAt(0)];
      if (capGlyph) {
        break;
      }
    }
    if (!capGlyph) {
      for (let charCode in this.glyphs) {
        if (this.glyphs.hasOwnProperty(charCode)) {
          glyph = this.glyphs[charCode];
          if (glyph.height === 0 || glyph.width === 0) {
            continue;
          }
          this.capHeight = Math.max(this.capHeight, glyph.height);
        }
      }
    } else {
      this.capHeight = capGlyph.height;
    }
    this.capHeight -= padY;
  }
};
var Draggable = class extends Renderable {
  /**
   * @param {number} x - the x coordinates of the draggable object
   * @param {number} y - the y coordinates of the draggable object
   * @param {number} width - draggable object width
   * @param {number} height - draggable object height
   */
  constructor(x, y, width, height) {
    super(x, y, width, height);
    this.isKinematic = false;
    this.dragging = false;
    this.dragId = null;
    this.grabOffset = new Vector2d(0, 0);
    this.initEvents();
  }
  /**
   * Initializes the events the modules needs to listen to
   * It translates the pointer events to me.events
   * in order to make them pass through the system and to make
   * this module testable. Then we subscribe this module to the
   * transformed events.
   * @name initEvents
   * @memberof Draggable
   * @private
   */
  initEvents() {
    registerPointerEvent("pointerdown", this, (e) => emit(DRAGSTART, e, this));
    registerPointerEvent("pointerup", this, (e) => emit(DRAGEND, e, this));
    registerPointerEvent("pointercancel", this, (e) => emit(DRAGEND, e, this));
    on(POINTERMOVE, (e) => this.dragMove(e));
    on(DRAGSTART, (e, draggable) => {
      if (draggable === this) {
        this.dragStart(e);
      }
    });
    on(DRAGEND, (e, draggable) => {
      if (draggable === this) {
        this.dragEnd(e);
      }
    });
  }
  /**
   * Gets called when the user starts dragging the entity
   * @name dragStart
   * @memberof Draggable
   * @param {object} e - the pointer event
   * @returns {boolean} false if the object is being dragged
   */
  dragStart(e) {
    if (this.dragging === false) {
      this.dragging = true;
      this.grabOffset.set(e.gameX, e.gameY);
      this.grabOffset.sub(this.pos);
      return false;
    }
  }
  /**
   * Gets called when the user drags this entity around
   * @name dragMove
   * @memberof Draggable
   * @param {object} e - the pointer event
   */
  dragMove(e) {
    if (this.dragging === true) {
      this.pos.set(e.gameX, e.gameY, this.pos.z);
      this.pos.sub(this.grabOffset);
    }
  }
  /**
   * Gets called when the user stops dragging the entity
   * @name dragEnd
   * @memberof Draggable
   * @returns {boolean} false if the object stopped being dragged
   */
  dragEnd() {
    if (this.dragging === true) {
      this.dragging = false;
      return false;
    }
  }
  /**
   * Destructor
   * @name destroy
   * @memberof Draggable
   * @ignore
   */
  destroy() {
    off(POINTERMOVE, this.dragMove);
    off(DRAGSTART, this.dragStart);
    off(DRAGEND, this.dragEnd);
    releasePointerEvent("pointerdown", this);
    releasePointerEvent("pointerup", this);
    releasePointerEvent("pointercancel", this);
    super.destroy();
  }
};
var DropTarget = class extends Renderable {
  /**
   * @param {number} x - the x coordinates of the drop target
   * @param {number} y - the y coordinates of the drop target
   * @param {number} width - drop target width
   * @param {number} height - drop target height
   */
  constructor(x, y, width, height) {
    super(x, y, width, height);
    this.isKinematic = false;
    this.CHECKMETHOD_OVERLAP = "overlaps";
    this.CHECKMETHOD_CONTAINS = "contains";
    this.checkMethod = this.CHECKMETHOD_OVERLAP;
    on(DRAGEND, this.checkOnMe, this);
  }
  /**
   * Sets the collision method which is going to be used to check a valid drop
   * @name setCheckMethod
   * @memberof DropTarget
   * @param {string} checkMethod - the checkmethod (defaults to CHECKMETHOD_OVERLAP)
   */
  setCheckMethod(checkMethod) {
    if (typeof this.getBounds()[this.checkMethod] === "function") {
      this.checkMethod = checkMethod;
    }
  }
  /**
   * Checks if a dropped entity is dropped on the current entity
   * @name checkOnMe
   * @memberof DropTarget
   * @param {object} e - the triggering event
   * @param {Draggable} draggable - the draggable object that is dropped
   */
  checkOnMe(e, draggable) {
    if (draggable && this.getBounds()[this.checkMethod](draggable.getBounds())) {
      this.drop(draggable);
    }
  }
  /**
   * Gets called when a draggable entity is dropped on the current entity
   * @name drop
   * @memberof DropTarget
   * @param {Draggable} draggable - the draggable object that is dropped
   */
  drop(draggable) {
  }
  /**
   * Destructor
   * @name destroy
   * @memberof DropTarget
   * @ignore
   */
  destroy() {
    off(DRAGEND, this.checkOnMe);
    super.destroy();
  }
};
var LEFT_VORNOI_REGION = -1;
var MIDDLE_VORNOI_REGION = 0;
var RIGHT_VORNOI_REGION = 1;
var T_VECTORS = [];
for (let v = 0; v < 10; v++) {
  T_VECTORS.push(new Vector2d());
}
var T_ARRAYS = [];
for (let a = 0; a < 5; a++) {
  T_ARRAYS.push([]);
}
function flattenPointsOn(points, normal, result) {
  let min2 = Number.MAX_VALUE;
  let max2 = -Number.MAX_VALUE;
  let len = points.length;
  for (let i = 0; i < len; i++) {
    const dot = points[i].dot(normal);
    if (dot < min2) {
      min2 = dot;
    }
    if (dot > max2) {
      max2 = dot;
    }
  }
  result[0] = min2;
  result[1] = max2;
}
function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
  let rangeA = T_ARRAYS.pop();
  let rangeB = T_ARRAYS.pop();
  let offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
  let projectedOffset = offsetV.dot(axis);
  flattenPointsOn(aPoints, axis, rangeA);
  flattenPointsOn(bPoints, axis, rangeB);
  rangeB[0] += projectedOffset;
  rangeB[1] += projectedOffset;
  if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
    T_VECTORS.push(offsetV);
    T_ARRAYS.push(rangeA);
    T_ARRAYS.push(rangeB);
    return true;
  }
  if (response) {
    let overlap = 0;
    if (rangeA[0] < rangeB[0]) {
      response.aInB = false;
      if (rangeA[1] < rangeB[1]) {
        overlap = rangeA[1] - rangeB[0];
        response.bInA = false;
      } else {
        let option1 = rangeA[1] - rangeB[0];
        let option2 = rangeB[1] - rangeA[0];
        overlap = option1 < option2 ? option1 : -option2;
      }
    } else {
      response.bInA = false;
      if (rangeA[1] > rangeB[1]) {
        overlap = rangeA[0] - rangeB[1];
        response.aInB = false;
      } else {
        let option11 = rangeA[1] - rangeB[0];
        let option22 = rangeB[1] - rangeA[0];
        overlap = option11 < option22 ? option11 : -option22;
      }
    }
    let absOverlap = Math.abs(overlap);
    if (absOverlap < response.overlap) {
      response.overlap = absOverlap;
      response.overlapN.copy(axis);
      if (overlap < 0) {
        response.overlapN.negateSelf();
      }
    }
  }
  T_VECTORS.push(offsetV);
  T_ARRAYS.push(rangeA);
  T_ARRAYS.push(rangeB);
  return false;
}
function vornoiRegion(line, point) {
  let len2 = line.length2();
  let dp = point.dot(line);
  if (dp < 0) {
    return LEFT_VORNOI_REGION;
  } else if (dp > len2) {
    return RIGHT_VORNOI_REGION;
  } else {
    return MIDDLE_VORNOI_REGION;
  }
}
function testPolygonPolygon(a, polyA, b, polyB, response) {
  let aPoints = polyA.points;
  let aNormals = polyA.normals;
  let aLen = aNormals.length;
  let bPoints = polyB.points;
  let bNormals = polyB.normals;
  let bLen = bNormals.length;
  let posA = T_VECTORS.pop().copy(a.pos).add(a.ancestor.getAbsolutePosition()).add(polyA.pos);
  let posB = T_VECTORS.pop().copy(b.pos).add(b.ancestor.getAbsolutePosition()).add(polyB.pos);
  for (let i = 0; i < aLen; i++) {
    if (isSeparatingAxis(posA, posB, aPoints, bPoints, aNormals[i], response)) {
      T_VECTORS.push(posA);
      T_VECTORS.push(posB);
      return false;
    }
  }
  for (let i = 0; i < bLen; i++) {
    if (isSeparatingAxis(posA, posB, aPoints, bPoints, bNormals[i], response)) {
      T_VECTORS.push(posA);
      T_VECTORS.push(posB);
      return false;
    }
  }
  if (response) {
    response.a = a;
    response.b = b;
    response.overlapV.copy(response.overlapN).scale(response.overlap);
  }
  T_VECTORS.push(posA);
  T_VECTORS.push(posB);
  return true;
}
function testEllipseEllipse(a, ellipseA, b, ellipseB, response) {
  let differenceV = T_VECTORS.pop().copy(b.pos).add(b.ancestor.getAbsolutePosition()).add(ellipseB.pos).sub(a.pos).add(a.ancestor.getAbsolutePosition()).sub(ellipseA.pos);
  let radiusA = ellipseA.radius;
  let radiusB = ellipseB.radius;
  let totalRadius = radiusA + radiusB;
  let totalRadiusSq = totalRadius * totalRadius;
  let distanceSq = differenceV.length2();
  if (distanceSq > totalRadiusSq) {
    T_VECTORS.push(differenceV);
    return false;
  }
  if (response) {
    let dist = Math.sqrt(distanceSq);
    response.a = a;
    response.b = b;
    response.overlap = totalRadius - dist;
    response.overlapN.copy(differenceV.normalize());
    response.overlapV.copy(differenceV).scale(response.overlap);
    response.aInB = radiusA <= radiusB && dist <= radiusB - radiusA;
    response.bInA = radiusB <= radiusA && dist <= radiusA - radiusB;
  }
  T_VECTORS.push(differenceV);
  return true;
}
function testPolygonEllipse(a, polyA, b, ellipseB, response) {
  let circlePos = T_VECTORS.pop().copy(b.pos).add(b.ancestor.getAbsolutePosition()).add(ellipseB.pos).sub(a.pos).add(a.ancestor.getAbsolutePosition()).sub(polyA.pos);
  let radius = ellipseB.radius;
  let radius2 = radius * radius;
  let points = polyA.points;
  let edges = polyA.edges;
  let len = edges.length;
  let edge = T_VECTORS.pop();
  let normal = T_VECTORS.pop();
  let point = T_VECTORS.pop();
  let dist = 0;
  for (let i = 0; i < len; i++) {
    const next = i === len - 1 ? 0 : i + 1;
    const prev = i === 0 ? len - 1 : i - 1;
    let overlap = 0;
    let overlapN = null;
    edge.copy(edges[i]);
    point.copy(circlePos).sub(points[i]);
    if (response && point.length2() > radius2) {
      response.aInB = false;
    }
    let region = vornoiRegion(edge, point);
    let inRegion = true;
    if (region === LEFT_VORNOI_REGION) {
      let point2 = null;
      if (len > 1) {
        edge.copy(edges[prev]);
        point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
        region = vornoiRegion(edge, point2);
        if (region !== RIGHT_VORNOI_REGION) {
          inRegion = false;
        }
      }
      if (inRegion) {
        dist = point.length();
        if (dist > radius) {
          T_VECTORS.push(circlePos);
          T_VECTORS.push(edge);
          T_VECTORS.push(normal);
          T_VECTORS.push(point);
          if (point2) {
            T_VECTORS.push(point2);
          }
          return false;
        } else if (response) {
          response.bInA = false;
          overlapN = point.normalize();
          overlap = radius - dist;
        }
      }
      if (point2) {
        T_VECTORS.push(point2);
      }
    } else if (region === RIGHT_VORNOI_REGION) {
      if (len > 1) {
        edge.copy(edges[next]);
        point.copy(circlePos).sub(points[next]);
        region = vornoiRegion(edge, point);
        if (region !== LEFT_VORNOI_REGION) {
          inRegion = false;
        }
      }
      if (inRegion) {
        dist = point.length();
        if (dist > radius) {
          T_VECTORS.push(circlePos);
          T_VECTORS.push(edge);
          T_VECTORS.push(normal);
          T_VECTORS.push(point);
          return false;
        } else if (response) {
          response.bInA = false;
          overlapN = point.normalize();
          overlap = radius - dist;
        }
      }
    } else {
      normal.copy(polyA.normals[i]);
      dist = point.dot(normal);
      let distAbs = Math.abs(dist);
      if ((len === 1 || dist > 0) && distAbs > radius) {
        T_VECTORS.push(circlePos);
        T_VECTORS.push(edge);
        T_VECTORS.push(normal);
        T_VECTORS.push(point);
        return false;
      } else if (response) {
        overlapN = normal;
        overlap = radius - dist;
        if (dist >= 0 || overlap < 2 * radius) {
          response.bInA = false;
        }
      }
    }
    if (overlapN && response && Math.abs(overlap) < Math.abs(response.overlap)) {
      response.overlap = overlap;
      response.overlapN.copy(overlapN);
    }
  }
  if (response) {
    response.a = a;
    response.b = b;
    response.overlapV.copy(response.overlapN).scale(response.overlap);
  }
  T_VECTORS.push(circlePos);
  T_VECTORS.push(edge);
  T_VECTORS.push(normal);
  T_VECTORS.push(point);
  return true;
}
function testEllipsePolygon(a, ellipseA, b, polyB, response) {
  let result = testPolygonEllipse(b, polyB, a, ellipseA, response);
  if (result && response) {
    let resa = response.a;
    let aInB = response.aInB;
    response.overlapN.negateSelf();
    response.overlapV.negateSelf();
    response.a = response.b;
    response.b = resa;
    response.aInB = response.bInA;
    response.bInA = aInB;
  }
  return result;
}
var SAT = {
  __proto__: null,
  testEllipseEllipse,
  testEllipsePolygon,
  testPolygonEllipse,
  testPolygonPolygon
};
var ResponseObject = class {
  constructor() {
    this.a = null;
    this.b = null;
    this.overlapN = new Vector2d();
    this.overlapV = new Vector2d();
    this.aInB = true;
    this.bInA = true;
    this.indexShapeA = -1;
    this.indexShapeB = -1;
    this.overlap = Number.MAX_VALUE;
  }
  /**
   * Set some values of the response back to their defaults. <br>
   * Call this between tests if you are going to reuse a single <br>
   * Response object for multiple intersection tests <br>
   * (recommended as it will avoid allocating extra memory) <br>
   * @name clear
   * @public
   * @returns {object} this object for chaining
   */
  clear() {
    this.aInB = true;
    this.bInA = true;
    this.overlap = Number.MAX_VALUE;
    this.indexShapeA = -1;
    this.indexShapeB = -1;
    return this;
  }
};
var dummyObj = {
  pos: new Vector2d(0, 0),
  ancestor: {
    _absPos: new Vector2d(0, 0),
    getAbsolutePosition: function() {
      return this._absPos;
    }
  }
};
var boundsA = new Bounds();
var boundsB = new Bounds();
var Detector = class {
  /**
   * @param {Container} world - the physic world this detector is bind to
   */
  constructor(world) {
    this.world = world;
    this.response = new ResponseObject();
  }
  /**
   * determine if two objects should collide (based on both respective objects body collision mask and type).<br>
   * you can redefine this function if you need any specific rules over what should collide with what.
   * @param {Renderable|Container|Entity|Sprite|NineSliceSprite} a - a reference to the object A.
   * @param {Renderable|Container|Entity|Sprite|NineSliceSprite} b - a reference to the object B.
   * @returns {boolean} true if they should collide, false otherwise
   */
  shouldCollide(a, b) {
    let bodyA = a.body, bodyB = b.body;
    return typeof bodyA === "object" && typeof bodyB === "object" && a !== b && a.isKinematic !== true && b.isKinematic !== true && bodyA.shapes.length > 0 && bodyB.shapes.length > 0 && !(bodyA.isStatic === true && bodyB.isStatic === true) && (bodyA.collisionMask & bodyB.collisionType) !== 0 && (bodyA.collisionType & bodyB.collisionMask) !== 0;
  }
  /**
   * detect collision between two bodies.
   * @param {Body} bodyA - a reference to body A.
   * @param {Body} bodyB - a reference to body B.
   * @returns {boolean} true if colliding
   */
  collides(bodyA, bodyB, response = this.response) {
    for (let indexA = bodyA.shapes.length, shapeA; indexA--, shapeA = bodyA.shapes[indexA]; ) {
      for (let indexB = bodyB.shapes.length, shapeB; indexB--, shapeB = bodyB.shapes[indexB]; ) {
        if (SAT["test" + shapeA.type + shapeB.type].call(
          this,
          bodyA.ancestor,
          // a reference to the object A
          shapeA,
          bodyB.ancestor,
          // a reference to the object B
          shapeB,
          // clear response object before reusing
          response.clear()
        ) === true) {
          response.indexShapeA = indexA;
          response.indexShapeB = indexB;
          return true;
        }
      }
    }
    return false;
  }
  /**
   * find all the collisions for the specified object using a broadphase algorithm
   * @ignore
   * @param {Renderable|Container|Entity|Sprite|NineSliceSprite} objA - object to be tested for collision
   * @returns {boolean} in case of collision, false otherwise
   */
  collisions(objA) {
    let collisionCounter = 0;
    let candidates = this.world.broadphase.retrieve(objA);
    boundsA.addBounds(objA.getBounds(), true);
    boundsA.addBounds(objA.body.getBounds());
    candidates.forEach((objB) => {
      if (this.shouldCollide(objA, objB)) {
        boundsB.addBounds(objB.getBounds(), true);
        boundsB.addBounds(objB.body.getBounds());
        if (boundsA.overlaps(boundsB)) {
          if (this.collides(objA.body, objB.body)) {
            collisionCounter++;
            if (objA.onCollision && objA.onCollision(this.response, objB) !== false && objA.body.isStatic === false) {
              objA.body.respondToCollision.call(objA.body, this.response);
            }
            if (objB.onCollision && objB.onCollision(this.response, objA) !== false && objB.body.isStatic === false) {
              objB.body.respondToCollision.call(objB.body, this.response);
            }
          }
        }
      }
    });
    return collisionCounter > 0;
  }
  /**
   * Checks for object colliding with the given line
   * @ignore
   * @param {Line} line - line to be tested for collision
   * @param {Array.<Renderable>} [result] - a user defined array that will be populated with intersecting physic objects.
   * @returns {Array.<Renderable>} an array of intersecting physic objects
   * @example
   *    // define a line accross the viewport
   *    let ray = new me.Line(
   *        // absolute position of the line
   *        0, 0, [
   *        // starting point relative to the initial position
   *        new me.Vector2d(0, 0),
   *        // ending point
   *        new me.Vector2d(me.game.viewport.width, me.game.viewport.height)
   *    ]);
   *
   *    // check for collition
   *    result = me.collision.rayCast(ray);
   *
   *    if (result.length > 0) {
   *        // ...
   *    }
   */
  rayCast(line, result = []) {
    let collisionCounter = 0;
    let candidates = this.world.broadphase.retrieve(line);
    for (let i = candidates.length, objB; i--, objB = candidates[i]; ) {
      if (objB.body && line.getBounds().overlaps(objB.getBounds())) {
        const bLen = objB.body.shapes.length;
        if (objB.body.shapes.length === 0) {
          continue;
        }
        let shapeA = line;
        let indexB = 0;
        do {
          let shapeB = objB.body.getShape(indexB);
          if (SAT["test" + shapeA.type + shapeB.type].call(
            this,
            dummyObj,
            // a reference to the object A
            shapeA,
            objB,
            // a reference to the object B
            shapeB
          )) {
            result[collisionCounter] = objB;
            collisionCounter++;
          }
          indexB++;
        } while (indexB < bLen);
      }
    }
    result.length = collisionCounter;
    return result;
  }
};
var World = class extends Container {
  /**
   * @param {number} [x=0] - position of the container (accessible via the inherited pos.x property)
   * @param {number} [y=0] - position of the container (accessible via the inherited pos.y property)
   * @param {number} [width=game.viewport.width] - width of the container
   * @param {number} [height=game.viewport.height] - height of the container
   */
  constructor(x = 0, y = 0, width = Infinity, height = Infinity) {
    super(x, y, width, height, true);
    this.name = "rootContainer";
    this.anchorPoint.set(0, 0);
    this.app = void 0;
    this.physic = "builtin";
    this.fps = 60;
    this.gravity = new Vector2d(0, 0.98);
    this.preRender = false;
    this.bodies = /* @__PURE__ */ new Set();
    this.broadphase = new QuadTree(this, this.getBounds().clone(), collision.maxChildren, collision.maxDepth);
    this.detector = new Detector(this);
    on(GAME_RESET, this.reset, this);
    on(LEVEL_LOADED, () => {
      this.broadphase.clear(this.getBounds());
    });
  }
  /**
   * reset the game world
   */
  reset() {
    this.broadphase.clear();
    this.anchorPoint.set(0, 0);
    super.reset();
    this.bodies.clear();
  }
  /**
   * Add a physic body to the game world
   * @see Container.addChild
   * @param {Body} body
   * @returns {World} this game world
   */
  addBody(body) {
    if (this.physic === "builtin") {
      this.bodies.add(body);
    }
    return this;
  }
  /**
   * Remove a physic body from the game world
   * @see Container.removeChild
   * @param {Body} body
   * @returns {World} this game world
   */
  removeBody(body) {
    if (this.physic === "builtin") {
      this.bodies.delete(body);
    }
    return this;
  }
  /**
   * Apply gravity to the given body
   * @private
   * @param {Body} body
   */
  bodyApplyGravity(body) {
    if (!body.ignoreGravity && body.gravityScale !== 0) {
      let gravity = this.gravity;
      body.force.x += body.mass * gravity.x * body.gravityScale;
      body.force.y += body.mass * gravity.y * body.gravityScale;
    }
  }
  /**
   * update the game world
   * @param {number} dt - the time passed since the last frame update
   * @returns {boolean} true if the world is dirty
   */
  update(dt) {
    if (this.physic === "builtin" || hasRegisteredEvents() === true) {
      this.broadphase.clear();
      this.broadphase.insertContainer(this);
    }
    this.step(dt);
    return super.update(dt);
  }
  /**
   * update the builtin physic simulation by one step (called by the game world update method)
   * @param {number} dt - the time passed since the last frame update
   */
  step(dt) {
    if (this.physic === "builtin") {
      let isPaused = state.isPaused();
      this.bodies.forEach((body) => {
        if (!body.isStatic) {
          let ancestor = body.ancestor;
          if (!(isPaused && !ancestor.updateWhenPaused) && (ancestor.inViewport || ancestor.alwaysUpdate)) {
            this.bodyApplyGravity(body);
            if (body.update(dt) === true) {
              ancestor.isDirty = true;
            }
            this.detector.collisions(ancestor);
            body.force.set(0, 0);
          }
        }
      });
    }
    emit(WORLD_STEP, dt);
  }
};
var ParticleEmitterSettings = {
  /**
   * Width of the particle spawn area.
   * @type {number}
   * @name width
   * @memberof ParticleEmitterSettings
   * @default 1
   */
  width: 1,
  /**
   * Height of the particle spawn area
   * @public
   * @type {number}
   * @name height
   * @memberof ParticleEmitterSettings
   * @default 1
   */
  height: 1,
  /**
   * image used for particles texture
   * (by default melonJS will create an white 8x8 texture image)
   * @public
   * @type {HTMLCanvasElement}
   * @name image
   * @memberof ParticleEmitterSettings
   * @default undefined
   * @see ParticleEmitterSettings.textureSize
   */
  image: void 0,
  /**
   * default texture size used for particles if no image is specified
   * (by default melonJS will create an white 8x8 texture image)
   * @public
   * @type {number}
   * @name textureSize
   * @memberof ParticleEmitterSettings
   * @default 8
   * @see ParticleEmitterSettings.image
   */
  textureSize: 8,
  /**
   * tint to be applied to particles
   * @public
   * @type {string}
   * @name tint
   * @memberof ParticleEmitterSettings
   * @default "#fff"
   */
  tint: "#fff",
  /**
   * Total number of particles in the emitter
   * @public
   * @type {number}
   * @name totalParticles
   * @default 50
   * @memberof ParticleEmitterSettings
   */
  totalParticles: 50,
  /**
   * Start angle for particle launch in Radians
   * @public
   * @type {number}
   * @name angle
   * @default Math.PI / 2
   * @memberof ParticleEmitterSettings
   */
  angle: Math.PI / 2,
  /**
   * letiation in the start angle for particle launch in Radians.
   * @public
   * @type {number}
   * @name angleVariation
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  angleVariation: 0,
  /**
   * Minimum time each particle lives once it is emitted in ms.
   * @public
   * @type {number}
   * @name minLife
   * @default 1000
   * @memberof ParticleEmitterSettings
   */
  minLife: 1e3,
  /**
   * Maximum time each particle lives once it is emitted in ms.
   * @public
   * @type {number}
   * @name maxLife
   * @default 3000
   * @memberof ParticleEmitterSettings
   */
  maxLife: 3e3,
  /**
   * Start speed of particles.<br>
   * @public
   * @type {number}
   * @name speed
   * @default 2
   * @memberof ParticleEmitterSettings
   */
  speed: 2,
  /**
   * letiation in the start speed of particles
   * @public
   * @type {number}
   * @name speedVariation
   * @default 1
   * @memberof ParticleEmitterSettings
   */
  speedVariation: 1,
  /**
   * Minimum start rotation for particles sprites in Radians
   * @public
   * @type {number}
   * @name minRotation
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  minRotation: 0,
  /**
   * Maximum start rotation for particles sprites in Radians
   * @public
   * @type {number}
   * @name maxRotation
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  maxRotation: 0,
  /**
   * Minimum start scale ratio for particles (1 = no scaling)
   * @public
   * @type {number}
   * @name minStartScale
   * @default 1
   * @memberof ParticleEmitterSettings
   */
  minStartScale: 1,
  /**
   * Maximum start scale ratio for particles (1 = no scaling)
   * @public
   * @type {number}
   * @name maxStartScale
   * @default 1
   * @memberof ParticleEmitterSettings
   */
  maxStartScale: 1,
  /**
   * Minimum end scale ratio for particles
   * @public
   * @type {number}
   * @name minEndScale
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  minEndScale: 0,
  /**
   * Maximum end scale ratio for particles
   * @public
   * @type {number}
   * @name maxEndScale
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  maxEndScale: 0,
  /**
   * Vertical force (Gravity) for each particle
   * @public
   * @type {number}
   * @name gravity
   * @default 0
   * @memberof ParticleEmitterSettings
   * @see game.world.gravity
   */
  gravity: 0,
  /**
   * Horizontal force (like a Wind) for each particle
   * @public
   * @type {number}
   * @name wind
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  wind: 0,
  /**
   * Update the rotation of particle in accordance the particle trajectory.<br>
   * The particle sprite should aim at zero angle (draw from left to right).<br>
   * Override the particle minRotation and maxRotation.<br>
   * @public
   * @type {boolean}
   * @name followTrajectory
   * @default false
   * @memberof ParticleEmitterSettings
   */
  followTrajectory: false,
  /**
   * Enable the Texture Additive by composite operation ("additive" blendMode)
   * @public
   * @type {boolean}
   * @name textureAdditive
   * @default false
   * @memberof ParticleEmitterSettings
   * @see ParticleEmitterSettings.blendMode
   */
  textureAdditive: false,
  /**
   * the blend mode to be applied when rendering particles.
   * (note: this will superseed the `textureAdditive` setting if different than "normal")
   * @public
   * @type {string}
   * @name blendMode
   * @default normal
   * @memberof ParticleEmitterSettings
   * @see CanvasRenderer#setBlendMode
   * @see WebGLRenderer#setBlendMode
   */
  blendMode: "normal",
  /**
   * Update particles only in the viewport, remove it when out of viewport.
   * @public
   * @type {boolean}
   * @name onlyInViewport
   * @default true
   * @memberof ParticleEmitterSettings
   */
  onlyInViewport: true,
  /**
   * Render particles in screen space.
   * @public
   * @type {boolean}
   * @name floating
   * @default false
   * @memberof ParticleEmitterSettings
   */
  floating: false,
  /**
   * Maximum number of particles launched each time in this emitter (used only if emitter is Stream).
   * @public
   * @type {number}
   * @name maxParticles
   * @default 10
   * @memberof ParticleEmitterSettings
   */
  maxParticles: 10,
  /**
   * How often a particle is emitted in ms (used only if emitter is a Stream).
   * @public
   * @type {number}
   * @name frequency
   * @default 100
   * @memberof ParticleEmitterSettings
   */
  frequency: 100,
  /**
   * Duration that the emitter releases particles in ms (used only if emitter is Stream).
   * After this period, the emitter stop the launch of particles.
   * @public
   * @type {number}
   * @name duration
   * @default Infinity
   * @memberof ParticleEmitterSettings
   */
  duration: Infinity,
  /**
   * Skip n frames after updating the particle system once.
   * This can be used to reduce the performance impact of emitters with many particles.
   * @public
   * @type {number}
   * @name framesToSkip
   * @default 0
   * @memberof ParticleEmitterSettings
   */
  framesToSkip: 0
};
function createDefaultParticleTexture(w = 8, h = 8) {
  let defaultParticleTexture = pool.pull("CanvasRenderTarget", w, h, { offscreenCanvas: true });
  defaultParticleTexture.context.fillStyle = "#fff";
  defaultParticleTexture.context.fillRect(0, 0, w, h);
  return defaultParticleTexture;
}
var ParticleEmitter = class extends Container {
  /**
   * @param {number} x - x position of the particle emitter
   * @param {number} y - y position of the particle emitter
   * @param {ParticleEmitterSettings} [settings=ParticleEmitterSettings] - the settings for the particle emitter.
   * @example
   * // Create a particle emitter at position 100, 100
   * let emitter = new ParticleEmitter(100, 100, {
   *     width: 16,
   *     height : 16,
   *     tint: "#f00",
   *     totalParticles: 32,
   *     angle: 0,
   *     angleVariation: 6.283185307179586,
   *     maxLife: 5,
   *     speed: 3
   * });
   *
   * // Add the emitter to the game world
   * me.game.world.addChild(emitter);
   *
   * // Launch all particles one time and stop, like a explosion
   * emitter.burstParticles();
   *
   * // Launch constantly the particles, like a fountain
   * emitter.streamParticles();
   *
   * // At the end, remove emitter from the game world
   * // call this in onDestroyEvent function
   * me.game.world.removeChild(emitter);
   */
  constructor(x, y, settings = {}) {
    super(
      x,
      y,
      settings.width | 1,
      settings.height | 1
    );
    this.settings = {};
    this.centerOn(x, y);
    this._stream = false;
    this._frequencyTimer = 0;
    this._durationTimer = 0;
    this._enabled = false;
    this.alwaysUpdate = true;
    this.autoSort = false;
    this._updateCount = 0;
    this._dt = 0;
    this.reset(settings);
  }
  /**
   * Reset the emitter with particle emitter settings.
   * @param {ParticleEmitterSettings} settings - [optional] object with emitter settings. See {@link ParticleEmitterSettings}
   */
  reset(settings = {}) {
    Object.assign(this.settings, ParticleEmitterSettings, settings);
    if (typeof this.settings.image === "undefined") {
      this._defaultParticle = createDefaultParticleTexture(settings.textureSize, settings.textureSize);
      this.settings.image = this._defaultParticle.canvas;
    }
    this.floating = this.settings.floating;
    this.isDirty = true;
  }
  /**
   * returns a random point on the x axis within the bounds of this emitter
   * @returns {number}
   */
  getRandomPointX() {
    return randomFloat(0, this.getBounds().width);
  }
  /**
   * returns a random point on the y axis within the bounds this emitter
   * @returns {number}
   */
  getRandomPointY() {
    return randomFloat(0, this.getBounds().height);
  }
  // Add count particles in the game world
  /** @ignore */
  addParticles(count) {
    for (let i = 0; i < count; i++) {
      this.addChild(pool.pull("Particle", this), this.pos.z);
    }
    this.isDirty = true;
  }
  /**
   * Emitter is of type stream and is launching particles
   * @returns {boolean} Emitter is Stream and is launching particles
   */
  isRunning() {
    return this._enabled && this._stream;
  }
  /**
   * Launch particles from emitter constantly (e.g. for stream)
   * @param {number} [duration] - time that the emitter releases particles in ms
   */
  streamParticles(duration) {
    this._enabled = true;
    this._stream = true;
    this.settings.frequency = Math.max(1, this.settings.frequency);
    this._durationTimer = typeof duration === "number" ? duration : this.settings.duration;
  }
  /**
   * Stop the emitter from generating new particles (used only if emitter is Stream)
   */
  stopStream() {
    this._enabled = false;
  }
  /**
   * Launch all particles from emitter and stop (e.g. for explosion)
   * @param {number} [total] - number of particles to launch
   */
  burstParticles(total) {
    this._enabled = true;
    this._stream = false;
    this.addParticles(typeof total === "number" ? total : this.settings.totalParticles);
    this._enabled = false;
  }
  /**
   * @ignore
   */
  update(dt) {
    if (++this._updateCount > this.settings.framesToSkip) {
      this._updateCount = 0;
    }
    if (this._updateCount > 0) {
      this._dt += dt;
      return this.isDirty;
    }
    dt += this._dt;
    this._dt = 0;
    this.isDirty |= super.update(dt);
    if (this._enabled && this._stream) {
      if (this._durationTimer !== Infinity) {
        this._durationTimer -= dt;
        if (this._durationTimer <= 0) {
          this.stopStream();
          return this.isDirty;
        }
      }
      this._frequencyTimer += dt;
      const particlesCount = this.children.length;
      if (particlesCount < this.settings.totalParticles && this._frequencyTimer >= this.settings.frequency) {
        if (particlesCount + this.settings.maxParticles <= this.settings.totalParticles) {
          this.addParticles(this.settings.maxParticles);
        } else {
          this.addParticles(this.settings.totalParticles - particlesCount);
        }
        this._frequencyTimer = 0;
        this.isDirty = true;
      }
    }
    return this.isDirty;
  }
  /**
   * Destroy function
   * @ignore
   */
  destroy() {
    super.destroy(arguments);
    if (typeof this._defaultParticle !== "undefined") {
      pool.push(this._defaultParticle);
      this._defaultParticle = void 0;
    }
    this.settings.image = void 0;
    this.settings = void 0;
  }
};
var Particle = class extends Renderable {
  /**
   * @param {ParticleEmitter} emitter - the particle emitter
   */
  constructor(emitter) {
    super(
      emitter.getRandomPointX(),
      emitter.getRandomPointY(),
      emitter.settings.image.width,
      emitter.settings.image.height
    );
    this.onResetEvent(emitter, true);
  }
  /**
   * @ignore
   */
  onResetEvent(emitter, newInstance = false) {
    if (newInstance === false) {
      this.pos.set(
        emitter.getRandomPointX(),
        emitter.getRandomPointY()
      );
      this.resize(
        emitter.settings.image.width,
        emitter.settings.image.height
      );
      this.currentTransform.identity();
    } else {
      this.vel = pool.pull("Vector2d");
    }
    this.image = emitter.settings.image;
    this.alwaysUpdate = true;
    if (typeof emitter.settings.tint === "string") {
      this.tint.parseCSS(emitter.settings.tint);
    }
    if (emitter.settings.textureAdditive === true) {
      this.blendMode = "additive";
    }
    if (emitter.settings.blendMode !== "normal") {
      this.blendMode = emitter.settings.blendMode;
    }
    let angle = emitter.settings.angle + (emitter.settings.angleVariation > 0 ? (randomFloat(0, 2) - 1) * emitter.settings.angleVariation : 0);
    let speed = emitter.settings.speed + (emitter.settings.speedVariation > 0 ? (randomFloat(0, 2) - 1) * emitter.settings.speedVariation : 0);
    this.vel.set(speed * Math.cos(angle), -speed * Math.sin(angle));
    this.life = randomFloat(emitter.settings.minLife, emitter.settings.maxLife);
    this.startLife = this.life;
    this.startScale = clamp(
      randomFloat(emitter.settings.minStartScale, emitter.settings.maxStartScale),
      emitter.settings.minStartScale,
      emitter.settings.maxStartScale
    );
    this.endScale = clamp(
      randomFloat(emitter.settings.minEndScale, emitter.settings.maxEndScale),
      emitter.settings.minEndScale,
      emitter.settings.maxEndScale
    );
    this.gravity = emitter.settings.gravity;
    this.wind = emitter.settings.wind;
    this.followTrajectory = emitter.settings.followTrajectory;
    this.onlyInViewport = emitter.settings.onlyInViewport;
    this._deltaInv = timer.maxfps / 1e3;
    if (!emitter.settings.followTrajectory) {
      this.angle = randomFloat(emitter.settings.minRotation, emitter.settings.maxRotation);
    }
  }
  /**
   * Update the Particle <br>
   * This is automatically called by the game manager {@link game}
   * @ignore
   * @param {number} dt - time since the last update in milliseconds
   */
  update(dt) {
    let skew = dt * this._deltaInv;
    this.life = this.life > dt ? this.life - dt : 0;
    if (this.life <= 0) {
      this.ancestor.removeChild(this);
      return false;
    }
    let ageRatio = this.life / this.startLife;
    let scale2 = this.startScale;
    if (this.startScale > this.endScale) {
      scale2 *= ageRatio;
      scale2 = scale2 < this.endScale ? this.endScale : scale2;
    } else if (this.startScale < this.endScale) {
      scale2 /= ageRatio;
      scale2 = scale2 > this.endScale ? this.endScale : scale2;
    }
    this.alpha = ageRatio;
    this.vel.x += this.wind * skew;
    this.vel.y += this.gravity * skew;
    let angle = this.followTrajectory ? Math.atan2(this.vel.y, this.vel.x) : this.angle;
    this.pos.x += this.vel.x * skew;
    this.pos.y += this.vel.y * skew;
    this.currentTransform.setTransform(
      scale2,
      0,
      0,
      0,
      scale2,
      0,
      this.pos.x,
      this.pos.y,
      1
    ).rotate(angle);
    this.isDirty = this.inViewport || !this.onlyInViewport;
    return super.update(dt);
  }
  /**
   * @ignore
   */
  draw(renderer2) {
    let w = this.width, h = this.height;
    renderer2.drawImage(
      this.image,
      0,
      0,
      w,
      h,
      -w / 2,
      -h / 2,
      w,
      h
    );
  }
};
var Entity = class extends Renderable {
  /**
   * @param {number} x - the x coordinates of the entity object
   * @param {number} y - the y coordinates of the entity object
   * @param {object} settings - Entity properties, to be defined through Tiled or when calling the entity constructor
   * <img src="images/object_properties.png"/>
   * @param {number} settings.width - the physical width the entity takes up in game
   * @param {number} settings.height - the physical height the entity takes up in game
   * @param {string} [settings.name] - object entity name
   * @param {string} [settings.id] - object unique IDs
   * @param {Image|string} [settings.image] - resource name of a spritesheet to use for the entity renderable component
   * @param {Vector2d} [settings.anchorPoint=0.0] - Entity anchor point
   * @param {number} [settings.framewidth=settings.width] - width of a single frame in the given spritesheet
   * @param {number} [settings.frameheight=settings.width] - height of a single frame in the given spritesheet
   * @param {string} [settings.type] - object type
   * @param {number} [settings.collisionMask] - Mask collision detection for this object
   * @param {Rect[]|Polygon[]|Line[]|Ellipse[]} [settings.shapes] - the initial list of collision shapes (usually populated through Tiled)
   */
  constructor(x, y, settings) {
    if (typeof settings.width !== "number" || typeof settings.height !== "number") {
      throw new Error("height and width properties are mandatory when passing settings parameters to an object entity");
    }
    super(x, y, settings.width, settings.height);
    this.children = [];
    if (settings.image) {
      settings.framewidth = settings.framewidth || settings.width;
      settings.frameheight = settings.frameheight || settings.height;
      this.renderable = new Sprite(0, 0, settings);
    }
    if (settings.anchorPoint) {
      this.anchorPoint.setMuted(settings.anchorPoint.x, settings.anchorPoint.y);
    } else {
      this.anchorPoint.setMuted(0, 0);
    }
    if (typeof settings.name === "string") {
      this.name = settings.name;
    }
    this.type = settings.type || "";
    this.id = settings.id || "";
    this.alive = true;
    if (typeof settings.shapes === "undefined") {
      settings.shapes = pool.pull("Polygon", 0, 0, [
        pool.pull("Vector2d", 0, 0),
        pool.pull("Vector2d", this.width, 0),
        pool.pull("Vector2d", this.width, this.height),
        pool.pull("Vector2d", 0, this.height)
      ]);
    }
    this.body = new Body(this, settings.shapes, () => this.onBodyUpdate());
    if (this.width === 0 && this.height === 0) {
      this.resize(this.body.getBounds().width, this.body.getBounds().height);
    }
    this.body.setCollisionMask(settings.collisionMask);
    this.body.setCollisionType(settings.collisionType);
    this.autoTransform = false;
  }
  /**
   * The entity renderable component (can be any objects deriving from me.Renderable, like me.Sprite for example)
   * @type {Renderable}
   */
  get renderable() {
    return this.children[0];
  }
  set renderable(value) {
    if (value instanceof Renderable) {
      this.children[0] = value;
      this.children[0].ancestor = this;
      this.updateBounds();
    } else {
      throw new Error(value + "should extend me.Renderable");
    }
  }
  /** @ignore */
  update(dt) {
    if (this.renderable) {
      this.isDirty |= this.renderable.update(dt);
    }
    return super.update(dt);
  }
  /**
   * update the bounding box for this entity.
   * @param {boolean} [absolute=true] - update the bounds size and position in (world) absolute coordinates
   * @returns {Bounds} this entity bounding box Rectangle object
   */
  updateBounds(absolute = true) {
    let bounds = this.getBounds();
    bounds.clear();
    bounds.addFrame(
      0,
      0,
      this.width,
      this.height
    );
    if (this.children && this.children.length > 0) {
      bounds.addBounds(this.children[0].getBounds());
    }
    if (this.body) {
      bounds.addBounds(this.body.getBounds());
    }
    if (absolute === true) {
      let absPos = this.getAbsolutePosition();
      bounds.centerOn(absPos.x + bounds.x + bounds.width / 2, absPos.y + bounds.y + bounds.height / 2);
    }
    return bounds;
  }
  /**
   * update the bounds when the body is modified
   */
  onBodyUpdate() {
    this.updateBounds();
  }
  preDraw(renderer2) {
    renderer2.save();
    renderer2.translate(
      this.pos.x + this.body.getBounds().x,
      this.pos.y + this.body.getBounds().y
    );
    if (this.renderable instanceof Renderable) {
      renderer2.translate(
        this.anchorPoint.x * this.body.getBounds().width,
        this.anchorPoint.y * this.body.getBounds().height
      );
    }
  }
  /**
   * draw this entity (automatically called by melonJS)
   * @param {CanvasRenderer|WebGLRenderer} renderer - a renderer instance
   * @param {Camera2d} [viewport] - the viewport to (re)draw
   */
  draw(renderer2, viewport) {
    let renderable = this.renderable;
    if (renderable instanceof Renderable) {
      renderable.preDraw(renderer2);
      renderable.draw(renderer2, viewport);
      renderable.postDraw(renderer2);
    }
  }
  /**
   * Destroy function
   * @ignore
   */
  destroy() {
    if (this.renderable) {
      this.renderable.destroy.apply(this.renderable, arguments);
      this.children.splice(0, 1);
    }
    super.destroy(arguments);
  }
  /**
   * onDeactivateEvent Notification function
   */
  onDeactivateEvent() {
    if (this.renderable && this.renderable.onDeactivateEvent) {
      this.renderable.onDeactivateEvent();
    }
  }
};
function autoDetectRenderer(options) {
  try {
    if (isWebGLSupported(options)) {
      return new WebGLRenderer(options);
    }
  } catch (e) {
    console.log("Error creating WebGL renderer :" + e.message);
  }
  return new CanvasRenderer(options);
}
function scale(game2, x, y) {
  let renderer2 = game2.renderer;
  let canvas = renderer2.getCanvas();
  let context = renderer2.getContext();
  let settings = renderer2.settings;
  let pixelRatio = devicePixelRatio;
  let w = settings.zoomX = canvas.width * x * pixelRatio;
  let h = settings.zoomY = canvas.height * y * pixelRatio;
  renderer2.scaleRatio.set(x * pixelRatio, y * pixelRatio);
  canvas.style.width = w / pixelRatio + "px";
  canvas.style.height = h / pixelRatio + "px";
  renderer2.setAntiAlias(context, settings.antiAlias);
  renderer2.setBlendMode(settings.blendMode, context);
  game2.repaint();
}
function onresize(game2) {
  let renderer2 = game2.renderer;
  let settings = renderer2.settings;
  let scaleX = settings.scale, scaleY = settings.scale;
  let nodeBounds;
  if (settings.autoScale) {
    let canvasMaxWidth = Infinity;
    let canvasMaxHeight = Infinity;
    if (globalThis.getComputedStyle) {
      let style = globalThis.getComputedStyle(renderer2.getCanvas(), null);
      canvasMaxWidth = parseInt(style.maxWidth, 10) || Infinity;
      canvasMaxHeight = parseInt(style.maxHeight, 10) || Infinity;
    }
    if (typeof game2.settings.scaleTarget !== "undefined") {
      nodeBounds = getElementBounds(game2.settings.scaleTarget);
    } else {
      nodeBounds = getParentBounds(game2.getParentElement());
    }
    let _max_width = Math.min(canvasMaxWidth, nodeBounds.width);
    let _max_height = Math.min(canvasMaxHeight, nodeBounds.height);
    let screenRatio = _max_width / _max_height;
    if (settings.scaleMethod === "fill-min" && screenRatio > renderer2.designRatio || settings.scaleMethod === "fill-max" && screenRatio < renderer2.designRatio || settings.scaleMethod === "flex-width") {
      let sWidth = Math.min(canvasMaxWidth, settings.height * screenRatio);
      scaleX = scaleY = _max_width / sWidth;
      renderer2.resize(Math.floor(sWidth), settings.height);
    } else if (settings.scaleMethod === "fill-min" && screenRatio < renderer2.designRatio || settings.scaleMethod === "fill-max" && screenRatio > renderer2.designRatio || settings.scaleMethod === "flex-height") {
      let sHeight = Math.min(canvasMaxHeight, settings.width * (_max_height / _max_width));
      scaleX = scaleY = _max_height / sHeight;
      renderer2.resize(settings.width, Math.floor(sHeight));
    } else if (settings.scaleMethod === "flex") {
      renderer2.resize(Math.floor(_max_width), Math.floor(_max_height));
    } else if (settings.scaleMethod === "stretch") {
      scaleX = _max_width / settings.width;
      scaleY = _max_height / settings.height;
    } else {
      if (screenRatio < renderer2.designRatio) {
        scaleX = scaleY = _max_width / settings.width;
      } else {
        scaleX = scaleY = _max_height / settings.height;
      }
    }
  }
  scale(game2, scaleX, scaleY);
}
function consoleHeader(app) {
  let renderType = app.renderer.type;
  let gpu_renderer = typeof app.renderer.GPURenderer === "string" ? " (" + app.renderer.GPURenderer + ")" : "";
  let depthTesting = renderType.includes("WebGL") && app.renderer.depthTest === "z-buffer" ? "Depth Test | " : "";
  let audioType = hasWebAudio ? "Web Audio" : "HTML5 Audio";
  console.log(
    renderType + " renderer" + gpu_renderer + " | " + depthTesting + audioType + " | pixel ratio " + devicePixelRatio + " | " + (platform.nodeJS ? "node.js" : platform.isMobile ? "mobile" : "desktop") + " | " + getScreenOrientation() + " | " + language
  );
  console.log(
    "resolution: requested " + app.settings.width + "x" + app.settings.height + ", got " + app.renderer.width + "x" + app.renderer.height
  );
}
var Application = class {
  /**
   * @param {number} width - The width of the canvas viewport
   * @param {number} height - The height of the canvas viewport
   * @param {ApplicationSettings} [options] - The optional parameters for the application and default renderer
   * @throws Will throw an exception if it fails to instantiate a renderer
   */
  constructor(width, height, options) {
    this.parentElement = void 0;
    this.renderer = void 0;
    this.viewport = void 0;
    this.world = void 0;
    this.mergeGroup = true;
    this.lastUpdate = 0;
    this.isInitialized = false;
    this.settings = void 0;
    this.pauseOnBlur = true;
    this.resumeOnFocus = true;
    this.stopOnBlur = false;
    this.isDirty = true;
    this.isAlwaysDirty = false;
    this.frameCounter = 0;
    this.frameRate = 1;
    this.accumulator = 0;
    this.accumulatorMax = 0;
    this.accumulatorUpdateDelta = 0;
    this.stepSize = 1e3 / 60;
    this.updateDelta = 0;
    this.lastUpdateStart = null;
    this.updateAverageDelta = 0;
    if (options.legacy !== true) {
      this.init(width, height, options);
    }
  }
  /**
   * init the game instance (create a physic world, update starting time, etc..)
   * @param {number} width - The width of the canvas viewport
   * @param {number} height - The height of the canvas viewport
   * @param {ApplicationSettings} [options] - The optional parameters for the application and default renderer
   */
  init(width, height, options) {
    this.settings = Object.assign(ApplicationSettings, options || {});
    this.settings.width = width;
    this.settings.height = height;
    this.settings.transparent = !!this.settings.transparent;
    this.settings.antiAlias = !!this.settings.antiAlias;
    this.settings.failIfMajorPerformanceCaveat = !!this.settings.failIfMajorPerformanceCaveat;
    this.settings.depthTest = this.settings.depthTest === "z-buffer" ? "z-buffer" : "sorting";
    this.settings.subPixel = !!this.settings.subPixel;
    this.settings.verbose = !!this.settings.verbose;
    if (this.settings.scaleMethod.search(/^(fill-(min|max)|fit|flex(-(width|height))?|stretch)$/) !== -1) {
      this.settings.autoScale = this.settings.scale === "auto" || true;
    } else {
      this.settings.scaleMethod = "fit";
      this.settings.autoScale = this.settings.scale === "auto" || false;
    }
    let uriFragment = getUriFragment();
    if (uriFragment.webgl === true || uriFragment.webgl1 === true || uriFragment.webgl2 === true) {
      this.settings.renderer = WEBGL;
      if (uriFragment.webgl1 === true) {
        this.settings.preferWebGL1 = true;
      }
    } else if (uriFragment.canvas === true) {
      this.settings.renderer = CANVAS;
    }
    this.settings.scale = this.settings.autoScale ? 1 : +this.settings.scale || 1;
    this.settings.zoomX = width * this.settings.scale;
    this.settings.zoomY = height * this.settings.scale;
    this.parentElement = getElement(this.settings.parent);
    if (typeof this.settings.scaleTarget !== "undefined") {
      this.settings.scaleTarget = getElement(this.settings.scaleTarget);
    }
    if (typeof this.settings.renderer === "number") {
      switch (this.settings.renderer) {
        case AUTO:
        case WEBGL:
          this.renderer = autoDetectRenderer(this.settings);
          break;
        default:
          this.renderer = new CanvasRenderer(this.settings);
          break;
      }
    } else {
      let CustomRenderer = this.settings.renderer;
      this.renderer = new CustomRenderer(this.settings);
    }
    on(WINDOW_ONRESIZE, () => onresize(this), this);
    on(WINDOW_ONORIENTATION_CHANGE, () => onresize(this), this);
    this.parentElement.appendChild(this.renderer.getCanvas());
    if (platform.isMobile) {
      enableSwipe(false);
    }
    onresize(this);
    if ("MutationObserver" in globalThis) {
      let observer = new MutationObserver(() => onresize(this));
      observer.observe(this.parentElement, {
        attributes: false,
        childList: true,
        subtree: true
      });
    }
    if (this.settings.consoleHeader !== false) {
      consoleHeader(this);
    }
    this.world = new World(0, 0, this.settings.width, this.settings.height);
    this.world.app = this;
    this.world.physic = this.settings.physic;
    this.lastUpdate = globalThis.performance.now();
    this.world.autoSort = !(this.renderer.type === "WEBGL" && this.settings.depthTest === "z-buffer");
    this.isInitialized = true;
    emit(GAME_INIT, this);
    on(STATE_CHANGE, this.repaint, this);
    on(STATE_RESTART, this.repaint, this);
    on(STATE_RESUME, this.repaint, this);
    on(STAGE_RESET, this.reset, this);
    on(TICK, (time) => {
      this.update(time);
      this.draw();
    }, this);
    on(BLUR, () => {
      if (this.stopOnBlur === true) {
        state.stop(true);
      }
      if (this.pauseOnBlur === true) {
        state.pause(true);
      }
    });
    on(FOCUS, () => {
      if (this.stopOnBlur === true) {
        state.restart(true);
      }
      if (this.resumeOnFocus === true) {
        state.resume(true);
      }
    });
  }
  /**
   * reset the game Object manager
   * destroy all current objects
   */
  reset() {
    let current = state.get();
    if (typeof current !== "undefined") {
      this.viewport = current.cameras.get("default");
    }
    emit(GAME_RESET);
    this.updateFrameRate();
  }
  /**
   * Specify the property to be used when sorting renderables for this application game world.
   * Accepted values : "x", "y", "z", "depth"
   * @type {string}
   * @see World.sortOn
   */
  get sortOn() {
    return this.world.sortOn;
  }
  set sortOn(value) {
    this.world.sortOn = value;
  }
  /**
   * Fired when a level is fully loaded and all renderable instantiated. <br>
   * Additionnaly the level id will also be passed to the called function.
   * @example
   * // call myFunction () everytime a level is loaded
   * me.game.onLevelLoaded = this.myFunction.bind(this);
   */
  onLevelLoaded() {
  }
  /**
   * Update the renderer framerate using the system config variables.
   * @see timer.maxfps
   * @see World.fps
   */
  updateFrameRate() {
    this.frameCounter = 0;
    this.frameRate = ~~(0.5 + 60 / timer.maxfps);
    this.stepSize = 1e3 / this.world.fps;
    this.accumulator = 0;
    this.accumulatorMax = this.stepSize * 10;
    this.isAlwaysDirty = timer.maxfps > this.world.fps;
  }
  /**
   * Returns the parent HTML Element holding the main canvas of this application
   * @returns {HTMLElement} the parent HTML element
   */
  getParentElement() {
    return this.parentElement;
  }
  /**
   * force the redraw (not update) of all objects
   */
  repaint() {
    this.isDirty = true;
  }
  /**
   * update all objects related to this game active scene/stage
   * @param {number} time - current timestamp as provided by the RAF callback
   */
  update(time) {
    if (++this.frameCounter % this.frameRate === 0) {
      this.frameCounter = 0;
      emit(GAME_BEFORE_UPDATE, time);
      this.accumulator += timer.getDelta();
      this.accumulator = Math.min(this.accumulator, this.accumulatorMax);
      this.updateDelta = timer.interpolation ? timer.getDelta() : this.stepSize;
      this.accumulatorUpdateDelta = timer.interpolation ? this.updateDelta : Math.max(this.updateDelta, this.updateAverageDelta);
      while (this.accumulator >= this.accumulatorUpdateDelta || timer.interpolation) {
        this.lastUpdateStart = globalThis.performance.now();
        if (state.isPaused() !== true) {
          emit(GAME_UPDATE, time);
        }
        this.isDirty = this.world.update(this.updateDelta);
        this.isDirty = state.current().update(this.updateDelta) || this.isDirty;
        this.lastUpdate = globalThis.performance.now();
        this.updateAverageDelta = this.lastUpdate - this.lastUpdateStart;
        this.accumulator -= this.accumulatorUpdateDelta;
        if (timer.interpolation) {
          this.accumulator = 0;
          break;
        }
      }
      emit(GAME_AFTER_UPDATE, this.lastUpdate);
    }
  }
  /**
   * draw the active scene/stage associated to this game
   */
  draw() {
    if (this.renderer.isContextValid === true && (this.isDirty || this.isAlwaysDirty)) {
      emit(GAME_BEFORE_DRAW, globalThis.performance.now());
      this.renderer.clear();
      state.current().draw(this.renderer, this.world);
      this.isDirty = false;
      this.renderer.flush();
      emit(GAME_AFTER_DRAW, globalThis.performance.now());
    }
  }
};
var cache = {};
var BasePlugin = class {
  /**
   * @param {Application} [app] - a reference to the app/game that registered this plugin
   */
  constructor(app = game) {
    this.version = "17.4.0";
    this.app = app;
  }
};
var Base = class extends BasePlugin {
  constructor() {
    warning("plugin.Base", "plugin.BasePlugin", "15.1.6");
    super();
  }
};
function patch(proto, name, fn) {
  if (typeof proto.prototype !== "undefined") {
    proto = proto.prototype;
  }
  if (typeof proto[name] === "function") {
    let _parent = proto[name];
    Object.defineProperty(proto, name, {
      "configurable": true,
      "value": /* @__PURE__ */ function(name2, fn2) {
        return function() {
          this._patched = _parent;
          let ret = fn2.apply(this, arguments);
          this._patched = null;
          return ret;
        };
      }(name, fn)
    });
  } else {
    throw new Error(name + " is not an existing function");
  }
}
function register(plugin2, name = plugin2.toString().match(/ (\w+)/)[1]) {
  if (cache[name]) {
    throw new Error("plugin " + name + " already registered");
  }
  let _args = [];
  if (arguments.length > 2) {
    _args = Array.prototype.slice.call(arguments, 1);
  }
  _args[0] = plugin2;
  let instance = new (plugin2.bind.apply(plugin2, _args))();
  if (typeof instance === "undefined" || !(instance instanceof BasePlugin)) {
    throw new Error("Plugin should extend the BasePlugin Class !");
  }
  if (checkVersion(instance.version, version) > 0) {
    throw new Error("Plugin version mismatch, expected: " + instance.version + ", got: " + version);
  }
  cache[name] = instance;
}
function get(classType) {
  for (const name in cache) {
    if (typeof classType === "string" && classType === name || cache[name] instanceof classType) {
      return cache[name];
    }
  }
}
var plugin = {
  __proto__: null,
  Base,
  BasePlugin,
  cache,
  get,
  patch,
  register
};
Object.defineProperty(Renderer.prototype, "Texture", {
  /**
   * @ignore
   */
  get: function() {
    warning("me.video.renderer.Texture", "me.TextureAtlas", "10.4.0");
    return TextureAtlas;
  }
});
var DraggableEntity = class extends Draggable {
  /**
   * @param {number} x - the x coordinates of the draggable object
   * @param {number} y - the y coordinates of the draggable object
   * @param {object} settings - Entity properties (see {@link Entity})
   */
  constructor(x, y, settings) {
    warning("DraggableEntity", "Draggable", "10.5.0");
    super(x, y, settings.width, settings.height);
  }
};
var DroptargetEntity = class extends DropTarget {
  /**
   * @param {number} x - the x coordinates of the draggable object
   * @param {number} y - the y coordinates of the draggable object
   * @param {object} settings - Entity properties (see {@link Entity})
   */
  constructor(x, y, settings) {
    warning("DroptargetEntity", "DropTarget", "10.5.0");
    super(x, y, settings.width, settings.height);
  }
};
Renderer.prototype.getScreenCanvas = function() {
  warning("getScreenCanvas", "getCanvas", "13.1.0");
  return this.getCanvas();
};
Renderer.prototype.getScreenContext = function() {
  warning("getScreenContext", "getContext", "13.1.0");
  return this.getContext();
};
var GUI_Object = class extends UISpriteElement {
  /**
   * @param {number} x - the x coordinate of the GUI Object
   * @param {number} y - the y coordinate of the GUI Object
   * @param {object} settings - See {@link Sprite}
   */
  constructor(x, y, settings) {
    warning("GUI_Object", "UISpriteElement or UITextButton", "14.0.0");
    super(x, y, settings);
  }
};
Renderer.prototype.getWidth = function() {
  warning("getWidth", "width", "15.12.0");
  return this.width;
};
Renderer.prototype.getHeight = function() {
  warning("getHeight", "height", "15.12.0");
  return this.height;
};
var CanvasTexture = class extends CanvasRenderTarget {
  /**
   * @param {number} width - the desired width of the canvas
   * @param {number} height - the desired height of the canvas
   * @param {object} attributes - The attributes to create both the canvas and context
   * @param {boolean} [attributes.context="2d"] - the context type to be created ("2d", "webgl", "webgl2")
   * @param {boolean} [attributes.offscreenCanvas=false] - will create an offscreenCanvas if true instead of a standard canvas
   * @param {boolean} [attributes.willReadFrequently=false] - Indicates whether or not a lot of read-back operations are planned
   * @param {boolean} [attributes.antiAlias=false] - Whether to enable anti-aliasing, use false (default) for a pixelated effect.
   */
  constructor(width, height, attributes) {
    warning("CanvasTexture", "CanvasRenderTarget", "17.1.0");
    super(width, height, attributes);
  }
};
CanvasRenderer.prototype.setLineWidth = function(width) {
  warning("setLineWidth", "lineWidth", "17.3.0");
  this.lineWidth = width;
};
WebGLRenderer.prototype.setLineWidth = function(width) {
  warning("setLineWidth", "lineWidth", "17.3.0");
  this.lineWidth = width;
};
var version = "17.4.0";
var initialized = false;
var skipAutoInit = false;
var game = new Application(0, 0, { legacy: true });
function boot() {
  if (initialized === true) {
    return;
  }
  console.log("melonJS 2 (v" + version + ") | http://melonjs.org");
  pool.register("me.Entity", Entity);
  pool.register("me.Collectable", Collectable);
  pool.register("me.Trigger", Trigger);
  pool.register("me.Light2d", Light2d);
  pool.register("me.Tween", Tween, true);
  pool.register("me.Color", Color, true);
  pool.register("me.Particle", Particle, true);
  pool.register("me.Sprite", Sprite);
  pool.register("me.NineSliceSprite", NineSliceSprite);
  pool.register("me.Renderable", Renderable);
  pool.register("me.Text", Text, true);
  pool.register("me.BitmapText", BitmapText);
  pool.register("me.BitmapTextData", BitmapTextData, true);
  pool.register("me.ImageLayer", ImageLayer);
  pool.register("me.ColorLayer", ColorLayer, true);
  pool.register("me.Vector2d", Vector2d, true);
  pool.register("me.Vector3d", Vector3d, true);
  pool.register("me.ObservableVector2d", ObservableVector2d, true);
  pool.register("me.ObservableVector3d", ObservableVector3d, true);
  pool.register("me.Matrix2d", Matrix2d, true);
  pool.register("me.Matrix3d", Matrix3d, true);
  pool.register("me.Rect", Rect, true);
  pool.register("me.RoundRect", RoundRect, true);
  pool.register("me.Polygon", Polygon, true);
  pool.register("me.Line", Line, true);
  pool.register("me.Point", Point, true);
  pool.register("me.Ellipse", Ellipse, true);
  pool.register("me.Bounds", Bounds, true);
  pool.register("Entity", Entity);
  pool.register("Collectable", Collectable);
  pool.register("Trigger", Trigger);
  pool.register("Light2d", Light2d);
  pool.register("Tween", Tween, true);
  pool.register("Color", Color, true);
  pool.register("Particle", Particle, true);
  pool.register("Sprite", Sprite);
  pool.register("NineSliceSprite", NineSliceSprite);
  pool.register("Renderable", Renderable);
  pool.register("Text", Text, true);
  pool.register("BitmapText", BitmapText);
  pool.register("BitmapTextData", BitmapTextData, true);
  pool.register("ImageLayer", ImageLayer);
  pool.register("ColorLayer", ColorLayer, true);
  pool.register("Vector2d", Vector2d, true);
  pool.register("Vector3d", Vector3d, true);
  pool.register("ObservableVector2d", ObservableVector2d, true);
  pool.register("ObservableVector3d", ObservableVector3d, true);
  pool.register("Matrix2d", Matrix2d, true);
  pool.register("Matrix3d", Matrix3d, true);
  pool.register("Rect", Rect, true);
  pool.register("RoundRect", RoundRect, true);
  pool.register("Polygon", Polygon, true);
  pool.register("Line", Line, true);
  pool.register("Point", Point, true);
  pool.register("Ellipse", Ellipse, true);
  pool.register("Bounds", Bounds, true);
  pool.register("CanvasRenderTarget", CanvasRenderTarget, true);
  emit(BOOT);
  setNocache(getUriFragment().nocache || false);
  initKeyboardEvent();
  initialized = true;
  if (skipAutoInit === true) {
    emit(DOM_READY);
  }
}
onReady(() => {
  if (skipAutoInit === false) {
    boot();
  }
});

export {
  math,
  pool,
  Color,
  Vector2d,
  Vector3d,
  ObservableVector2d,
  ObservableVector3d,
  Matrix2d,
  Matrix3d,
  Polygon,
  Line,
  Ellipse,
  Point,
  Rect,
  RoundRect,
  QuadTree,
  Bounds,
  collision,
  event,
  audio,
  save,
  device,
  CANVAS,
  WEBGL,
  AUTO,
  video,
  Pointer,
  input,
  GLShader,
  Renderable,
  Camera2d,
  Stage,
  utils,
  TMXTileset,
  TMXTilesetGroup,
  TMXUtils,
  Tile,
  CanvasRenderTarget,
  Renderer,
  TextureAtlas,
  CanvasRenderer,
  TMXLayer,
  Container,
  TMXRenderer,
  TMXOrthogonalRenderer,
  TMXIsometricRenderer,
  TMXHexagonalRenderer,
  TMXStaggeredRenderer,
  TMXTileMap,
  level,
  loader,
  Sprite,
  state,
  timer,
  Body,
  Tween,
  Compositor,
  PrimitiveCompositor,
  QuadCompositor,
  WebGLRenderer,
  ColorLayer,
  ImageLayer,
  NineSliceSprite,
  UIBaseElement,
  Text,
  BitmapText,
  UITextButton,
  UISpriteElement,
  Collectable,
  Trigger,
  Light2d,
  BitmapTextData,
  Draggable,
  DropTarget,
  World,
  ParticleEmitterSettings,
  ParticleEmitter,
  Particle,
  Entity,
  Application,
  cache,
  plugin,
  DraggableEntity,
  DroptargetEntity,
  GUI_Object,
  CanvasTexture,
  version,
  initialized,
  skipAutoInit,
  game,
  boot
};
/*! Bundled license information:

melonjs/dist/melonjs.module.js:
  (*!
   * melonJS Game Engine - v17.4.0
   * http://www.melonjs.org
   * melonjs is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * @copyright (C) 2011 - 2024 Olivier Biot (AltByte Pte Ltd)
   *)

melonjs/dist/melonjs.module.js:
  (*!
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
*/
//# sourceMappingURL=chunk-L3DLO64J.js.map
